# 레퍼런스 정렬 스킬 — 레퍼런스 정렬 (Reference Alignment)

주어진 글을 레퍼런스 글(1월 19일 게시물)의 패턴에 맞춰 정렬합니다.
**구조적 템플릿**과 **품질 수준** 두 축을 모두 점검합니다.

기존 파이프라인이 **"존재하는가?"**를 확인했다면, 이 스킬은 **"레퍼런스 수준인가?"**를 확인합니다.

## 파이프라인 위치

```
/edit-writing → /clarify-writing → /refine-style → /smooth-flow → /verify-facts → /deep-review → ▶ /align-reference
  골격             이해               목소리          흐름            사실             독자 시뮬레이션     레퍼런스 정렬
```

이 스킬은 파이프라인의 **일곱 번째(마지막) 단계**입니다:
- 글의 뼈대 → `/edit-writing`
- 독자의 이해 → `/clarify-writing`
- 톤, 리듬, 서사 → `/refine-style`
- 읽기 흐름 → `/smooth-flow`
- 사실관계 → `/verify-facts`
- 독자 경험 통합 점검 → `/deep-review`

마지막인 이유:
- 1~6단계가 글 내부 품질을 끌어올린 후, 레퍼런스 기준으로 남은 격차를 메움
- 이전 단계의 수정 위에서 동작하므로 충돌 없음
- 구조적 변경(`<br>` 제거 등)은 다른 스킬의 수정을 덮어쓸 위험이 있으므로 마지막이 적합

## 인자
- `$ARGUMENTS`: 수정할 파일 경로 (선택사항). 없으면 사용자에게 파일 경로를 요청합니다.

---

## 점검 카테고리

2개 카테고리, 9개 항목으로 구성됩니다.

---

## 카테고리 1: 구조적 템플릿 정합성

레퍼런스 글의 구조적 패턴에 맞춰 형식을 정렬합니다. 직접 수정합니다.

---

### 1. 마감 섹션 제목

`## 정리`를 `## 마무리`로 변환합니다. 부제가 있으면 유지합니다.

```
# Before
## 정리: 분산이 핵심

# After
## 마무리: 분산이 핵심
```

### 점검 항목
- [ ] `## 마무리` 제목을 사용하고 있는가?

---

### 2. 마감 섹션 내부 구조

마감 섹션은 세 부분으로 구성됩니다: **불릿 리스트** + **성찰적 문단** + **내러티브 브릿지**.

#### 불릿 리스트

번호 리스트(1. 2. 3.)를 불릿 리스트(- )로 변환합니다.

```
# Before
1. DNS는 분산 데이터베이스이다.
2. 권한 위임으로 관리 책임을 나눈다.

# After
- DNS는 분산 데이터베이스입니다.
- 권한 위임으로 관리 책임을 나눕니다.
```

#### 성찰적 문단

불릿 리스트 뒤에 핵심 포인트를 연결하거나 의미를 부여하는 1~2문장을 추가합니다.

```
# 레퍼런스 예시 (NetworkCommunication-1)
- 전자기파는 매질 없이 공간을 통해 정보를 전달합니다.
- 주파수에 따라 회절, 대역폭 등 전파 특성이 달라집니다.
...

이 물리적 제약은 바뀌지 않습니다. 통신 기술은 이 제약 안에서 정보를 효율적으로
인코딩하고, 오류를 검출하고 정정하는 방법을 발전시켜 왔습니다.
```

성찰적 문단이 없고 불릿 뒤 바로 다음 글 링크가 오면, 핵심을 연결하는 문단을 추가합니다.

#### 내러티브 브릿지

다음 글 링크 앞에 호기심을 유발하는 서사적 연결을 추가합니다.

```
# Before
[Part 2](/dev/network/NATFirewall-2/)에서는 방화벽의 원리와 상태 추적을 살펴봅니다.

# After (레퍼런스 수준)
이 글에서는 소켓이 무엇인지, 어떻게 사용하는지 살펴봤습니다.
`connect()`와 `accept()`가 "연결을 맺는다"고 했는데,
그 안에서는 어떤 일이 일어날까요?

[Part 2](/dev/network/SocketTransport-2/)에서는 TCP 연결의 상태 머신을 살펴봅니다.
3-Way Handshake의 각 단계, TCP의 11가지 상태, TIME_WAIT가 왜 필요한지 알아봅니다.
```

### 점검 항목
- [ ] 불릿 리스트(- 접두사)를 사용하고 있는가?
- [ ] 성찰적 문단이 존재하는가?
- [ ] 내러티브 브릿지가 존재하는가?

---

### 3. 다음 글 연결

단순 링크를 서사적 연결로 보강합니다. 항목 2의 내러티브 브릿지와 동일한 기준입니다.

다음 패턴을 따릅니다:
1. 현재 글에서 다룬 핵심을 1~2문장으로 요약
2. 다음 글 주제에 대한 질문이나 호기심 유발
3. 링크 + 다음 글에서 다룰 내용 구체적 나열

---

### 4. `<br>` 밀도 정규화

#### 레퍼런스 패턴

```
같은 개념을 설명하는 연속 문단 사이: 빈 줄만 (br 없음)
개념이 전환되는 지점: 빈 줄 + <br> + 빈 줄
섹션 제목(##, ###) 직전/직후: br 없음
목표 밀도: 콘텐츠 12~20줄당 <br> 1개
```

#### 수정 전략

1. 같은 개념 내 연속 문단 사이의 `<br>`를 제거합니다
2. 섹션 제목 직전/직후의 `<br>`를 제거합니다
3. 콘텐츠 12줄 이내에 `<br>`가 2개 이상이면 하나를 제거합니다
4. 개념 전환점(새로운 소주제, 대조, 트레이드오프 전환)에만 `<br>`를 유지합니다

#### 비교

```
# Before (NATFirewall-1 스타일: 과밀)
IPv4 주소가 부족해질 것이 명확해졌습니다.

<br>

클래스 기반 할당이 비효율적이었습니다.

<br>

1000개의 호스트가 필요한 조직을 생각해봅시다.

<br>

클래스 C(254개)는 부족하므로 클래스 B(65,534개)를 할당받아야 합니다.

<br>

결과적으로 64,000개 이상의 주소가 낭비됩니다.

# After (레퍼런스 스타일: 전략적)
IPv4 주소가 부족해질 것이 명확해졌습니다.

클래스 기반 할당이 비효율적이었습니다. 1000개의 호스트가 필요한 조직을 생각해봅시다.
클래스 C(254개)는 부족하므로 클래스 B(65,534개)를 할당받아야 합니다.
결과적으로 64,000개 이상의 주소가 낭비됩니다.

<br>

이런 낭비가 전 세계적으로 누적되었습니다.
```

### 점검 항목
- [ ] `<br>` 비율이 12~20줄당 1개 이하인가?
- [ ] 같은 개념 내에 불필요한 `<br>`가 없는가?
- [ ] 섹션 제목 직전/직후에 `<br>`가 없는가?

---

### 5. 교차 참조 섹션 보강

#### 레퍼런스 패턴

```markdown
**관련 글**
- [타 시리즈 관련 글](/경로/)

**시리즈**
- 현재 시리즈 Part 1 (현재 글)
- [현재 시리즈 Part 2](/경로/)
- [현재 시리즈 Part 3](/경로/)

**심화 시리즈** (기초 시리즈에서만)
- [심화 시리즈 Part 1](/경로/)
```

#### 수정 전략

1. `**시리즈**` 섹션이 없으면 추가합니다
   - 현재 시리즈의 모든 파트를 나열합니다
   - 현재 글은 "(현재 글)" 표시를 합니다
2. `**관련 글**`에 같은 시리즈 파트가 포함되어 있으면 `**시리즈**`로 이동합니다
3. `**관련 글**`은 타 시리즈의 관련 글로 정리합니다
4. 기초 시리즈(NetworkCommunication 등)에서 심화 시리즈가 있으면 `**심화 시리즈**`를 추가합니다

### 점검 항목
- [ ] `**시리즈**` 섹션이 존재하는가?
- [ ] 전체 파트가 나열되어 있는가?
- [ ] 현재 글에 "(현재 글)" 표시가 있는가?
- [ ] `**관련 글**`이 타 시리즈 글로 구성되어 있는가?

---

### 6. 섹션 순서 정합성

마감 이후 구간의 순서를 확인합니다.

```
## 마무리
(불릿 리스트)
(성찰적 문단)
(내러티브 브릿지 + 다음 글 링크)

<br>

---

**관련 글**
- ...

**시리즈**
- ...
```

순서가 다르면 재배치합니다.

### 점검 항목
- [ ] 마감 → `<br>` → `---` → 교차 참조 순서인가?
- [ ] `**관련 글**`이 `**시리즈**`보다 앞에 있는가?

---

## 카테고리 2: 레퍼런스 대비 품질 정합성

레퍼런스 글의 품질 수준에 맞춰 내용을 보강합니다. 직접 수정합니다.

기존 파이프라인이 "존재하는가?"를 확인했다면, 이 카테고리는 "레퍼런스 수준인가?"를 확인합니다.

---

### 7. 도입부 서사 깊이

#### 레퍼런스 기준

도입부(프론트매터 뒤 ~ 첫 `---`까지)가 **15줄 이상**이며, 다음 패턴 중 하나를 따릅니다:

**패턴 A: 역사적 서사** (NetworkCommunication-1)
```
[역사적 사건/인물] → [원리/발견] → [자연스러운 질문] → [한계/새로운 문제]

"1837년, 새뮤얼 모스는 전선을 통해 전기 신호를 보내는 데 성공했습니다."
→ "원리는 간단했습니다. 스위치를 누르면..."
→ "전선 없이도 정보를 보낼 수 있을까요?"
→ "1864년, 맥스웰은 한 가지 예측을 내놓았습니다."
```

**패턴 B: 문제-탐색 서사** (SocketTransport-1)
```
[기존 방식 소개] → [한계 드러남] → [핵심 질문] → [새로운 접근 필요]

"1970년대 Unix에서 프로세스들은 서로 통신해야 했습니다."
→ "하지만 이것들은 모두 같은 컴퓨터 안에서만 작동했습니다."
→ "다른 컴퓨터에 있는 프로세스와 통신하려면 어떻게 해야 하는가?"
→ "네트워크를 통한 통신을 위한 새로운 추상화가 필요했습니다."
```

#### 대상 글의 전형적 문제

```
# NetworkPerformance-1 (4줄)
"느리다"는 말은 흔히 듣지만, 정확히 무엇이 느린 걸까요?
네트워크 성능을 개선하려면 먼저 지연의 원인을 이해해야 합니다.
→ 질문은 있지만, 서사/맥락이 전혀 없음. 바로 정의로 넘어감.
```

#### 수정 전략

1. 도입부가 15줄 미만이면 보강합니다
2. 해당 주제의 역사적 맥락, 문제 상황, "왜 이것이 필요했는가"를 추가합니다
3. 기존 도입부의 질문/요약은 유지하되, 그 앞에 서사를 확장합니다

#### /refine-style과의 차이

`/refine-style`은 "정의 나열로 시작하는가?"를 확인하고 서사적 전환을 시도합니다.
이 스킬은 "도입부가 레퍼런스만큼 풍부한가?"를 확인하고, 4줄 도입을 15줄 이상으로 확장합니다.

### 점검 항목
- [ ] 도입부가 15줄 이상인가?
- [ ] 역사적 맥락 또는 문제 구축 서사가 존재하는가?

---

### 8. 설명 충분성

#### 레퍼런스 기준

**질문에 대한 답변 깊이**: 질문을 던진 후 최소 2~3문장으로 답변합니다.

```
# 레퍼런스 (NetworkCommunication-1)
"음성 신호를 직접 전송하려면 문제가 생깁니다."
→ "음성의 주파수는 300Hz~3400Hz 정도입니다."
→ "3000Hz의 파장은 약 10만 미터이므로, 효율적인 안테나 길이는 25km가 됩니다."
→ "이런 안테나는 만들 수 없습니다."
→ "이 문제를 해결하는 것이 변조(Modulation)입니다."

# 대상 (NATFirewall-1)
"왜 이 대역들일까요?"
→ "이 대역들은 이미 사용되지 않던 주소 블록이었기에..."
→ (한 문장으로 끝)
```

**순진한 해법 → 실패 → 진짜 해법 패턴**: 주요 개념 도입 시 적용합니다.

```
패턴: [문제] → [직관적 접근] → [실패 이유] → [진짜 해법]

# 레퍼런스 (SocketTransport-1)
문제: 프로세스 간 통신
순진한 해법: 기존 IPC (파이프, 메시지 큐)
실패: 같은 컴퓨터 안에서만 작동
진짜 해법: Berkeley Sockets
```

**불릿 나열 → 설명 전환**: 대안/특성을 불릿으로만 나열하지 않고 설명합니다.

```
# Before (NetworkPerformance-1)
대안:
- CDN으로 콘텐츠를 사용자 가까이에 배치
- 에지 컴퓨팅
- 왕복 횟수 줄이기 (프로토콜 최적화)

# After
전파 지연 자체를 줄일 수는 없지만, 그 영향을 줄이는 방법은 있습니다.

CDN은 원본 서버의 콘텐츠를 전 세계 여러 지점에 복제합니다.
서울의 사용자가 미국 서버 대신 한국 PoP에서 응답을 받으면,
RTT가 100ms에서 10ms 미만으로 줄어듭니다.

프로토콜 수준에서는 왕복 횟수 자체를 줄이는 접근이 있습니다.
TLS 1.3은 핸드셰이크를 2 RTT에서 1 RTT로 줄였고,
HTTP/3의 0-RTT는 이전 연결 정보를 재사용하여 첫 요청부터 데이터를 보낼 수 있습니다.
```

#### 수정 전략

1. 질문 뒤 한 문장 답변을 찾아 2~3문장으로 확장합니다
2. 주요 개념에 순진한 해법 패턴이 없으면 추가합니다
3. 불릿만 나열된 곳을 설명 문단으로 전환합니다

#### /clarify-writing과의 차이

`/clarify-writing`은 "설명이 빠진 용어가 있는가?"를 확인합니다.
이 스킬은 "설명이 레퍼런스만큼 깊은가?"를 확인합니다. 설명이 존재하지만 한 문장에 불과한 경우, 레퍼런스 수준으로 확장합니다.

### 점검 항목
- [ ] "왜?" 질문에 대한 답변이 2~3문장 이상인가?
- [ ] 주요 개념에 순진한 해법 → 실패 → 진짜 해법 패턴이 적용되었는가?
- [ ] 불릿만 나열된 곳이 설명 문단으로 전환되었는가?

---

### 9. 개념 간 명시적 연결

#### 레퍼런스 기준

섹션 또는 개념이 전환될 때 앞 내용과의 연결을 명시합니다.

```
# 레퍼런스 예시
"앞서 살펴본 것처럼, 높은 주파수는 파장이 짧아 회절이 잘 일어나지 않습니다."
"앞에서 클라이언트는 bind()를 호출하지 않는다고 했습니다."
"앞에서 소켓이 무엇인지, 5-tuple로 어떻게 식별되는지 살펴봤습니다. 이제 실제로..."
```

#### 대상 글의 전형적 문제

```
# NATFirewall-1
## CIDR의 등장
1993년, CIDR(Classless Inter-Domain Routing)이 도입되었습니다.
→ 이전 섹션(클래스 기반 할당의 비효율)과의 연결이 없음

# After
앞에서 클래스 기반 할당이 어떻게 주소를 낭비하는지 살펴봤습니다.
1993년, 이 문제를 해결하기 위해 CIDR이 도입되었습니다.
```

#### 수정 전략

1. 섹션 시작 지점에서 이전 섹션과의 연결이 없는 곳을 식별합니다
2. "앞에서 ~를 살펴봤습니다", "앞서 살펴본 것처럼" 등의 연결구를 추가합니다
3. 단순 연결구가 아니라, 이전 내용의 핵심을 요약하면서 다음 주제로 전환합니다

#### /smooth-flow와의 차이

`/smooth-flow`는 **섹션 내부**의 문장-문단 간 미시적 연결을 다룹니다.
이 스킬은 **섹션 간** 거시적 연결이 레퍼런스 수준으로 명시적인지를 확인합니다.

### 점검 항목
- [ ] 섹션 전환 지점에 이전 내용과의 명시적 연결이 있는가?
- [ ] 연결이 단순 연결어가 아니라 핵심 요약을 포함하는가?

---

## 다른 커맨드와의 경계

**기존 스킬 = "존재하는가?" / 이 스킬 = "레퍼런스 수준인가?"**

| 기존 스킬 | 기존 스킬의 점검 | 이 스킬의 점검 |
|----------|----------------|--------------|
| `/edit-writing` | 마무리 섹션이 **존재하는가** | 마무리 섹션의 **형식이 레퍼런스와 일치하는가** |
| `/clarify-writing` | 설명이 **빠지지 않았는가** | 설명이 **레퍼런스만큼 깊은가** (한 문장 vs 여러 문장) |
| `/refine-style` | 서사적 도입이 **시도되었는가** | 도입부가 **레퍼런스만큼 풍부한가** (4줄 vs 30줄) |
| `/smooth-flow` | 문장 간 **미시적 연결이 자연스러운가** | **거시적 개념 간 연결이 명시적인가** |
| `/deep-review` | **독자 경험이 자연스러운가** | **글 간 구조/품질이 일관적인가** |

핵심 원칙:
- 기존 스킬이 0→1(부재→존재)이라면, 이 스킬은 1→레퍼런스(존재→충분)
- YAML 프론트매터는 수정하지 않음
- 섹션 제목(`##`)은 마감 제목(정리→마무리) 외에는 수정하지 않음
- 원래 의미를 훼손하지 않음

---

## 작업 프로세스

### 1단계: 파일 읽기 + 시리즈 식별
- `$ARGUMENTS`가 있으면 해당 파일 읽기
- 없으면 사용자에게 파일 경로를 요청
- 제목 패턴으로 시리즈 판별, 같은 시리즈의 다른 파트 경로 확인

### 2단계: 구조 스캔
- 마감 섹션 제목 확인 (`## 마무리` vs `## 정리` vs 기타)
- 마감 섹션 내부: 리스트 형식, 성찰적 문단, 내러티브 브릿지 존재 여부
- 다음 글 연결 형태 (서사적 vs 단순 링크)
- 교차 참조 섹션: `**시리즈**`, `**관련 글**`, `**심화 시리즈**` 존재 여부
- `<br>` 위치 전수 조사
- 섹션 순서

### 3단계: `<br>` 밀도 분석
- 콘텐츠 줄 수 대비 `<br>` 비율 계산
- 같은 개념 내 `<br>` 식별 (12줄 이내에 2개 이상)
- 섹션 제목 직전/직후 `<br>` 식별

### 4단계: 도입부 측정
- 프론트매터 뒤 ~ 첫 `---`까지 줄 수
- 역사적 맥락 / 문제 구축 서사 패턴 존재 여부

### 5단계: 설명 충분성 스캔
- 질문 뒤 한 문장 답변 식별
- 순진한 해법 패턴 적용 여부
- 불릿만 나열된 곳 식별
- 섹션 전환 지점에서 연결구 부재 식별

### 6단계: 수정
우선순위: 구조(1~6) → `<br>` 정규화(4) → 도입부(7) → 설명(8) → 연결(9)

### 7단계: 출력
수정된 글 + 카테고리별 변경 요약

---

## 출력 형식

```
## 레퍼런스 정렬 결과

### 구조적 정합성
| 항목 | 상태 | 변경 내용 |
|------|------|----------|
| 마감 제목 | ✓ 수정 | ## 정리 → ## 마무리 |
| 마감 구조 | ✓ 수정 | 성찰적 문단 추가, 브릿지 보강 |
| <br> 밀도 | ✓ 수정 | 18개 → 9개 (9개 제거) |
| 교차 참조 | ✓ 수정 | **시리즈** 섹션 추가 |
| 섹션 순서 | — 정합 | 변경 없음 |

### 품질 정합성
| 항목 | 상태 | 변경 내용 |
|------|------|----------|
| 도입부 깊이 | ✓ 수정 | 4줄 → 22줄 (역사적 서사 추가) |
| 설명 충분성 | ✓ 수정 | 3개 섹션에서 답변 보강 |
| 개념 간 연결 | ✓ 수정 | 5개 전환 지점에 연결구 추가 |
```

---

## 병렬 작업

- 단일 글: 병렬화 불가 (전체 구조/품질 점검 필요)
- 여러 글에 일괄 적용 시: 글별 병렬 처리 가능

---

## 체크리스트

### 구조적 정합성
- [ ] `## 마무리` 제목 사용
- [ ] 불릿 리스트(- 접두사) 사용
- [ ] 성찰적 문단 존재
- [ ] 내러티브 브릿지 존재
- [ ] `**시리즈**` 섹션 존재 및 전체 파트 나열
- [ ] "(현재 글)" 표시
- [ ] `**관련 글**`이 타 시리즈 글로 구성
- [ ] `<br>` 비율 12~20줄당 1개 이하
- [ ] 같은 개념 내 불필요한 `<br>` 없음
- [ ] 섹션 제목 직전/직후 `<br>` 없음
- [ ] 마감 이후 섹션 순서 정합

### 품질 정합성
- [ ] 도입부 15줄 이상
- [ ] 도입부에 역사적 맥락 또는 문제 구축 서사 존재
- [ ] "왜?" 질문에 대한 답변이 2~3문장 이상
- [ ] 주요 개념에 순진한 해법 → 실패 → 진짜 해법 패턴 적용
- [ ] 불릿 나열이 설명 문단으로 전환됨
- [ ] 섹션 전환 지점에 명시적 연결구 존재
