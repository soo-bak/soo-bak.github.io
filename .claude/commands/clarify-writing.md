# 이해도 높이기 스킬 — 이해 (Comprehension)

주어진 글의 **이해도를 높입니다**. 독자가 외부 지식 없이도 글만으로 개념을 이해할 수 있도록 설명 기법을 점검하고 보완합니다.

**설명의 완성도**를 다듬습니다.

## 파이프라인 위치

```
/edit-writing → ▶ /clarify-writing → /refine-style → /smooth-flow → /verify-facts → /deep-review → /align-reference
  골격              이해                목소리          흐름            사실             독자 시뮬레이션    레퍼런스 정렬
```

이 스킬은 파이프라인의 **두 번째 단계**입니다:
- 글의 뼈대 → `/edit-writing`
- 톤, 리듬, 서사 → `/refine-style`
- 읽기 흐름 → `/smooth-flow`
- 사실관계 → `/verify-facts`
- 독자 경험 통합 점검 → `/deep-review`
- 레퍼런스 정렬 → `/align-reference`

## 인자
- `$ARGUMENTS`: 수정할 파일 경로 (선택사항). 없으면 사용자에게 파일 또는 텍스트를 요청합니다.

---

## 점검 항목

---

## 1. 설명 순서: "왜?" → "무엇?" → "어떻게?"

개념의 필요성(동기)을 먼저 제시하고, 정의와 메커니즘은 그 후에 설명합니다.

### 핵심 패턴

```
[동기/문제] → [정의] → [메커니즘/구현]
```

### 비교

```
# 나쁜 예 (동기 없이 정의부터)
DNS의 핵심 개념은 권한 위임(Delegation)입니다.
→ 독자: "왜 위임이 필요한데?"

# 좋은 예 (SocketTransport-2)
TCP 연결을 수립할 때 3-Way Handshake가 필요합니다.
왜 2번이 아니라 3번일까요?
[2-Way의 문제를 보여준 후]
→ 3-Way가 왜 필요한지 독자가 직접 느끼게 함
```

### 수정 전략

정의가 먼저 등장하는 곳을 찾아 앞에 동기/문제를 추가합니다.

```
# Before
레코드 타입에는 A, AAAA, CNAME, MX, NS 등이 있습니다.

# After
DNS 서버가 질의를 받으면, 어떤 종류의 정보를 돌려줘야 할까요?
IP 주소일 수도, 메일 서버 주소일 수도, 다른 이름일 수도 있습니다.
이 구분을 위해 레코드 타입이 존재합니다. A, AAAA, CNAME, MX, NS 등이 있습니다.
```

### 점검 항목
- [ ] 개념이 "왜 필요한지" 설명 없이 정의부터 시작하는 곳이 있는가?
- [ ] "어떻게 동작하는지"가 "왜 그렇게 설계되었는지"보다 먼저 나오는 곳이 있는가?

---

## 2. 문제 → 순진한 해법 실패 → 진짜 해법

독자가 "이렇게 하면 되지 않나?"라고 생각할 수 있는 순진한 접근을 먼저 보여주고, 왜 실패하는지 보여준 후 진짜 해법을 제시합니다.

### 핵심 패턴

```
[문제] → [직관적이지만 불완전한 접근] → [실패 이유] → [진짜 해법]
```

### 레퍼런스 사례

```
# HTTPEvolution-1: HTTP/1.1 파이프라이닝
문제: 요청이 응답을 기다려야 함
순진한 해법: 여러 요청을 한꺼번에 보내면?
실패 이유: 응답은 순서대로 와야 함 → HOL Blocking
진짜 해법: HTTP/2의 바이너리 프레이밍 + 스트림 ID

# SocketTransport-2: 2-Way vs 3-Way Handshake
문제: TCP 연결 수립
순진한 해법: 2번 교환이면 충분하지 않나?
실패 이유: 오래된 SYN 패킷이 유령 연결을 만들 수 있음
진짜 해법: 3번째 ACK로 클라이언트가 확인
```

### 적용 기법

해법이 바로 제시되는 곳을 찾아, 독자가 먼저 "더 쉬운 방법은 없나?"를 생각하게 합니다.

```
# Before
DNS는 계층적 이름 구조를 사용합니다.

# After
모든 이름을 하나의 파일에 넣으면 안 될까요?
HOSTS.TXT가 바로 그 방식이었습니다. 하지만 이름이 수천 개를 넘어가면서
충돌이 일어났고, 파일 크기도 감당할 수 없게 되었습니다.
DNS는 이 문제를 계층적 이름 구조로 해결했습니다.
```

### 점검 항목
- [ ] 해법이 문제 제시 없이 바로 등장하는 곳이 있는가?
- [ ] 독자가 "왜 더 간단한 방법을 안 쓰지?"라고 의문을 가질 수 있는 곳에서 그 의문을 다루고 있는가?

---

## 3. 암묵적 전제

"A이므로 C이다" 형태의 인과 관계에서, A→C 사이의 중간 단계 B가 생략되어 독자가 인과 관계를 이해할 수 없는 경우입니다. 글쓴이에게는 자명하지만 독자에게는 자명하지 않은 전제가 숨어 있습니다.

### 핵심 패턴

```
[원인 A] → [숨겨진 전제 B] → [결과 C]
글에는 "A이므로 C이다"만 있고, B가 빠져 있음
```

### 비교 (DNS-1 실제 사례)

```
# Before
모든 호스트 이름이 하나의 평면적 목록에 있었으므로,
MIT와 Stanford가 동시에 MAILSERVER라는 이름을 사용할 수 없었습니다.
→ "평면적 목록"이 왜 "동시 사용 불가"로 이어지는지 설명 없음

숨겨진 전제: 하나의 목록에서 같은 이름이 두 개 있으면,
             어느 컴퓨터의 주소를 돌려줘야 할지 알 수 없다

# After
HOSTS.TXT에는 모든 호스트 이름이 하나의 목록에 들어 있었습니다.
같은 이름이 두 개 있으면 어느 컴퓨터의 주소를 돌려줘야 할지 알 수 없으므로,
이름은 전체에서 유일해야 했습니다.
MIT가 MAILSERVER를 먼저 등록하면, Stanford는 같은 이름을 쓸 수 없었습니다.
→ 숨겨진 전제(이름 유일성의 이유)가 명시됨
```

### 수정 전략

인과 관계 문장("A이므로 B이다", "A 때문에 B이다")을 발견하면 다음을 확인합니다.

1. 원인(A)에서 결과(C)까지 독자가 스스로 추론할 수 있는가?
2. 글쓴이에게는 자명하지만 독자에게는 아닐 수 있는 전제가 있는가?
3. 숨겨진 전제가 있으면, 원인과 결과 사이에 명시적으로 풀어 쓴다

### 점검 항목
- [ ] "A이므로 C이다" 형태에서, A→C 사이에 독자가 채워야 할 논리적 빈칸이 있는가?
- [ ] 글쓴이에게 자명한 전제가 독자에게도 자명한가?
- [ ] 인과 관계가 두 단계 이상 압축되어 있는가?

---

## 4. 상위 맥락과의 단절

문단이 소속 섹션의 논점을 뒷받침하지 않는 경우입니다. 문단 자체는 정확하지만, 그것이 왜 이 섹션에 있는지 독자가 연결할 수 없습니다.

### 핵심 패턴

```
섹션 제목: [주제 X]
  문단: [Y에 대한 설명]
  → Y가 왜 X와 관련되는지 명시되지 않음
```

### 비교 (DNS-1 실제 사례)

```
# Before
섹션: "확장성의 한계"
  "이름 충돌: MIT가 MAILSERVER를 먼저 등록하면,
   Stanford는 같은 이름을 쓸 수 없었습니다."
  → 이름 충돌이 무엇인지는 설명했지만,
     이것이 왜 "확장성" 문제인지 연결 없음.
     호스트가 100대일 때도 1만 대일 때도 같은 제약인데,
     왜 "확장성"의 한계인가?

# After
섹션: "확장성의 한계"
  "이름 충돌: NIC는 중복 이름의 등록을 거부할 수 있었지만,
   이름 분쟁을 조정할 권한은 없었습니다.
   네트워크에 참여하는 조직이 늘어날수록 원하는 이름이
   이미 등록되어 있을 가능성이 높아졌고,
   이름을 자유롭게 선택하기 어려워졌습니다."
  → "조직이 늘어날수록"가 확장성과의 명시적 연결
```

### 수정 전략

각 문단이 소속 섹션의 제목/논점에 연결되는지 확인합니다.

1. 섹션 제목이 제시하는 논점(X)을 파악
2. 각 문단의 설명(Y)이 X를 뒷받침하는지 확인
3. 연결이 없으면, Y가 왜 X와 관련되는지 한 문장을 추가

### 점검 항목
- [ ] 문단의 설명이 소속 섹션의 제목/논점을 뒷받침하는가?
- [ ] "이 문단이 왜 이 섹션에 있는가?"에 대한 답이 텍스트에 명시되어 있는가?
- [ ] 하위 항목을 나열할 때, 각 항목이 상위 주제와의 관계를 명시하고 있는가?

---

## 5. 미설명 용어

새 용어가 등장하면 독자가 모른다고 가정하고 바로 설명합니다.

### 핵심 원칙

**용어가 처음 등장하는 시점에 독자가 이해할 수 있어야 합니다.**

### 좋은 예시

```
# SocketTransport-1: 5-tuple 도입
5-tuple = (프로토콜, 로컬 IP, 로컬 포트, 원격 IP, 원격 포트)
[각 요소가 왜 필요한지 표로 설명]
[하나라도 빠지면 어떤 문제가 생기는지 예시]
```

### 나쁜 예시

```
# DNS-1 현재
"실제로는 Anycast를 통해 수백 개의 서버가 분산 배치되어 있습니다."
→ Anycast가 무엇인지 설명 없음

"Zone apex에서는 CNAME을 사용할 수 없습니다."
→ Zone apex가 무엇인지 설명 없음
```

### 수정 전략

설명 없는 용어를 발견하면 세 가지 중 하나를 선택합니다.

1. **즉시 설명 추가**: 핵심 개념이면 괄호나 후속 문장으로 설명
2. **비유/예시로 설명**: 추상적 개념이면 익숙한 것에 비유
3. **삭제 또는 대체**: 글의 흐름에 필수적이지 않으면 일반적인 표현으로 대체

```
# Before
실제로는 Anycast를 통해 수백 개의 서버가 분산 배치되어 있습니다.

# After (즉시 설명)
실제로는 같은 IP 주소를 여러 서버가 공유하는 Anycast 기술을 통해,
수백 개의 서버가 전 세계에 분산 배치되어 있습니다.
사용자의 질의는 네트워크 상 가장 가까운 서버로 자동 전달됩니다.
```

### 점검 항목
- [ ] 독자가 처음 보는 용어가 설명 없이 사용되는 곳이 있는가?
- [ ] 약어가 풀어 쓰이지 않고 바로 사용되는 곳이 있는가?
- [ ] 글의 맥락상 필수적이지 않은데 설명 없이 등장하는 전문 용어가 있는가?

---

## 6. 추상적 서술 → 구체적 수치/예시

"빠르다", "크다", "많이 줄어든다" 같은 추상적 표현 대신 구체적 수치를 사용합니다.

### 비교

```
# 나쁜 예
HTTP/2에서는 헤더가 크게 줄어듭니다.

# 좋은 예 (HTTPEvolution-1)
41개 파일의 경우, HTTP/1.1에서 41KB였던 헤더가
HTTP/2에서는 4~6KB로 줄어듭니다.
```

```
# 나쁜 예
캐싱 덕분에 루트 서버의 부하가 줄어듭니다.

# 좋은 예
".com"의 NS 레코드 TTL이 48시간이므로,
리졸버 하나가 이틀에 한 번만 TLD 서버에 질의하면 됩니다.
수백만 건의 ".com" 질의 중 실제로 TLD에 도달하는 건 극히 일부입니다.
```

### 수정 전략

추상적 서술을 발견하면 다음 중 하나를 적용합니다.

1. **구체적 수치**: 가능하면 실제 수치를 찾아 제시
2. **규모감 비교**: "X는 Y의 N배" 형태로 직관 형성
3. **시나리오 예시**: 수치가 없으면 구체적 상황으로 제시

### 점검 항목
- [ ] "크게", "많이", "빠르게", "효율적으로" 같은 추상적 부사가 수치 없이 사용되는 곳이 있는가?
- [ ] 비교를 하면서 구체적 기준이 없는 곳이 있는가? (예: "기존보다 빠르다" → 얼마나?)
- [ ] 규모감을 제공해야 하는데 빠져 있는 곳이 있는가?

---

## 7. 누락된 예시

정의만 있고 실례가 없으면 독자는 추상적으로만 이해하게 됩니다.

### 핵심 원칙

**모든 정의/개념에는 최소 하나의 구체적 예시가 따라와야 합니다.**

### 좋은 예시

```
# SocketTransport-1: 5-tuple 정의 후

웹 서버(80번 포트)에 두 클라이언트가 접속한 경우:
연결 1: (TCP, 10.0.0.5, 12345, 93.184.216.34, 80)
연결 2: (TCP, 10.0.0.7, 54321, 93.184.216.34, 80)
→ 로컬 IP와 로컬 포트가 다르므로 구분 가능
```

### 나쁜 예시

```
# NS 레코드 정의만
NS 레코드는 해당 도메인의 네임서버를 가리킵니다.
→ 실제 질의에서 NS 레코드가 어떻게 사용되는지 예시 없음
```

### 수정 전략

정의만 있는 곳을 찾아 다음 중 하나를 추가합니다.

1. **구체적 시나리오**: 실제 사용 상황에서 어떻게 동작하는지
2. **데이터 예시**: 실제 값/형태를 보여줌
3. **대비 예시**: 있을 때와 없을 때의 차이

```
# Before
NS 레코드는 해당 도메인의 네임서버를 가리킵니다.

# After
NS 레코드는 해당 도메인의 네임서버를 가리킵니다.

예를 들어, example.com의 NS 레코드를 조회하면:
example.com.  IN  NS  ns1.example.com.
example.com.  IN  NS  ns2.example.com.

리졸버는 이 응답을 보고 "example.com에 대한 정보는
ns1.example.com에 물어봐야 하는구나"라고 판단합니다.
```

### 점검 항목
- [ ] 정의/개념 설명 후에 구체적 예시가 바로 따라오는가?
- [ ] 예시가 독자가 이미 아는 것(실제 도메인, 실제 IP 등)을 활용하는가?
- [ ] 과정을 설명하면서 실제 데이터로 단계를 보여주고 있는가?

---

## 8. 밀도 과다

한 문단에 새 개념이 3개 이상 등장하면 독자가 따라가기 어렵습니다.

### 핵심 원칙

**한 문단에 새 개념은 최대 2개.** 3개 이상이면 분리합니다.

### 나쁜 예시

```
# DNS-1 현재: 한 문단에 4개 조직이 등장
ICANN이 전체 도메인 이름 체계를 관리하고, 산하 기관인 IANA가
루트 존과 TLD의 기술적 운영을 담당합니다.
각 TLD는 레지스트리가 관리합니다. 예를 들어 .com의 레지스트리는 Verisign입니다.
→ ICANN, IANA, 레지스트리, Verisign이 한꺼번에 등장
```

### 수정 전략

밀도가 높은 곳을 찾아 다음 방법으로 분리합니다.

1. **계층적 전개**: 큰 개념부터 작은 개념으로 한 단계씩
2. **문단 분리**: 각 개념에 별도 문단 또는 별도 줄
3. **테이블 활용**: 여러 항목의 역할을 한눈에 보여줌

```
# After
전체 도메인 이름 체계를 관리하는 곳은 **ICANN(Internet Corporation for
Assigned Names and Numbers)**입니다.

ICANN 산하의 **IANA(Internet Assigned Numbers Authority)**가
루트 존과 TLD의 기술적 운영을 담당합니다.

각 TLD에는 전담 관리 조직인 **레지스트리(Registry)**가 있습니다.

| TLD | 레지스트리 |
|-----|----------|
| .com, .net | Verisign |
| .org | Public Interest Registry |
| .kr | KISA(한국인터넷진흥원) |
```

### 점검 항목
- [ ] 한 문단에 독자가 처음 접하는 개념이 3개 이상 등장하는 곳이 있는가?
- [ ] 여러 항목을 나열하면서 각각의 역할/차이를 충분히 설명하고 있는가?
- [ ] 테이블이나 목록으로 분리하면 더 명확해지는 곳이 있는가?

---

## 9. 누락된 시각화

과정, 구조, 비교를 문장으로만 설명하면 독자가 머릿속에서 그림을 그려야 합니다.

### 시각화가 필요한 상황

| 상황 | 시각화 형태 |
|------|-----------|
| 순차적 과정 | 단계별 다이어그램 |
| 계층/구조 | 트리 다이어그램 |
| 두 개념 비교 | 대비 테이블 |
| 요청/응답 흐름 | 화살표 다이어그램 |
| 패킷/프레임 구조 | 박스 다이어그램 |
| 네트워크 토폴로지 | 노드-링크 다이어그램 |
| 프로토콜 캡슐화 | 중첩 박스 다이어그램 |
| 정상/장애 비교 | 상태 비교 다이어그램 |

### ASCII 다이어그램 패턴

**패킷/프레임 구조:**
```
┌─────────┬────────┬────────┬──────┬─────────────────┬─────┐
│프리앰블  │ 목적지  │ 출발지  │ 타입 │      데이터     │ FCS │
└─────────┴────────┴────────┴──────┴─────────────────┴─────┘
```

**네트워크 토폴로지:**
```
라우터 A ─── 라우터 B ─── 라우터 C
   │
10.0.0.0/8
```

**프로토콜 스택/캡슐화:**
```
응용:     [         HTTP 요청         ]
전송:     [TCP 헤더][   HTTP 요청     ]
네트워크: [IP 헤더][TCP 헤더][HTTP 요청]
```

**상태 비교 다이어그램:**
```
정상 상태:
A ─── B ─── C ─── D
      │
      E

장애 발생:
A ─── B ─X─ C ─── D
      │
      E
```

### 레퍼런스 사례

```
# Routing-2: Dijkstra 알고리즘 단계별 시각화
[초기 상태] 확정: {A}
[1단계] 비용이 가장 낮은 C(비용 3)를 확정
[2단계] C를 거쳐 갈 수 있는 노드의 비용 업데이트
→ 독자가 각 단계를 따라가며 알고리즘을 직접 이해

# SocketTransport-1: TCP vs UDP 대비 테이블
| | TCP | UDP |
|--|-----|-----|
| 연결 | 필요 | 불필요 |
| 신뢰성 | 보장 | 없음 |
| 오버헤드 | 큼 | 작음 |
```

### 수정 전략

문장으로만 설명된 과정/구조를 찾아 시각화합니다.

```
# Before (문장으로만 설명)
클라이언트가 리졸버에게 질의하면, 리졸버는 루트 서버에 물어보고,
루트 서버는 TLD 서버를 안내하고, TLD 서버는 권한 서버를 안내합니다.

# After (다이어그램 추가)
클라이언트 → 리졸버: "www.example.com의 IP는?"
리졸버 → 루트 서버: ".com은 누가 관리하나요?"
루트 서버 → 리졸버: "TLD 서버(a.gtld-servers.net)에 물어보세요"
리졸버 → TLD 서버: "example.com은 누가 관리하나요?"
TLD 서버 → 리졸버: "ns1.example.com에 물어보세요"
리졸버 → 권한 서버: "www.example.com의 IP는?"
권한 서버 → 리졸버: "93.184.216.34입니다"
```

### 점검 항목
- [ ] 순차적 과정이 문장으로만 설명되어 있는 곳이 있는가?
- [ ] 두 개념의 차이를 문장으로 나열하고 있는 곳이 있는가? → 테이블로 전환
- [ ] 계층 구조를 텍스트로만 설명하고 있는 곳이 있는가? → 트리로 시각화
- [ ] 구조(패킷, 프레임, 프로토콜 스택)를 설명하면서 박스 다이어그램이 없는가?
- [ ] 정상/장애 상태를 비교하면서 시각적 대비가 없는가?

---

## 10. 예외/한계 명시

"항상", "모든" 같은 절대적 표현을 피하고 조건과 예외를 명시합니다.

### 핵심 원칙

**절대적 표현은 독자에게 잘못된 확신을 줍니다.** 조건과 한계를 함께 제시합니다.

### 비교

```
# 나쁜 예
캐싱 덕분에 DNS 질의는 항상 빠르게 처리됩니다.

# 좋은 예
캐싱 덕분에 대부분의 DNS 질의는 빠르게 처리됩니다.
다만 TTL이 만료된 직후나, 처음 방문하는 도메인의 경우에는
루트부터 재귀적으로 질의해야 하므로 지연이 발생할 수 있습니다.
```

### 레퍼런스 사례

```
# 좋은 예
MIMO가 효과적이지만, 장애물이 없는 경우 효과가 줄어듭니다.
HPACK이 효과적이지만, 스트림이 독립적인 QUIC에서는 QPACK이 필요합니다.
→ "효과적이다"에서 끝나지 않고 한계 조건을 명시
```

### 점검 항목
- [ ] "항상", "모든", "반드시" 같은 절대적 표현이 조건 없이 사용되는 곳이 있는가?
- [ ] 장점만 나열하고 한계/트레이드오프를 언급하지 않는 곳이 있는가?
- [ ] "~하면 된다"라고 단정하면서 예외 상황을 빠뜨린 곳이 있는가?

---

## 익숙한 개념 → 새 개념 연결

위 10개 점검 항목 외에, 수정 시 항상 고려해야 할 원칙입니다.

독자가 이미 아는 것에서 출발하여 새 개념을 설명합니다.

```
# SocketTransport-1
Unix에서 파일을 열면 번호를 받고, 이 번호로 읽기/쓰기/닫기를 합니다.
소켓도 마찬가지입니다.
→ 파일 디스크립터(익숙) → 소켓 디스크립터(새 개념)

# NetworkCommunication-1
음성 신호를 직접 전송하려면... 3000Hz의 파장은 약 10만 미터이므로,
효율적인 안테나 길이는 25km가 됩니다. 이런 안테나는 만들 수 없습니다.
→ 왜 변조가 필요한지 독자가 직접 이해
```

새 개념을 도입할 때 독자가 알 만한 것을 먼저 언급했는지 확인합니다.

---

## 작업 프로세스

### 1단계: 파일 읽기
- `$ARGUMENTS`가 있으면 해당 파일 읽기
- 없으면 사용자에게 파일 경로 또는 텍스트 요청

### 2단계: 이해도 분석
- 10개 점검 항목에 따라 글 전체를 분석
- 각 항목별로 문제가 있는 위치를 기록

### 3단계: 문제 식별 및 우선순위
- 발견된 문제를 다음 기준으로 우선순위 결정:
  1. **미설명 용어**: 독자가 이해할 수 없는 용어가 가장 시급
  2. **암묵적 전제**: 인과 관계의 숨겨진 중간 단계
  3. **상위 맥락과의 단절**: 문단이 소속 섹션의 논점에 연결되지 않음
  4. **논리 간극**: "왜?"가 빠진 정의
  5. **설명 순서**: 동기 없이 시작하는 섹션
  6. **나머지 항목**: 추상적 서술, 누락된 예시, 밀도 과다, 시각화, 예외

### 4단계: 수정
- 각 문제에 대해 점검 항목의 수정 전략을 적용
- 원래 의미가 훼손되지 않도록 주의
- 글의 전체 흐름이 자연스럽게 유지되는지 확인

### 5단계: 출력
- 수정된 글 전체
- 주요 변경 사항 요약 (점검 항목별로 분류)

---

## 병렬 작업 (긴 글의 경우)

긴 글은 섹션별로 나누어 서브에이전트에게 병렬로 수정을 요청할 수 있습니다.

### 서브에이전트 프롬프트
```
다음 글의 이해도를 높여주세요.

## 점검 항목
1. 설명 순서: "왜?" → "무엇?" → "어떻게?" 순서인가?
2. 논리 간극: 정의만 있고 동기/이유가 없는 곳은?
3. 암묵적 전제: "A이므로 C이다"에서 숨겨진 중간 단계 B가 있는가?
4. 상위 맥락과의 단절: 문단이 소속 섹션의 논점을 뒷받침하지 않는 곳은?
5. 미설명 용어: 독자가 모를 수 있는 용어가 설명 없이 사용되는 곳은?
6. 추상적 서술: 구체적 수치/예시로 대체할 수 있는 곳은?
7. 누락된 예시: 정의만 있고 실례가 없는 곳은?
8. 밀도 과다: 한 문단에 새 개념이 3개 이상 등장하는 곳은?
9. 누락된 시각화: 다이어그램이나 테이블이 필요한 곳은?
10. 예외 미명시: 절대적 표현이 조건/예외 없이 사용된 곳은?

## 원칙
- 독자가 외부 지식 없이 글만으로 이해할 수 있어야 함
- 새 개념은 익숙한 개념에서 출발하여 연결
- 원래 의미를 훼손하지 않을 것

## 수정할 글
[섹션 내용]

## 출력
수정된 글 + 변경 사항 요약 (점검 항목별)
```

---

## 체크리스트

### 문장 수준
- [ ] 설명 없이 사용된 용어가 없는가?
- [ ] 추상적 부사("크게", "많이") 대신 구체적 수치가 있는가?
- [ ] "항상", "모든" 같은 절대적 표현에 조건이 붙어 있는가?
- [ ] "A이므로 C이다" 형태에서 독자가 채워야 할 숨겨진 전제가 없는가?

### 문단 수준
- [ ] 한 문단에 새 개념이 3개 이상 등장하지 않는가?
- [ ] 정의 뒤에 구체적 예시가 따라오는가?
- [ ] 개념의 동기("왜?")가 정의 전에 제시되는가?
- [ ] 문단이 소속 섹션의 논점을 뒷받침하는가?

### 섹션 수준
- [ ] "왜?" → "무엇?" → "어떻게?" 순서를 따르는가?
- [ ] 순진한 해법의 실패를 먼저 보여주고 진짜 해법을 제시하는가?
- [ ] 과정/구조가 문장으로만 설명되지 않고 시각화되어 있는가?

### 글 전체 수준
- [ ] 독자가 외부 자료 없이 이 글만으로 개념을 이해할 수 있는가?
- [ ] 새 개념이 익숙한 개념에서 출발하여 설명되는가?
- [ ] 장점에 한계/트레이드오프가 함께 제시되는가?
