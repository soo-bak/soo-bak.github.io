# 흐름 다듬기 스킬 — 흐름 (Flow)

주어진 글의 **읽기 흐름**을 다듬습니다. 문장과 문단 사이를 막힘 없이 읽을 수 있는지,
즉시 이해가 가능한지, 문맥이 자연스럽게 이어지는지 점검합니다.

## 파이프라인 위치

```
/edit-writing → /clarify-writing → /refine-style → ▶ /smooth-flow → /verify-facts → /deep-review → /align-reference
  골격             이해               목소리           흐름            사실             독자 시뮬레이션    레퍼런스 정렬
```

이 스킬은 파이프라인의 **네 번째 단계**입니다:
- 글의 뼈대 → `/edit-writing`
- 독자의 이해 → `/clarify-writing`
- 톤, 리듬, 서사 → `/refine-style`
- 사실관계 → `/verify-facts`
- 독자 경험 통합 점검 → `/deep-review`
- 레퍼런스 정렬 → `/align-reference`

## 인자
- `$ARGUMENTS`: 수정할 파일 경로 (선택사항). 없으면 사용자에게 파일 또는 텍스트를 요청합니다.

---

## 점검 항목

---

## 1. 문장 자연스러움

한국어로 자연스럽게 읽히는가?

### 점검 대상

- 수식어 체인이 과도하게 긴 곳
- 절 중첩이 3단계 이상인 곳
- 어색한 조사 사용
- 능동/수동이 부자연스러운 곳

### /edit-writing과의 차이

`/edit-writing`은 주어-서술어 **구조적 호응**을 다룹니다. 이 스킬은 구조적으로 올바르더라도 **읽었을 때 자연스러운지**를 다룹니다.

### /refine-style과의 차이

`/refine-style`은 종결어미 다양성과 문장 **리듬**을 다룹니다. 이 스킬은 문장 **내부 구성**의 자연스러움을 다룹니다.

### 비교

```
# 구조적으로 올바르지만 부자연스러운 예
서버가 클라이언트로부터 전달받은 요청을 처리한 결과를 포함하는 응답을
클라이언트에게 반환합니다.
→ 수식어 체인이 과도하게 길어 한 번에 읽히지 않음

# 자연스러운 예
서버는 클라이언트의 요청을 처리하고, 그 결과를 응답에 담아 반환합니다.
→ 같은 내용이지만 수식어 체인을 끊어 자연스럽게 읽힘
```

### 수정 전략

1. **수식어 체인 분리**: 긴 수식어를 별도 문장이나 절로 분리
2. **절 중첩 해소**: 중첩된 절을 독립 문장으로 풀기
3. **조사 교정**: 문맥에 맞는 조사로 교체
4. **능동/수동 전환**: 문맥에서 더 자연스러운 태로 전환

### 점검 항목
- [ ] 수식어 체인이 3단어 이상 연속되는 곳이 있는가?
- [ ] 절 중첩이 3단계 이상인 곳이 있는가?
- [ ] 소리 내어 읽었을 때 어색하게 느껴지는 조사가 있는가?
- [ ] 능동/수동 전환이 더 자연스러운 곳이 있는가?

---

## 2. 즉시 이해 가능성

한 번 읽으면 바로 이해되는가?

### 점검 대상

- 다시 읽어야 이해되는 문장
- 핵심 정보가 긴 절 뒤에 묻힌 문장
- 작업 기억에 과부하를 주는 문장 (주어와 서술어 사이에 긴 삽입절)

### /clarify-writing과의 차이

`/clarify-writing`은 **설명이 완전한가**(전략)를 다룹니다. 이 스킬은 **완전한 설명이 즉시 이해되게 배치되었는가**(배치)를 다룹니다.

### 비교

```
# 설명은 완전하지만 즉시 이해가 어려운 예
리졸버가, 캐시에 해당 레코드가 없고 TTL이 만료되었거나
처음 질의하는 도메인인 경우에, 루트 서버부터 재귀적으로 질의합니다.
→ 핵심 동작("루트 서버부터 재귀적으로 질의")이 긴 조건절 뒤에 묻힘

# 즉시 이해되는 배치
리졸버는 루트 서버부터 재귀적으로 질의합니다.
캐시에 해당 레코드가 없거나, TTL이 만료된 경우입니다.
→ 핵심 동작을 먼저 제시하고 조건을 뒤에 배치
```

### 수정 전략

1. **핵심 정보 앞으로**: 핵심 동작/결론을 문장 앞에 배치하고, 조건/배경은 뒤에
2. **삽입절 분리**: 주어와 서술어 사이의 긴 삽입절을 별도 문장으로 분리
3. **단일 정보 원칙**: 한 문장에 새 정보를 하나만 담기

### 점검 항목
- [ ] 두 번 읽어야 이해되는 문장이 있는가?
- [ ] 핵심 정보가 긴 조건절/삽입절 뒤에 묻혀 있는가?
- [ ] 주어와 서술어 사이에 긴 삽입절이 있는가?

---

## 3. 인접 문맥 연결

바로 앞 문장/문단에서 자연스럽게 이어지는가?

### 점검 대상

- 섹션 내부에서 문장 간 논리적 도약
- 문단 간 연결 없이 갑자기 전환되는 곳
- 한 문단의 마지막 문장과 다음 문단의 첫 문장 사이의 단절

### /refine-style과의 차이

`/refine-style`은 **섹션 간** 전환(내러티브 브릿지)을 다룹니다. 이 스킬은 **섹션 내부**의 문장-문단 간 연결을 다룹니다.

### /deep-review와의 차이

`/deep-review`는 **거시적 읽기 관성**(독자가 읽기를 멈추는 지점)을 다룹니다. 이 스킬은 **미시적 문맥 연결**(바로 앞 문장에서 자연스럽게 이어지는가)을 다룹니다.

### 비교

```
# 인접 문맥이 끊긴 예
DNS 서버는 계층적으로 구성되어 있습니다.
캐싱을 통해 질의 횟수를 줄일 수 있습니다.
→ "계층 구성"에서 "캐싱"으로의 논리적 연결이 없음

# 인접 문맥이 연결된 예
DNS 서버는 계층적으로 구성되어 있습니다.
이 계층 구조 덕분에 한 번 조회한 결과를 캐싱하면,
매번 루트부터 다시 질의할 필요가 없습니다.
→ "계층 구조" → "캐싱 가능" 연결이 명시됨
```

### 수정 전략

1. **연결 고리 추가**: 앞 문장의 키워드를 다음 문장에서 받아서 시작
2. **논리적 도약 채우기**: 두 문장 사이에 빠진 중간 연결을 추가
3. **문단 순서 조정**: 논리적으로 더 자연스러운 순서로 문단 재배치

### 점검 항목
- [ ] 섹션 내에서 문장 간 논리적 도약이 있는가?
- [ ] 문단의 마지막 문장과 다음 문단의 첫 문장 사이에 단절이 있는가?
- [ ] 앞 문장의 키워드가 다음 문장에서 자연스럽게 이어지는가?

---

## 4. 설명 시점 일관성

설명의 관점/프레임이 일관적인가?

### 점검 대상

- 한 섹션 내에서 갑자기 관점이 바뀌는 곳 (클라이언트 → 서버)
- 추상 수준이 갑자기 바뀌는 곳 (원리 → 구현 세부)
- 같은 개념의 프레이밍이 달라지는 곳

### /deep-review와의 차이

`/deep-review`는 **개념 순서**(이해 곡선)를 다룹니다. 이 스킬은 **관점/시점의 안정성**을 다룹니다.

### 비교

```
# 관점이 갑자기 바뀌는 예
클라이언트는 DNS 서버에 질의를 보냅니다.
요청을 수신한 서버는 캐시를 확인합니다.
캐시에 없으면 클라이언트는 다시 기다려야 합니다.
→ 클라이언트 → 서버 → 클라이언트로 관점이 흔들림

# 관점이 일관된 예
클라이언트는 DNS 서버에 질의를 보냅니다.
서버가 캐시를 확인하는 동안 클라이언트는 응답을 기다립니다.
캐시에 결과가 없으면 서버는 상위 서버에 다시 질의하고,
클라이언트의 대기 시간이 길어집니다.
→ 일관된 시점에서 서술
```

```
# 추상 수준이 갑자기 바뀌는 예
DNS는 분산 데이터베이스입니다.
BIND 설정 파일의 zone 블록에서 type을 master로 지정합니다.
→ 개념적 원리에서 갑자기 구현 세부로 전환

# 추상 수준이 일관된 예
DNS는 분산 데이터베이스입니다.
각 서버가 자기 영역의 데이터만 관리하고,
다른 영역에 대한 질의는 해당 영역의 서버에게 위임합니다.
→ 같은 추상 수준에서 개념을 전개
```

### 수정 전략

1. **관점 통일**: 한 문단/섹션 내에서 일관된 관점(주체) 유지
2. **추상 수준 유지**: 같은 섹션 내에서 원리와 구현 세부를 분리
3. **프레이밍 통일**: 같은 개념을 같은 방식으로 설명

### 점검 항목
- [ ] 한 섹션 내에서 설명의 주체(관점)가 일관적인가?
- [ ] 추상 수준이 갑자기 바뀌는 곳이 있는가?
- [ ] 같은 개념이 문단에 따라 다르게 프레이밍되고 있는가?

---

## 5. 예시 절제

모든 예시가 제 역할을 하는가?

### 점검 대상

- 이미 명확한 개념에 불필요한 예시
- 흐름을 끊는 예시 (설명 중간에 긴 예시가 끼어드는 경우)
- 중복된 예시 (같은 포인트를 반복하는 예시)
- 연속 예시 과다 (3개 이상 예시가 연달아 나오는 경우)

### /clarify-writing과의 차이

`/clarify-writing`은 **누락된 예시 추가**를 다룹니다. 이 스킬은 **불필요한 예시 정리**를 다룹니다. 둘은 상보적 관계입니다.

### 비교

```
# 불필요한 예시
IP 주소는 네 개의 숫자로 구성됩니다.
예를 들어, 192.168.1.1이 IP 주소입니다.
또 다른 예로, 10.0.0.1도 IP 주소입니다.
172.16.0.1 역시 IP 주소의 한 형태입니다.
→ "네 개의 숫자로 구성됩니다"는 이미 명확. 예시 하나면 충분

# 절제된 예시
IP 주소는 네 개의 숫자로 구성됩니다(예: 192.168.1.1).
→ 하나의 예시로 충분히 전달
```

### 수정 전략

1. **중복 예시 제거**: 같은 포인트를 보여주는 예시는 가장 효과적인 하나만 유지
2. **흐름 위치 조정**: 설명 중간의 긴 예시는 설명 직후로 이동
3. **인라인 예시 전환**: 짧은 예시는 괄호 안에 인라인으로 배치
4. **연속 예시 정리**: 3개 이상 연속 예시는 테이블로 정리하거나 1~2개로 축소

### 점검 항목
- [ ] 이미 명확한 개념에 불필요한 예시가 있는가?
- [ ] 설명 흐름 중간에 긴 예시가 끼어들어 흐름을 끊는가?
- [ ] 같은 포인트를 반복하는 중복 예시가 있는가?
- [ ] 3개 이상의 예시가 연달아 나오는 곳이 있는가?

---

## 6. 지시어/참조 명확성

"이", "그", "위의" 등의 참조가 즉시 명확한가?

### 점검 대상

- 지시 대상이 모호한 곳
- 2~3문장 이상 떨어진 대상을 가리키는 곳
- 지시어 체인이 계속되는 곳 ("이것은... 그것을... 이를...")

### /edit-writing과의 차이

`/edit-writing`은 **대명사보다 명확한 지시어를 선호**하는 규칙을 다룹니다. 이 스킬은 **흐름 속에서 참조가 마찰을 일으키는지** 경험적으로 판단합니다.

### 비교

```
# 참조가 모호한 예
DNS 서버는 계층 구조로 되어 있습니다.
이 구조는 확장성을 높입니다.
이를 통해 전 세계적으로 서비스할 수 있습니다.
이는 인터넷의 핵심 설계 원칙이기도 합니다.
→ "이", "이를", "이는"이 연쇄적으로 이어지며
  각각이 무엇을 가리키는지 모호

# 참조가 명확한 예
DNS 서버는 계층 구조로 되어 있습니다.
계층 구조 덕분에 각 서버가 담당 영역만 관리하면 되므로 확장성이 높아집니다.
이 분산 관리 방식은 전 세계적 서비스를 가능하게 했고,
인터넷의 핵심 설계 원칙이기도 합니다.
→ 지시 대상이 명확하거나 구체적 명사로 대체
```

### 수정 전략

1. **명사 대체**: 모호한 지시어를 구체적 명사로 교체
2. **가까이 배치**: 참조 대상과 지시어 사이의 거리 줄이기
3. **지시어 체인 끊기**: 연속 지시어를 구체적 명사로 교체

### 점검 항목
- [ ] 지시 대상이 모호한 "이", "그", "위의" 등이 있는가?
- [ ] 참조 대상과 지시어 사이에 2~3문장 이상의 거리가 있는가?
- [ ] 지시어가 연쇄적으로 이어지는 곳이 있는가?

---

## 다른 커맨드와의 경계

이 스킬의 6개 항목은 다른 커맨드의 항목과 겹치지 않습니다:

- `/edit-writing`은 **구조적 호응과 규칙**을 다룹니다 → 이 스킬은 **읽기 경험의 자연스러움**을 봅니다
- `/clarify-writing`은 **설명의 완전성**(전략)을 다룹니다 → 이 스킬은 **설명의 배치**(경험)를 봅니다
- `/refine-style`은 **톤, 리듬, 섹션 간 전환**을 다룹니다 → 이 스킬은 **섹션 내부의 문장-문단 간 흐름**을 봅니다
- `/verify-facts`는 **사실의 정확성**을 다룹니다 → 이 스킬은 **흐름의 자연스러움**을 봅니다
- `/deep-review`는 **거시적 독자 경험**을 다룹니다 → 이 스킬은 **미시적 흐름**을 봅니다
- `/align-reference`는 **레퍼런스 대비 구조/품질 정합성**을 다룹니다 → 이 스킬은 **섹션 내부의 읽기 흐름**을 봅니다

---

## 작업 프로세스

### 1단계: 파일 읽기
- `$ARGUMENTS`가 있으면 해당 파일 읽기
- 없으면 사용자에게 파일 경로 또는 텍스트 요청

### 2단계: 흐름 분석
- 문장 단위: 각 문장의 자연스러움, 즉시 이해 가능성 점검
- 문단 단위: 문장 간 연결, 시점 일관성, 예시 배치 점검
- 섹션 단위: 문단 간 연결, 관점 일관성 점검

### 3단계: 문제 식별 및 우선순위
- 발견된 문제를 다음 기준으로 우선순위 결정:
  1. **문장 자연스러움**: 읽히지 않는 문장이 가장 시급
  2. **즉시 이해 가능성**: 두 번 읽어야 하는 문장
  3. **인접 문맥 연결**: 논리적 도약이 있는 곳
  4. **설명 시점 일관성**: 관점이 흔들리는 곳
  5. **예시 절제**: 흐름을 끊는 예시
  6. **지시어/참조 명확성**: 모호한 참조

### 4단계: 수정
- 각 문제에 대해 점검 항목의 수정 전략을 적용
- 원래 의미가 훼손되지 않도록 주의
- 글의 전체 흐름이 자연스럽게 유지되는지 확인

### 5단계: 검토
- 수정 후 전체를 다시 읽어 새로운 흐름 문제가 생기지 않았는지 확인
- 원래 의미가 훼손되지 않았는지 확인

### 6단계: 출력
- 수정된 글 전체
- 주요 변경 사항 요약 (점검 항목별로 분류)

---

## 병렬 작업 (긴 글의 경우)

긴 글은 섹션별로 나누어 서브에이전트에게 병렬로 수정을 요청할 수 있습니다.

### 서브에이전트 프롬프트
```
다음 글의 읽기 흐름을 다듬어주세요.

## 점검 항목
1. 문장 자연스러움: 수식어 체인이 과도하거나, 절 중첩이 깊거나, 조사가 어색한 곳은?
2. 즉시 이해 가능성: 두 번 읽어야 이해되는 문장, 핵심 정보가 묻힌 문장은?
3. 인접 문맥 연결: 문장/문단 간 논리적 도약, 갑작스러운 전환이 있는 곳은?
4. 설명 시점 일관성: 관점/추상 수준이 갑자기 바뀌는 곳은?
5. 예시 절제: 불필요한 예시, 중복 예시, 흐름을 끊는 예시는?
6. 지시어/참조 명확성: "이", "그" 등의 지시 대상이 모호한 곳은?

## 원칙
- 문장과 문단 사이를 막힘 없이 읽을 수 있어야 함
- 한 번 읽으면 즉시 이해되어야 함
- 원래 의미를 훼손하지 않을 것

## 수정할 글
[섹션 내용]

## 출력
수정된 글 + 변경 사항 요약 (점검 항목별)
```

---

## 체크리스트

### 문장 수준
- [ ] 수식어 체인이 과도하게 긴 문장이 없는가?
- [ ] 절 중첩이 3단계 이상인 문장이 없는가?
- [ ] 두 번 읽어야 이해되는 문장이 없는가?
- [ ] 핵심 정보가 긴 조건절 뒤에 묻혀 있지 않은가?
- [ ] 지시 대상이 모호한 지시어가 없는가?

### 문단 수준
- [ ] 문장 간 논리적 도약 없이 자연스럽게 이어지는가?
- [ ] 앞 문단의 마지막 문장과 다음 문단의 첫 문장이 연결되는가?
- [ ] 설명의 관점/주체가 일관적인가?
- [ ] 불필요하거나 중복된 예시가 없는가?

### 섹션 수준
- [ ] 추상 수준이 일관적으로 유지되는가?
- [ ] 같은 개념의 프레이밍이 일관적인가?
- [ ] 연속 예시가 3개 이상 나열되지 않는가?
- [ ] 지시어 체인이 계속되지 않는가?
