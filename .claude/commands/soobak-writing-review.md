# 글쓰기 전체 리뷰 파이프라인

8단계 파이프라인을 순서대로 실행하여 글을 완전하게 수정합니다.

```
/equalize-baseline → /edit-writing → /clarify-writing → /refine-style → /smooth-flow → /verify-facts → /deep-review → /align-reference
   기준선 보강          골격            이해               목소리          흐름           사실            독자 시뮬레이션    레퍼런스 정렬
```

## 인자
- `$ARGUMENTS`: 수정할 파일 경로 (필수)

---

## 사전 분석

파이프라인 실행 **전**에 아래 두 작업을 수행하고, 결과를 모든 단계에 컨텍스트로 전달합니다.

### 1. 시리즈 컨텍스트 수집

대상 파일이 시리즈(파일명에 `-N` 접미사)인 경우, 같은 시리즈의 다른 파트를 읽어 다음을 수집합니다.

- 핵심 용어와 표기법 (예: "WebSocket" vs "웹소켓")
- `##` 섹션 제목 목록
- 각 파트가 전제하는 사전 지식 수준

시리즈가 아닌 단독 글이면 이 단계를 건너뜁니다.

### 2. 파일 내 자산 인벤토리

대상 파일에서 다음 자산을 추출하여 목록화합니다.

- **코드 블록**: 위치(줄 번호), 언어, 줄 수, 주요 변수/함수 이름
- **다이어그램**: 위치(줄 번호), 엔티티 이름 목록
- **시나리오 값**: IP 주소, 포트, 호스트명 등 구체적 값

이 인벤토리는 이후 단계 간 규칙 및 후속 점검에서 참조됩니다.

---

## 실행 절차

아래 8개 커맨드 스킬을 `Skill` 도구로 **순서대로** 실행합니다.
각 단계는 이전 단계의 수정 결과 위에서 동작합니다.
다음 단계는 반드시 이전 단계가 완료된 후 시작합니다.

| 단계 | 스킬 | 역할 |
|------|------|------|
| 0 | `/equalize-baseline $ARGUMENTS` | 기준선 보강 — 설명 밀도, 도입부 연결, 마무리 형식 |
| 1 | `/edit-writing $ARGUMENTS` | 골격 — 용어, 구조, 문장 |
| 2 | `/clarify-writing $ARGUMENTS` | 이해 — 설명 완성도 |
| 3 | `/refine-style $ARGUMENTS` | 목소리 — 톤, 리듬, 서사 |
| 4 | `/smooth-flow $ARGUMENTS` | 흐름 — 자연스러움, 즉시 이해 |
| 5 | `/verify-facts $ARGUMENTS` | 사실 — 사실관계 검증 |
| 6 | `/deep-review $ARGUMENTS` | 독자 시뮬레이션 — 읽기 경험 |
| 7 | `/align-reference $ARGUMENTS` | 레퍼런스 정렬 — 구조/품질 정합 |

---

## 단계 간 규칙

- 각 단계는 **파일을 직접 수정**합니다 (Edit 도구 사용).
- 각 단계 완료 시 변경 사항을 **3~5줄로 요약**합니다.
- YAML 프론트매터는 어떤 단계에서도 수정하지 않습니다.
- 원래 의미를 훼손하지 않습니다.

### 사용자 문체 규칙

아래 규칙은 **모든 단계에서** 적용되는 절대 규칙입니다. 개별 스킬의 지침과 충돌하면 이 규칙이 우선합니다.

#### 1. 질문형 문체 금지

글 본문에서 수사적 질문("~할까요?", "~인가요?", "어떻게 ~할까요?")을 **사용하지 않습니다.** 선언문으로 전환합니다.

| 금지 | 대안 |
|------|------|
| "어떻게 구분할까요?" | "하지만 문제가 있습니다." |
| "왜 이 대역들일까요?" | "이 대역들이 선택된 이유가 있습니다." |
| "어떻게 가능할까요?" | "이것을 가능하게 하는 메커니즘이 있습니다." |

종결어미 다양성을 확보할 때에도 질문형 대신 다음 어미를 활용합니다: "~때문입니다", "~했습니다", "~있습니다", "~이며", "~했고".

#### 2. 기술 용어 보존

L2, L3, ARP, MAC, TTL 등 확립된 기술 용어는 **제거하거나 단순화하지 않습니다.** 대신 처음 등장 시 설명을 추가합니다.

- **금지**: "L2" → "2계층" 으로 대체하며 원래 용어 제거
- **금지**: "L2" → "이더넷" 으로 대체 — 친숙하지만 부정확한 용어로의 치환 (L2 ⊃ 이더넷, 정확성 훼손)
- **허용**: "L2(데이터 링크 계층)" 으로 설명을 붙이되 원래 용어 유지

**원칙: 이해도를 높이기 위해 내용을 생략하거나 느슨하게 설명하지 않습니다.** 초보자를 위한다는 이유로 정밀한 용어를 친숙하지만 범위가 다른 용어로 바꾸면, 독자가 잘못된 개념을 학습하게 됩니다. 정확한 용어를 유지하고 설명을 추가하는 것이 올바른 접근입니다.

#### 3. 메타 문장 금지

"뒤에서 다시 다룹니다", "이 부분은 다음 섹션에서 설명합니다" 같은 전방 참조 메타 문장을 **사용하지 않습니다.** 해당 지점에서 설명을 완결합니다.

- **금지**: "이 오버헤드는 뒤에서 다시 다룹니다."
- **대안**: 필요한 만큼 해당 지점에서 설명을 마칩니다. (예: "그만큼 전송 효율이 떨어집니다.")

#### 4. 교과서적 표현 추가 금지 목록

다음 표현을 사용하지 않습니다 (기존 금지 목록에 추가):

| 금지 표현 | 대안 |
|----------|------|
| "유의해야 합니다" | 구체적 상황으로 직접 설명 |
| "주목할 필요가 있습니다" | 바로 내용 서술 |
| "살펴볼 필요가 있습니다" | 바로 내용 서술 |

#### 5. 개념 글에서 설정/구현 코드 자제

개념을 설명하는 글에서는 JSON, YAML 설정 파일이나 구현 코드를 포함하지 않습니다. 개념 글은 원리와 메커니즘에 집중합니다.

- 판별 기준: 글의 시리즈 이름에 "실습", "Setup", "Tutorial" 등이 없으면 개념 글로 간주
- ASCII 다이어그램과 명령어 실행 결과는 허용 (구조/동작 설명 목적)

#### 6. 산문 우선

정보를 전달할 때 불릿 리스트보다 **산문(flowing prose)**을 우선합니다. 불릿 리스트는 3개 이상 항목의 병렬 비교, 요약, 체크리스트에만 사용합니다. 설명이 필요한 항목을 불릿으로 나열하지 않고, 문단으로 풀어 씁니다.

#### 7. 초보자 기준 설명

모든 개념은 **초보자**가 외부 자료 없이 이 글만으로 이해할 수 있도록 설명합니다.

- 암묵적 전제를 모두 풀어 씁니다. "A이므로 C이다" 형태에서 중간 단계 B를 빠뜨리지 않습니다.
- 새로운 개념(ARP, docker0, veth 등)이 등장하면 해당 지점에서 바로 설명합니다.
- 원리를 설명할 때 단계별로 풀어서 독자가 따라올 수 있게 합니다.

#### 8. 추상적 서술 구체화

"빠르다", "크다", "많이 줄어든다" 같은 추상적 표현 대신 **구체적 수치/값/이름**을 사용합니다.

- "빠르게 처리됩니다" → "10ms 이내에 처리됩니다"
- "많은 연결" → "수천 개의 동시 연결"
- 다이어그램/코드의 구체적 이름(veth-a, br0, 10.0.0.1)을 산문에서도 일관 사용합니다.

### 코드 블록 통합 규칙

1. 코드 블록 직전에 **도입 문장** 필수 — 무엇을 보여주는 코드인지 한 문장으로 설명
2. 코드 블록 직후에 **결과 설명** 필수 — 주석을 반복하는 것이 아니라, 코드가 만들어내는 결과나 의미를 설명
3. 같은 파일 내 코드 블록 간 **변수명 일관성** 유지
4. 15줄 초과 코드 블록은 **단계 분리** 또는 **인라인 주석**으로 가독성 확보

### 구체적 이름 사용 규칙

- 다이어그램이나 코드에 구체적 이름(예: `veth-a`, `br0`, `10.0.0.1`)이 정의되어 있으면, 산문에서 "한쪽 인터페이스", "브릿지", "IP 주소" 같은 추상적 표현 대신 **해당 구체적 이름을 사용**합니다.
- 사전 분석의 자산 인벤토리를 참조하여 불일치를 탐지합니다.

### 시리즈 일관성 규칙

- 이전 파트와 **용어 표기가 일치**해야 합니다 (사전 분석의 시리즈 컨텍스트 참조).
- 이전 파트에서 이미 상세 설명한 개념은 **간략 요약 + 링크**로 대체합니다.
- 이후 파트의 지식을 전제하지 않는지 확인합니다.

---

## 후속 점검

8단계 파이프라인 완료 후, 최종 출력 전에 다음 4가지 점검을 수행합니다.

### 1. 레퍼런스-매뉴얼 패턴 탐지

- **탐지 조건**: `####` 제목이 3개 이상 연속 + 각 본문 5줄 이하 + 항목 간 연결 서사 부재
- **조치 옵션**:
  - 비교 테이블로 통합
  - 1~2개를 서사적으로 설명하고 나머지는 테이블로 정리
  - 유형 간 연결 서사 추가 (차이점, 사용 시점 등)

### 2. 코드 블록 통합 최종 확인

- [ ] 모든 코드 블록에 도입 문장이 있는가
- [ ] 모든 코드 블록에 결과 설명이 있는가
- [ ] 코드 블록 간 변수명이 일관적인가
- [ ] 15줄 초과 코드 블록에 단계 분리 또는 인라인 주석이 있는가

### 3. 다이어그램 일관성 확인

- [ ] 같은 파일 내 다이어그램 간 엔티티 이름이 일관적인가
- [ ] 산문에서 다이어그램 엔티티를 지칭할 때 정확한 이름을 사용하는가

### 4. 시리즈 정합성 확인

- [ ] 시리즈 내 용어 표기가 일치하는가
- [ ] 이전 파트와 중복 설명이 없는가 (있다면 요약 + 링크로 대체)
- [ ] 교차 참조(링크)가 정확한가

### 5. 초보자 이해도 최종 확인

- [ ] 암묵적 전제가 남아 있지 않은가 — "A이므로 C이다"에서 중간 단계 B가 모두 명시되어 있는가
- [ ] 처음 등장하는 개념마다 해당 지점에서 구체적 설명이 제공되는가
- [ ] 개념이 직관적으로 이해할 수 있도록 풀어 쓰여 있는가 (정의만 제시하지 않고 원리와 맥락 포함)
- [ ] 추상적 표현("빠르다", "크다") 없이 구체적 수치/값이 제시되는가
- [ ] 초보자가 외부 자료 없이 이 글만으로 모든 내용을 따라갈 수 있는가

---

## 최종 출력

모든 단계 완료 후 다음을 출력합니다:

```
## 전체 리뷰 결과

### 단계별 요약
| 단계 | 수정 건수 | 주요 변경 |
|------|----------|----------|
| 0. 기준선 보강 | N건 | ... |
| 1. 골격 | N건 | ... |
| 2. 이해 | N건 | ... |
| 3. 목소리 | N건 | ... |
| 4. 흐름 | N건 | ... |
| 5. 사실 | ✓N / ✗N / ?N | ... |
| 6. 독자 시뮬레이션 | N건 | ... |
| 7. 레퍼런스 정렬 | N건 | ... |

### 사실 검증 보고서
(5단계의 ✗, ? 항목 상세)

### 특이사항
(단계 간 충돌이 있었다면 기록)

### 후속 점검 결과
| 점검 항목 | 결과 | 조치 내용 |
|----------|------|----------|
| 레퍼런스-매뉴얼 패턴 | ✓ 없음 / ✗ N건 탐지 | ... |
| 코드 블록 통합 | ✓ 완료 / ✗ N건 미비 | ... |
| 다이어그램 일관성 | ✓ 일치 / ✗ N건 불일치 | ... |
| 시리즈 정합성 | ✓ 일치 / ✗ N건 불일치 / — 단독 글 | ... |
```
