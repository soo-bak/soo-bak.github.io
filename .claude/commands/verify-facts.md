# 사실관계 검증 스킬 — 사실 (Facts)

주어진 글에 포함된 **사실관계의 정확성**을 검증합니다. 개념, 역사, 수치, 논리, 예시, 용어가 모두 정확한지 점검하고, 부정확한 부분을 수정합니다.

**사실의 정확성**을 다듬습니다.

## 파이프라인 위치

```
/edit-writing → /clarify-writing → /refine-style → /smooth-flow → ▶ /verify-facts → /deep-review → /align-reference
  골격             이해               목소리          흐름             사실              독자 시뮬레이션    레퍼런스 정렬
```

이 스킬은 파이프라인의 **다섯 번째 단계**입니다:
- 글의 뼈대 → `/edit-writing`
- 독자의 이해 → `/clarify-writing`
- 톤, 리듬, 서사 → `/refine-style`
- 읽기 흐름 → `/smooth-flow`
- 독자 경험 통합 점검 → `/deep-review`
- 레퍼런스 정렬 → `/align-reference`

## 인자
- `$ARGUMENTS`: 검증할 파일 경로 (선택사항). 없으면 사용자에게 파일 또는 텍스트를 요청합니다.

---

## 검증 유형

---

## 1. 개념 사실

기술적 개념 설명이 정확한가?

### 점검 대상

- 기술의 정의가 표준/RFC/공식 문서의 정의와 일치하는가?
- 동작 원리 설명이 실제 메커니즘과 부합하는가?
- 개념 간 관계(상위/하위, 포함/배타)가 올바른가?

### 검증 방법

1. 해당 개념의 **표준 정의**(RFC, 공식 문서, 교과서)와 대조
2. 동작 원리가 **실제 구현**과 일치하는지 확인
3. 과도한 단순화로 **핵심이 왜곡**되지 않았는지 확인

### 실제 사례

```
# 검증 대상
"DNS는 전 세계 수십억 개의 도메인을 처리하는 분산 데이터베이스입니다"
→ RFC 1034 §1: "a distributed database" ✓

"소켓은 네트워크 연결의 한쪽 끝을 나타내는 커널 객체입니다"
→ 커널이 관리하는 file descriptor로 표현됨. ✓
→ 단, "커널 객체"는 정확히는 "커널이 관리하는 자료구조"가 더 정확. ? 표시 후 확인

# 주의: 단순화가 왜곡이 되는 경우
"TCP는 데이터를 순서대로 전달합니다"
→ 정확. 하지만 "TCP가 패킷을 순서대로 보냅니다"라고 쓰면 부정확.
  TCP는 바이트 스트림을 순서대로 전달하고, 패킷 순서는 IP 계층의 문제.
```

### 점검 항목
- [ ] 기술 개념의 정의가 표준 문서와 일치하는가?
- [ ] 동작 원리 설명이 실제 메커니즘과 부합하는가?
- [ ] 단순화가 핵심을 왜곡하지 않았는가?

---

## 2. 역사적 사실

날짜, 인물, 사건이 정확한가?

### 점검 대상

- 연도와 날짜
- 인물과 소속 기관
- 사건의 인과 관계와 순서

### 검증 방법

1. RFC 문서의 **발행 연도와 저자**를 원본에서 확인
2. 기술 역사는 **복수의 출처**로 교차 검증
3. "최초", "처음" 같은 표현은 특히 엄밀하게 확인

### 실제 사례

```
# 검증 대상
"1983년 11월, Paul Mockapetris는 RFC 882와 RFC 883을 발표했습니다"
→ RFC 882 발행: 1983년 11월. ✓
→ 저자: P. Mockapetris. ✓

"1987년, RFC 1034와 RFC 1035가 발표되었습니다"
→ RFC 1034/1035 발행: 1987년 11월. ✓

# 주의: 미묘한 부정확
"1984년, Berkeley의 학생들이 BIND를 만들었습니다"
→ BIND 최초 구현: UC Berkeley, 1984년경. ✓
→ 단, "학생들"보다는 "대학원생 Douglas Terry 등"이 더 정확. ? 표시
```

### 점검 항목
- [ ] 연도가 원본 문서/출처와 일치하는가?
- [ ] 인물 이름과 소속이 정확한가?
- [ ] "최초", "처음" 같은 표현이 사실과 부합하는가?
- [ ] 사건의 선후 관계가 올바른가?

---

## 3. 수치 사실

수치가 정확한가?

### 점검 대상

- 프로토콜의 크기, 개수, 제한값
- 성능 수치(속도, 지연, 처리량)
- 통계와 비율

### 검증 방법

1. **RFC/표준 문서**에서 정확한 수치 확인
2. 단위와 기준이 올바른지 확인 (비트 vs 바이트, 옥텟 vs 문자)
3. "약", "대략" 없이 정확한 수치처럼 제시된 것이 실제로 정확한지 확인

### 실제 사례

```
# 검증 대상
"13개의 루트 서버 클러스터(A-root ~ M-root)"
→ A~M = 13개. ✓

"각 레이블은 최대 63자, 전체 이름은 최대 253자입니다"
→ RFC 1035 §2.3.4: 레이블 63옥텟(octets). ✓
→ 전체 이름: 255옥텟(와이어 형식), 253자(텍스트 표현). ✓
  단, "자"와 "옥텟"의 구분이 필요할 수 있음. ASCII라면 동일하지만 명시하면 더 정확.

# 주의: 가변적인 수치
".com의 NS 레코드 TTL은 48시간"
→ 현재 .com NS 레코드 TTL: 172800초 = 48시간. ✓
→ 단, TTL은 운영자 설정에 따라 변경될 수 있으므로 "현재 기준" 표시 권장. ?
```

### 점검 항목
- [ ] 프로토콜의 크기/제한값이 RFC/표준과 일치하는가?
- [ ] 단위(비트/바이트, 옥텟/문자)가 정확한가?
- [ ] 가변적인 수치가 확정적으로 서술되지 않았는가?
- [ ] "약", "대략" 표현이 필요한 곳에 빠져 있지 않은가?

---

## 4. 논리적 정합성

인과 관계와 추론이 타당한가?

### 점검 대상

- "A이므로 B이다" 형태의 인과 관계
- "A이면 B가 불가능하다" 형태의 부정 추론
- 전체 논증의 흐름 (전제 → 중간 단계 → 결론)

### 검증 방법

1. **전제가 사실인지** 먼저 확인
2. 전제에서 결론으로의 **추론이 타당한지** 확인
3. **반례가 존재하는지** 검토 — 반례가 있으면 주장이 틀리거나 조건이 필요

### 실제 사례

```
# 검증 대상: DNS-1 이름 충돌
[전제1] HOSTS.TXT에는 모든 호스트 이름이 하나의 목록에 들어 있었다
[전제2] 같은 이름이 두 개 있으면 어느 컴퓨터의 주소를 돌려줘야 할지 알 수 없다
[결론1] 이름은 전체에서 유일해야 했다
[결론2] MIT가 MAILSERVER를 먼저 등록하면, Stanford는 같은 이름을 쓸 수 없었다

검증:
- 전제1: 사실. HOSTS.TXT는 flat file. ✓
- 전제2: 사실. 이름→주소 매핑이 일대일이어야 조회 가능. ✓
- 전제1+전제2 → 결론1: 타당. 단일 lookup table에서 key 중복은 모호함. ✓
- 결론1 → 결론2: 타당. 유일성 제약 하에서 선점 논리. ✓

반례 검토:
- "같은 이름이 두 개 있어도 IP가 같으면 문제 없지 않나?"
  → 다른 조직이 같은 이름을 원하는 건 보통 다른 호스트를 가리키기 위함. 반례 해당 없음.

전체 논증: ✓
```

```
# 주의: 숨겨진 전제가 있는 논증
"평면적 목록이므로 이름 충돌이 발생했다"
→ "평면적 목록" → "이름 충돌"의 논리적 간극.
  숨겨진 전제: 평면적 목록에서는 이름이 전역 유일해야 하므로 충돌 가능성 증가.
→ 논리적으로 타당하지만, 전제가 명시되지 않으면 ? 표시.
  (이 경우 /clarify-writing의 "암묵적 전제" 점검 영역이기도 함)
```

### 점검 항목
- [ ] 인과 관계의 전제가 사실인가?
- [ ] 전제에서 결론으로의 추론이 논리적으로 타당한가?
- [ ] 반례가 존재하여 주장이 무효화되지 않는가?
- [ ] 필요 조건과 충분 조건이 혼동되지 않았는가?
- [ ] 상관관계를 인과관계로 서술하지 않았는가?

---

## 5. 예시 정확성

코드, 설정, 출력 예시가 실제와 부합하는가?

### 점검 대상

- 코드 문법과 실행 결과
- 설정 파일 형식과 값
- 명령어 출력 형식
- IP 주소, 도메인 이름 등 예시 값의 현실성

### 검증 방법

1. 코드/설정이 **실제 문법**에 맞는지 확인
2. 예시 출력이 **실제 도구의 출력 형식**과 일치하는지 확인
3. 예시에 사용된 **도메인, IP 주소**가 적절한지 확인 (예: example.com은 IANA 예약 도메인)

### 실제 사례

```
# 검증 대상: Zone File 형식
$TTL 3600
@   IN  SOA   ns1.example.com. admin.example.com. (
              2024010101  ; Serial
              3600        ; Refresh
              900         ; Retry
              604800      ; Expire
              86400 )     ; Minimum TTL
→ BIND Zone File 실제 형식과 일치. ✓
→ SOA 레코드 필드 순서 올바름. ✓
→ admin.example.com.은 관리자 이메일(admin@example.com)의 Zone File 표기법. ✓

# 검증 대상: dig 출력
;; ANSWER SECTION:
example.com.  3600  IN  A  93.184.216.34
→ dig 출력 형식과 일치. ✓
→ 93.184.216.34는 실제 example.com의 IP. ✓ (IANA 예시 도메인)

# 주의: 부정확한 예시
"192.168.1.1은 google.com의 IP입니다"
→ 192.168.1.1은 사설 IP(RFC 1918). 공인 서버 IP로 부적절. ✗
→ 수정: IANA 문서용 IP(198.51.100.x) 또는 실제 IP 사용
```

### 점검 항목
- [ ] 코드/설정 예시가 실제 문법에 맞는가?
- [ ] 명령어 출력이 실제 도구의 출력 형식과 일치하는가?
- [ ] 예시에 사용된 도메인/IP가 적절한가? (사설 IP를 공인 IP처럼 사용하지 않았는가?)
- [ ] 예시의 값(포트 번호, TTL 등)이 현실적인가?

---

## 6. 용어 정확성

기술 용어가 올바른 의미로 사용되었는가?

### 점검 대상

- 한글 번역이 원어의 의미를 정확히 전달하는가?
- 용어의 적용 범위가 올바른가? (과도하게 넓거나 좁지 않은가?)
- 업계에서 통용되는 표현인가?

### 검증 방법

1. 한글 번역어가 **원어의 의미**를 왜곡하지 않는지 확인
2. 용어가 **해당 맥락에서 올바르게** 사용되었는지 확인
3. **유사 용어와의 혼동**이 없는지 확인

### 실제 사례

```
# 정확한 사용
"권한 있는 서버(Authoritative Server)"
→ RFC 1035에서 사용하는 표준 용어. ✓

"Zone apex"
→ Zone의 최상위 이름을 지칭하는 표준 용어. ✓

# 주의: 유사 용어 혼동
"DNS 서버"를 "네임서버"와 혼용
→ 맥락에 따라 다름.
  "네임서버"는 보통 Authoritative Server를 지칭.
  "DNS 서버"는 리졸버를 포함한 넓은 의미.
→ 문맥상 의미가 명확하면 ✓, 모호하면 ? 표시.

# 부정확한 사용
"DNS가 URL을 IP로 변환합니다"
→ DNS는 도메인 이름을 IP로 변환. URL은 프로토콜+도메인+경로를 포함하는 더 넓은 개념. ✗
→ 수정: "DNS가 도메인 이름을 IP 주소로 변환합니다"
```

### 점검 항목
- [ ] 한글 번역이 원어의 의미를 정확히 전달하는가?
- [ ] 유사 용어(예: 서버/호스트, 도메인/URL)가 혼동 없이 사용되었는가?
- [ ] 용어의 적용 범위가 해당 맥락에서 올바른가?

---

## 검증 결과 분류

| 기호 | 의미 | 행동 |
|------|------|------|
| ✓ | 정확 | 유지 |
| ✗ | 부정확 | 수정 |
| ? | 불확실 | 표시하여 사용자에게 확인 요청 |

### 판단 기준

- **✓ 정확**: 표준 문서, RFC, 공식 출처에서 확인 가능
- **✗ 부정확**: 출처와 명백히 다르거나, 논리적 오류가 있음
- **? 불확실**: 출처 확인이 어렵거나, 해석에 따라 달라질 수 있음

**원칙: 확실한 것만 ✓ 표시. 조금이라도 불확실하면 ? 표시.**

---

## 작업 프로세스

### 1단계: 파일 읽기
- `$ARGUMENTS`가 있으면 해당 파일 읽기
- 없으면 사용자에게 파일 경로 또는 텍스트 요청

### 2단계: 주장 추출
- 문장 단위로 검증 가능한 주장을 식별
- 각 주장을 6개 유형 중 하나로 분류
- 하나의 문장이 여러 유형에 해당할 수 있음

### 3단계: 유형별 검증
- 각 유형의 검증 방법에 따라 사실 여부 확인
- 웹 검색(`WebSearch`)으로 RFC, 공식 문서, 신뢰할 수 있는 출처 확인
- 논리적 정합성은 전제→결론 흐름을 분해하여 검증

### 4단계: 부정확한 부분 수정
- ✗ 판정된 부분은 정확한 내용으로 수정
- 수정 시 근거(출처, 논리)를 반드시 기록
- 원래 문장의 의도를 유지하면서 사실만 교정

### 5단계: 출력
- 수정된 글 전체
- 검증 보고서 (아래 형식)

---

## 검증 보고서 형식

```markdown
## 검증 보고서

### ✗ 부정확 (수정 완료)
| 위치 | 원문 | 수정 | 근거 |
|------|------|------|------|
| Line 54 | "1982년경 수백 대" | "1982년경 약 200대" | RFC 문서 기록 |

### ? 불확실 (사용자 확인 필요)
| 위치 | 주장 | 불확실한 이유 |
|------|------|-------------|
| Line 74 | ".com TTL 48시간" | TTL은 운영자 설정에 따라 변동 가능 |

### ✓ 검증 완료
- 개념 사실: N건 ✓
- 역사적 사실: N건 ✓
- 수치 사실: N건 ✓
- 논리적 정합성: N건 ✓
- 예시 정확성: N건 ✓
- 용어 정확성: N건 ✓
```

---

## 병렬 작업 (긴 글의 경우)

긴 글은 섹션별로 나누어 서브에이전트에게 병렬로 검증을 요청할 수 있습니다.

### 서브에이전트 프롬프트
```
다음 글의 사실관계를 검증해주세요.

## 검증 유형
1. 개념 사실: 기술적 개념 설명이 표준/RFC와 일치하는가?
2. 역사적 사실: 날짜, 인물, 사건이 정확한가?
3. 수치 사실: 프로토콜 크기, 제한값, 성능 수치가 정확한가?
4. 논리적 정합성: 인과 관계의 전제가 사실이고 추론이 타당한가? 반례는 없는가?
5. 예시 정확성: 코드/설정/출력 예시가 실제와 부합하는가?
6. 용어 정확성: 기술 용어가 올바른 의미로 사용되었는가?

## 결과 분류
- ✓: 정확 (출처에서 확인 가능)
- ✗: 부정확 (수정 필요)
- ?: 불확실 (사용자 확인 필요)

## 원칙
- 확실한 것만 ✓ 표시. 불확실하면 반드시 ?
- 수정 시 근거(출처, 논리) 명시
- 기술 블로그에 적합한 수준의 정확성 기준

## 검증할 글
[섹션 내용]

## 출력
수정된 글 + 검증 보고서 (유형별 결과)
```

---

## 주의 사항

### 정확성 기준
- **학술 논문 수준이 아닌, 기술 블로그에 적합한 수준**을 기준으로 합니다
- 과도한 단순화가 **핵심을 왜곡**하면 수정하되, 교육적 목적의 합리적 단순화는 허용합니다
- "엄밀히 말하면 다르지만 독자의 이해에 지장이 없는" 수준의 차이는 ? 표시 후 판단을 사용자에게 맡깁니다

### 검증 태도
- **확실한 것만 ✓ 표시**: 기억에 의존하지 않고, 검색으로 확인
- **수정 시 근거 명시**: 어떤 출처/논리에 기반한 수정인지 반드시 기록
- **과잉 수정 금지**: 정확한 내용을 불필요하게 변경하지 않음
- **논리적 정합성 검증 시**: 전제→결론 흐름을 분해하고, 반례 존재 여부를 확인

### /clarify-writing과의 경계
- `/clarify-writing`의 "암묵적 전제"는 **설명이 빠져서 이해가 안 되는** 문제
- `/verify-facts`의 "논리적 정합성"은 **설명된 논리가 사실과 맞는지** 검증하는 문제
- 암묵적 전제가 발견되면 `/clarify-writing` 재실행을 권장

---

## 체크리스트

### 개념 수준
- [ ] 기술 개념의 정의가 표준 문서와 일치하는가?
- [ ] 동작 원리 설명이 실제 메커니즘과 부합하는가?
- [ ] 과도한 단순화가 핵심을 왜곡하지 않았는가?

### 사실 수준
- [ ] 연도, 인물, 사건이 원본 출처와 일치하는가?
- [ ] 수치(크기, 개수, 제한값)가 RFC/표준과 일치하는가?
- [ ] 가변적인 수치가 확정적으로 서술되지 않았는가?

### 논리 수준
- [ ] 인과 관계의 전제가 사실인가?
- [ ] 추론이 논리적으로 타당한가?
- [ ] 반례가 주장을 무효화하지 않는가?
- [ ] 상관관계를 인과관계로 서술하지 않았는가?

### 예시 수준
- [ ] 코드/설정이 실제 문법에 맞는가?
- [ ] 출력 형식이 실제 도구와 일치하는가?
- [ ] 도메인, IP 등 예시 값이 적절한가?

### 용어 수준
- [ ] 한글 번역이 원어의 의미를 정확히 전달하는가?
- [ ] 유사 용어가 혼동 없이 사용되었는가?
- [ ] 용어의 적용 범위가 맥락에서 올바른가?
