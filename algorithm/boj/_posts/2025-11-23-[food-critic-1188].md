---
layout: single
title: "[백준 1188] 음식 평론가 (C#, C++) - soo:bak"
date: "2025-11-23 02:55:00 +0900"
description: 소시지 N개를 M명의 평론가에게 균등 분배할 때 필요한 최소 칼질 횟수가 m-gcd(n,m)이 되는 이유와 이를 구현한 백준 1188번 음식 평론가 문제의 C# 및 C++ 풀이
tags:
  - 백준
  - BOJ
  - 1188
  - C#
  - C++
  - 알고리즘
  - 수학
  - 정수론
  - 유클리드호제법
keywords: "백준 1188, 백준 1188번, BOJ 1188, C# 풀이, C++ 풀이, 알고리즘"
---

## 문제 링크
[1188번 - 음식 평론가](https://www.acmicpc.net/problem/1188)

## 설명

동일한 소시지 `N`개를 `M`명의 평론가에게 정확히 같은 양으로 분배해야 합니다. 각 소시지는 어느 위치에서든 자를 수 있습니다.

이때 필요한 최소 칼질 횟수를 구하는 문제입니다.

<br>

## 접근법

각 평론가는 전체 소시지의 `1/M`만큼을 받아야 하므로, 전체를 `M`등분하여 총 `M`개의 조각이 필요합니다.

단순히 생각하면 `M - 1`번의 칼질이 필요할 것 같지만, 실제로는 더 적은 칼질로 가능합니다.

<br>
`g = gcd(N, M)`이라 하면 `N`과 `M`의 최대공약수로 인해 전체 문제를 `g`개의 동일한 패턴으로 나눌 수 있습니다.

예를 들어 `N = 4`, `M = 6`일 때 `g = 2`이므로, 2개 소시지를 3명에게 나누는 패턴을 2번 반복하면 됩니다.

<br>
각 패턴에서는 `N/g`개의 소시지를 `M/g`명에게 분배합니다.

`M/g`개의 조각이 필요하므로 `M/g - 1`번의 칼질이 필요합니다.

총 `g`개의 패턴이 있으므로 전체 칼질 횟수는 `g × (M/g - 1) = M - g`가 됩니다.

<br>
따라서 `gcd(N, M)`을 구한 후 `M - gcd(N, M)`을 출력하면 됩니다.

<br>

---

## Code

### C#

```csharp
using System;

namespace Solution {
  class Program {
    static int Gcd(int a, int b) {
      while (b != 0) {
        var temp = a % b;
        a = b;
        b = temp;
      }
      return a;
    }

    static void Main(string[] args) {
      var tokens = Console.ReadLine()!.Split();
      var n = int.Parse(tokens[0]);
      var m = int.Parse(tokens[1]);

      var g = Gcd(n, m);

      Console.WriteLine(m - g);
    }
  }
}
```

### C++

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int n, m; cin >> n >> m;
  int g = gcd(n, m);

  cout << m - g << "\n";

  return 0;
}
```

