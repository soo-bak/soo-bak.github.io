---
layout: single
title: "[백준 12851] 숨바꼭질 2 (C#, C++) - soo:bak"
date: "2025-11-27 00:30:00 +0900"
description: BFS로 최단 시간을 구하면서 동일한 최단 거리로 도달하는 경우를 모두 세는 백준 12851번 숨바꼭질 2 문제의 C# 및 C++ 풀이
---

## 문제 링크
[12851번 - 숨바꼭질 2](https://www.acmicpc.net/problem/12851)

## 설명

수빈이는 `N(0 ≤ N ≤ 100000)`에, 동생은 `K(0 ≤ K ≤ 100000)`에 있습니다. 수빈이는 1초에 `X-1`, `X+1`, `2X`로 이동할 수 있습니다.

동생을 찾는 **가장 빠른 시간**과, 그 최단 시간으로 도달하는 **방법의 수**를 구해야 합니다.

<br>

## 접근법

모든 간선 가중치가 1이므로 BFS로 최단 시간을 구합니다. 최단 거리 경로의 수를 세려면 “방문 여부”만으로는 부족하고, 각 위치에 도달한 **최단 시간**을 기록해야 합니다.

1. `dist[i] = -1`로 초기화 후 시작점 `N`의 거리를 0으로 설정하고 큐에 넣습니다.
2. 큐에서 꺼낸 `cur`에 대해 세 가지 이동을 생성합니다.
   - `next`가 범위 내이고 `dist[next] == -1`이면 `dist[next] = dist[cur] + 1`로 설정하고 큐에 넣습니다.
   - `dist[next] == dist[cur] + 1`인 경우는 이미 같은 최단 거리로 도달한 적이 있으므로, 카운트 누적을 위해 큐에 다시 넣지 않지만 도착지라면 경우의 수를 세야 합니다.
3. 목적지 `K`를 만났을 때 `dist[K]`가 비어 있으면 그것이 최소 시간입니다. 이후에도 `dist[next] == dist[K]`인 경로가 있으면 방법 수를 더합니다. `dist[next]`가 더 크면 무시합니다.

`dist[K]`보다 큰 레벨은 볼 필요 없지만, BFS 특성상 자연스럽게 종료됩니다.

<br>

---

## Code

### C#

```csharp
using System;
using System.Collections.Generic;

namespace Solution {
  class Program {
    const int MAX = 100000;

    static void Main(string[] args) {
      var tokens = Console.ReadLine()!.Split();
      int N = int.Parse(tokens[0]);
      int K = int.Parse(tokens[1]);

      int[] dist = new int[MAX + 1];
      Array.Fill(dist, -1);

      var q = new Queue<int>();
      dist[N] = 0;
      q.Enqueue(N);

      int minTime = -1;
      int ways = 0;

      while (q.Count > 0) {
        int cur = q.Dequeue();
        int curDist = dist[cur];

        if (minTime != -1 && curDist > minTime) break; // 이후는 더 느린 경로

        if (cur == K) {
          if (minTime == -1) minTime = curDist;
          if (curDist == minTime) ways++;
        }

        int[] nexts = { cur - 1, cur + 1, cur * 2 };
        foreach (int nxt in nexts) {
          if (nxt < 0 || nxt > MAX) continue;
          if (dist[nxt] == -1) {
            dist[nxt] = curDist + 1;
            q.Enqueue(nxt);
          }
        }
      }

      Console.WriteLine(minTime);
      Console.WriteLine(ways);
    }
  }
}
```

### C++

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  const int MAX = 100000;
  int N, K; cin >> N >> K;

  vector<int> dist(MAX + 1, -1);
  queue<int> q;
  dist[N] = 0;
  q.push(N);

  int minTime = -1;
  int ways = 0;

  while (!q.empty()) {
    int cur = q.front(); q.pop();
    int curDist = dist[cur];

    if (minTime != -1 && curDist > minTime) break;

    if (cur == K) {
      if (minTime == -1) minTime = curDist;
      if (curDist == minTime) ++ways;
    }

    int nexts[3] = {cur - 1, cur + 1, cur * 2};
    for (int nxt : nexts) {
      if (nxt < 0 || nxt > MAX) continue;
      if (dist[nxt] == -1) {
        dist[nxt] = curDist + 1;
        q.push(nxt);
      }
    }
  }

  cout << minTime << '\n' << ways << '\n';
  return 0;
}
```

