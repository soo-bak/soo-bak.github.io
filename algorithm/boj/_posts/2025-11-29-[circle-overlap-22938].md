---
layout: single
title: "[백준 22938] 백발백준하는 명사수 (C#, C++) - soo:bak"
date: "2025-11-29 12:55:00 +0900"
description: 두 원의 중심 거리와 반지름 합·차를 비교하여 한 점 접촉을 제외한 겹침 여부를 판정하는 백준 22938번 백발백준하는 명사수 문제의 C# 및 C++ 풀이
tags:
  - 백준
  - BOJ
  - 22938
  - C#
  - C++
  - 알고리즘
keywords: "백준 22938, 백준 22938번, BOJ 22938, C# 풀이, C++ 풀이, 알고리즘"
---

## 문제 링크
[22938번 - 백발백준하는 명사수](https://www.acmicpc.net/problem/22938)

## 설명

평면 위에 두 원이 있는 상황에서, 각 원의 중심 좌표 (x, y)와 반지름 r (-10^9 ≤ x, y ≤ 10^9, 1 ≤ r ≤ 10^9)이 주어질 때, 두 원이 한 점에서만 만나는 경우(외접 또는 내접)를 제외하고 겹치는 부분이 존재하는지 판정하는 문제입니다.

겹치는 부분이 있으면 "YES", 없으면 "NO"를 출력합니다.

<br>

## 접근법

두 원의 위치 관계는 두 중심 사이의 거리와 두 반지름의 합 및 차이로 판정할 수 있습니다.

두 원이 겹치는 영역을 가지려면 두 조건을 모두 만족해야 합니다:
- 두 중심 사이의 거리가 두 반지름의 합보다 작아야 함 (외접보다 가까워야 함)
- 두 중심 사이의 거리가 두 반지름 차이의 절댓값과 달라야 함 (내접이 아니어야 함)

<br>
예를 들어, 원 A의 중심이 (0, 0)이고 반지름이 5, 원 B의 중심이 (6, 0)이고 반지름이 3인 경우:
- 중심 거리: 6
- 반지름 합: 5 + 3 = 8
- 반지름 차이의 절댓값: |5 - 3| = 2
- 중심 거리(6) < 반지름 합(8) 이고, 중심 거리(6) ≠ 2이므로 겹침 → YES

다른 예로, 원 A의 중심이 (0, 0)이고 반지름이 5, 원 B의 중심이 (8, 0)이고 반지름이 3인 경우:
- 중심 거리: 8
- 반지름 합: 5 + 3 = 8
- 중심 거리(8) = 반지름 합(8)이므로 외접 (한 점에서만 만남) → NO

또 다른 예로, 원 A의 중심이 (0, 0)이고 반지름이 5, 원 B의 중심이 (2, 0)이고 반지름이 3인 경우:
- 중심 거리: 2
- 반지름 합: 5 + 3 = 8
- 반지름 차이의 절댓값: |5 - 3| = 2
- 중심 거리(2) < 반지름 합(8) 이지만, 중심 거리(2) = 2이므로 내접 (한 점에서만 만남) → NO

<br>
한 원이 다른 원을 완전히 포함하면서 내접하지 않는 경우(중심 거리 < 반지름 차이의 절댓값)도 겹치는 것으로 판정됩니다.

거리 계산 시 제곱근을 사용하면 부동소수점 오차가 발생할 수 있으므로, 모든 비교를 제곱한 값으로 처리하면 정확하게 판정할 수 있습니다.

<br>

---

## Code

### C#

```csharp
using System;

namespace Solution {
  class Program {
    static void Main(string[] args) {
      var input1 = Array.ConvertAll(Console.ReadLine()!.Split(), long.Parse);
      var input2 = Array.ConvertAll(Console.ReadLine()!.Split(), long.Parse);

      long x1 = input1[0], y1 = input1[1], r1 = input1[2];
      long x2 = input2[0], y2 = input2[1], r2 = input2[2];

      long dx = x1 - x2;
      long dy = y1 - y2;
      long distSq = dx * dx + dy * dy;
      long sum = r1 + r2;
      long diff = Math.Abs(r1 - r2);
      long sumSq = sum * sum;
      long diffSq = diff * diff;

      var overlap = distSq < sumSq && distSq != diffSq;
      Console.WriteLine(overlap ? "YES" : "NO");
    }
  }
}
```

### C++

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  ll x1, y1, r1; cin >> x1 >> y1 >> r1;
  ll x2, y2, r2; cin >> x2 >> y2 >> r2;

  ll dx = x1 - x2;
  ll dy = y1 - y2;
  ll distSq = dx * dx + dy * dy;
  ll sum = r1 + r2;
  ll diff = abs(r1 - r2);
  ll sumSq = sum * sum;
  ll diffSq = diff * diff;

  bool overlap = distSq < sumSq && distSq != diffSq;
  cout << (overlap ? "YES" : "NO") << '\n';
  
  return 0;
}
```

