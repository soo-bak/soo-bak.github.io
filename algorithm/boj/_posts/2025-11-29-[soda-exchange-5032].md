---
layout: single
title: "[백준 5032] 탄산 음료 (C#, C++) - soo:bak"
date: "2025-11-29 22:00:00 +0900"
description: 빈 병을 모아 새 병으로 교환할 때 총 몇 병을 마실 수 있는지 계산하는 백준 5032번 탄산 음료 문제의 C# 및 C++ 풀이와 해설
tags:
  - 백준
  - BOJ
  - 5032
  - C#
  - C++
  - 알고리즘
keywords: "백준 5032, 백준 5032번, BOJ 5032, C# 풀이, C++ 풀이, 알고리즘"
---

## 문제 링크
[5032번 - 탄산 음료](https://www.acmicpc.net/problem/5032)

## 설명

빈 병 교환 규칙이 주어지는 상황에서, 현재 보유한 빈 병의 수 e, 길에서 찾은 빈 병의 수 f, 새 병으로 교환하는 데 필요한 빈 병의 수 c가 주어질 때, 총 몇 병의 탄산 음료를 마실 수 있는지 구하는 문제입니다.

새 병을 마시면 빈 병이 생기고, 이 빈 병들을 모아 다시 새 병으로 교환할 수 있습니다. 이 과정을 더 이상 교환할 수 없을 때까지 반복합니다.

<br>

## 접근법

처음에 가지고 있는 전체 빈 병 개수는 e + f입니다.

<br>
현재 보유한 빈 병 개수를 c로 나눈 몫만큼 새 병으로 교환할 수 있습니다. 이 새 병들을 마시면 해당 개수만큼 빈 병이 다시 생깁니다. 교환하고 남은 빈 병 개수는 나머지로 구할 수 있습니다.

교환으로 얻은 새 병을 마셔서 생긴 빈 병과 교환하고 남은 빈 병을 합치면 다음 라운드에서 사용할 수 있는 총 빈 병 개수가 됩니다. 이 과정을 보유한 빈 병 개수가 c보다 작아질 때까지 반복하며, 마신 병 수를 누적합니다.

<br>

---

## Code

### C#

```csharp
using System;

namespace Solution {
  class Program {
    static void Main(string[] args) {
      var input = Array.ConvertAll(Console.ReadLine()!.Split(), int.Parse);
      var owned = input[0];
      var found = input[1];
      var required = input[2];

      var emptyBottles = owned + found;
      var totalDrank = 0;
      
      while (emptyBottles >= required) {
        var exchanged = emptyBottles / required;
        var remaining = emptyBottles % required;
        totalDrank += exchanged;
        emptyBottles = exchanged + remaining;
      }
      
      Console.WriteLine(totalDrank);
    }
  }
}
```

### C++

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int owned, found, required;
  cin >> owned >> found >> required;
  
  int emptyBottles = owned + found;
  int totalDrank = 0;
  
  while (emptyBottles >= required) {
    int exchanged = emptyBottles / required;
    int remaining = emptyBottles % required;
    totalDrank += exchanged;
    emptyBottles = exchanged + remaining;
  }
  
  cout << totalDrank << "\n";
  
  return 0;
}
```


