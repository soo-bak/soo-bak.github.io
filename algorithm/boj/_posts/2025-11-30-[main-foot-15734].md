---
layout: single
title: "[백준 15734] 명장 남정훈 (C#, C++) - soo:bak"
date: "2025-11-30 01:48:00 +0900"
description: 왼발·오른발·양발 선수를 사용해 좌우 균형을 맞춘 뒤 최대 잔류 인원을 구하는 백준 15734번 명장 남정훈 문제의 C# 및 C++ 풀이와 해설
tags:
  - 백준
  - BOJ
  - 15734
  - C#
  - C++
  - 알고리즘
keywords: "백준 15734, 백준 15734번, BOJ 15734, C# 풀이, C++ 풀이, 알고리즘"
---

## 문제 링크
[15734번 - 명장 남정훈](https://www.acmicpc.net/problem/15734)

## 설명

선수들의 주발 정보가 주어지는 상황에서, 왼발 선수의 수 L, 오른발 선수의 수 R, 양발 선수의 수 A가 주어질 때, 좌우 선수 수를 균형있게 맞춘 후 팀에 남길 수 있는 최대 인원을 구하는 문제입니다.

양발 선수는 왼발과 오른발 중 어느 쪽으로든 배치할 수 있습니다. 좌우 선수 수가 같지 않으면 남는 인원은 방출해야 합니다.

<br>

## 접근법

먼저 양발 선수를 사용하여 왼발과 오른발 선수의 수를 균형있게 맞춥니다.

왼발과 오른발 중 더 적은 쪽에 양발 선수를 하나씩 배치하여 수를 맞춥니다. 양발 선수를 모두 사용했거나 왼발과 오른발 수가 같아지면 보충을 멈춥니다.

균형을 맞춘 후 남은 양발 선수는 2명씩 짝지어 왼발과 오른발에 하나씩 추가할 수 있습니다. 최종적으로 왼발과 오른발 중 적은 쪽의 2배가 팀에 남길 수 있는 최대 인원입니다.

<br>

---

## Code

### C#

```csharp
using System;

namespace Solution {
  class Program {
    static void Main(string[] args) {
      var input = Array.ConvertAll(Console.ReadLine()!.Split(), int.Parse);
      var leftFoot = input[0];
      var rightFoot = input[1];
      var bothFeet = input[2];

      while (bothFeet > 0 && leftFoot != rightFoot) {
        if (leftFoot < rightFoot) leftFoot++;
        else rightFoot++;
        bothFeet--;
      }
      
      var pairs = bothFeet / 2;
      leftFoot += pairs;
      rightFoot += pairs;

      Console.WriteLine(Math.Min(leftFoot, rightFoot) * 2);
    }
  }
}
```

### C++

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int leftFoot, rightFoot, bothFeet;
  cin >> leftFoot >> rightFoot >> bothFeet;
  
  while (bothFeet > 0 && leftFoot != rightFoot) {
    if (leftFoot < rightFoot) leftFoot++;
    else rightFoot++;
    bothFeet--;
  }
  
  int pairs = bothFeet / 2;
  leftFoot += pairs;
  rightFoot += pairs;
  
  cout << min(leftFoot, rightFoot) * 2 << "\n";
  
  return 0;
}
```


