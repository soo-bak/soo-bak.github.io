---
layout: single
title: "[백준 11066] 파일 합치기 (C#, C++) - soo:bak"
date: "2025-12-01 19:03:00 +0900"
description: 구간 DP와 누적합으로 파일 합치기 최소 비용을 구하는 백준 11066번 파일 합치기 문제의 C# 및 C++ 풀이와 해설
---

## 문제 링크
[11066번 - 파일 합치기](https://www.acmicpc.net/problem/11066)

## 설명
연속된 파일 크기 `K`개가 주어질 때, 두 파일을 합칠 비용이 두 파일 크기의 합이라고 하면 전체를 하나로 합치는 최소 비용을 구합니다.  
파일 순서는 바꿀 수 없으며, 구간을 나누어 합치는 위치에 따라 비용이 달라지므로 구간 DP로 최적값을 찾습니다.

<br>

## 접근법

- `dp[l][r]`: 구간 `[l,r]` 파일을 하나로 합치는 최소 비용.
- 누적합 `prefix[i]`를 이용해 구간 합 `sum(l,r) = prefix[r] - prefix[l-1]`을 O(1)로 구합니다.
- 전이: `dp[l][r] = min(dp[l][k] + dp[k+1][r] + sum(l,r))` for `k ∈ [l,r-1]`.
- 길이 1 구간 비용은 0. 길이를 늘려가며 채웁니다.
- `K ≤ 500`이므로 O(K³) DP가 제한 내에 가능합니다.

<br>

---

## Code

### C#

```csharp
using System;

namespace Solution {
  class Program {
    static void Main(string[] args) {
      int t = int.Parse(Console.ReadLine()!);
      while (t-- > 0) {
        int k = int.Parse(Console.ReadLine()!);
        var parts = Console.ReadLine()!.Split();

        int[] size = new int[k + 1];
        int[] prefix = new int[k + 1];
        for (int i = 1; i <= k; i++) {
          size[i] = int.Parse(parts[i - 1]);
          prefix[i] = prefix[i - 1] + size[i];
        }

        const int INF = int.MaxValue;
        int[,] dp = new int[k + 2, k + 2];

        for (int len = 1; len < k; len++) {
          for (int l = 1; l + len <= k; l++) {
            int r = l + len;
            int best = INF;
            int rangeSum = prefix[r] - prefix[l - 1];
            for (int mid = l; mid < r; mid++) {
              int cand = dp[l, mid] + dp[mid + 1, r] + rangeSum;
              if (cand < best) best = cand;
            }
            dp[l, r] = best;
          }
        }

        Console.WriteLine(dp[1, k]);
      }
    }
  }
}
```

### C++

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int tc; cin >> tc;
  while (tc--) {
    int k; cin >> k;
    vector<int> size(k + 1), prefix(k + 1, 0);
    for (int i = 1; i <= k; i++) {
      cin >> size[i];
      prefix[i] = prefix[i - 1] + size[i];
    }

    const int INF = INT_MAX;
    vector<vector<int>> dp(k + 2, vector<int>(k + 2, 0));

    for (int len = 1; len < k; len++) {
      for (int l = 1; l + len <= k; l++) {
        int r = l + len;
        int best = INF;
        int sum = prefix[r] - prefix[l - 1];
        for (int mid = l; mid < r; mid++) {
          int cand = dp[l][mid] + dp[mid + 1][r] + sum;
          if (cand < best) best = cand;
        }
        dp[l][r] = best;
      }
    }

    cout << dp[1][k] << "\n";
  }

  return 0;
}
```
