---
layout: single
title: "[백준 1703] 생장점 (C#, C++) - soo:bak"
date: "2025-12-07 23:35:00 +0900"
description: 해마다 분기와 가지치기를 반영해 잎의 개수를 계산하는 백준 1703번 생장점 문제의 C# 및 C++ 풀이와 해설
---

## 문제 링크
[1703번 - 생장점](https://www.acmicpc.net/problem/1703)

## 설명
해마다 분기 수와 가지치기 횟수가 주어질 때, 최종 잎의 개수를 구하는 문제입니다. 초기 묘목의 잎은 1개이며, 각 해마다 잎이 분기하여 늘어나고 가지치기로 줄어듭니다.

<br>

## 접근법
입력 한 줄이 한 나무를 나타내며, 나이 이후로 분기 수와 가지치기 수가 순서대로 주어집니다. 나이가 0이면 입력이 종료됩니다.

잎의 개수를 1에서 시작하여 각 해마다 현재 잎 수에 분기 수를 곱하고 가지치기 수를 뺍니다. 이 과정을 나이만큼 반복한 후 남은 잎의 개수를 출력합니다.

<br>

- - -

## Code

### C#
```csharp
using System;

class Program {
  static void Main() {
    while (true) {
      var first = Console.ReadLine();
      if (string.IsNullOrEmpty(first)) break;
      var parts = first.Split(' ', StringSplitOptions.RemoveEmptyEntries);
      var age = int.Parse(parts[0]);
      if (age == 0) break;

      int[] vals;
      if (parts.Length == 1) {
        vals = new int[age * 2];
        var filled = 0;
        while (filled < vals.Length) {
          var line = Console.ReadLine()!.Split(' ', StringSplitOptions.RemoveEmptyEntries);
          foreach (var s in line) vals[filled++] = int.Parse(s);
        }
      } else {
        vals = new int[age * 2];
        for (var i = 0; i < age * 2; i++)
          vals[i] = int.Parse(parts[i + 1]);
      }

      var ans = 1;
      for (var i = 0; i < age; i++) {
        var split = vals[2 * i];
        var cut = vals[2 * i + 1];
        ans = ans * split - cut;
      }
      Console.WriteLine(ans);
    }
  }
}
```

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef vector<int> vi;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  while (true) {
    int age;
    if (!(cin >> age) || age == 0) break;
    vi v(age * 2);
    for (int i = 0; i < 2 * age; i++) cin >> v[i];

    int ans = 1;
    for (int i = 0; i < age; i++) {
      int split = v[2 * i];
      int cut = v[2 * i + 1];
      ans = ans * split - cut;
    }
    cout << ans << "\n";
  }

  return 0;
}
```
