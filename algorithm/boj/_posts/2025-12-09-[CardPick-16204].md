---
layout: single
title: "[백준 16204] 카드 뽑기 (C#, C++) - soo:bak"
date: "2025-12-09 12:15:00 +0900"
description: 앞면 O/X 분포와 뒷면 O/X 계획이 주어질 때 같은 문자로 맞출 수 있는 최대 장수를 계산하는 백준 16204번 카드 뽑기 문제의 C# 및 C++ 풀이와 해설
tags:
  - 백준
  - BOJ
  - 16204
  - C#
  - C++
  - 알고리즘
  - 수학
  - 구현
  - arithmetic
keywords: "백준 16204, 백준 16204번, BOJ 16204, CardPick, C# 풀이, C++ 풀이, 알고리즘"
---

## 문제 링크
[16204번 - 카드 뽑기](https://www.acmicpc.net/problem/16204)

## 설명
앞면에 O가 M장, X가 N−M장 있는 카드에 대해, 뒷면에 O를 K장, X를 N−K장 적을 때 앞뒤가 같은 카드의 최대 개수를 구하는 문제입니다.

<br>

## 접근법
앞뒤가 같으려면 앞면 O인 카드에 뒷면도 O를 적거나, 앞면 X인 카드에 뒷면도 X를 적어야 합니다. 앞면 O인 카드는 M장이고 뒷면에 적을 O는 K개이므로, 둘 중 작은 수만큼 앞뒤 O를 맞출 수 있습니다. 마찬가지로 앞면 X인 카드는 N-M장이고 뒷면에 적을 X는 N-K개이므로, 둘 중 작은 수만큼 앞뒤 X를 맞출 수 있습니다. 두 값을 더하면 됩니다.

<br>

- - -

## Code

### C#
```csharp
using System;

class Program {
  static void Main() {
    var parts = Console.ReadLine()!.Split();
    var n = int.Parse(parts[0]);
    var m = int.Parse(parts[1]);
    var k = int.Parse(parts[2]);

    var ans = Math.Min(m, k) + Math.Min(n - m, n - k);
    Console.WriteLine(ans);
  }
}
```

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int n, m, k; cin >> n >> m >> k;
  cout << min(m, k) + min(n - m, n - k) << "\n";

  return 0;
}
```
