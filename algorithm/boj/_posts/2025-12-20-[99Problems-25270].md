---
layout: single
title: "[백준 25270] 99 Problems (C#, C++) - soo:bak"
date: "2025-12-20 16:02:00 +0900"
description: 주어진 수와 가장 가까운 99로 끝나는 양의 정수를 찾는 문제
---

## 문제 링크
[25270번 - 99 Problems](https://www.acmicpc.net/problem/25270)

## 설명
양의 정수가 주어질 때, 가장 가까운 99로 끝나는 양의 정수를 찾는 문제입니다. 거리가 같다면 더 큰 값을 선택합니다.

<br>

## 접근법
99로 끝나는 수는 99, 199, 299, ... 처럼 100 간격으로 존재합니다. 주어진 수를 100으로 나눈 몫을 이용해 현재 블록의 99와 바로 아래 블록의 99를 후보로 만듭니다.

아래 블록의 후보가 0 이하면 무시하고, 두 후보와의 거리를 비교해 더 가까운 것을 선택합니다. 거리가 같다면 더 큰 값을 출력합니다.

- - -

## Code

### C#
```csharp
using System;

class Program {
  static void Main() {
    var n = int.Parse(Console.ReadLine()!);

    var block = n / 100;
    var up = block * 100 + 99;
    var down = (block - 1) * 100 + 99;

    if (down <= 0) {
      Console.WriteLine(up);
      return;
    }

    var distUp = Math.Abs(up - n);
    var distDown = Math.Abs(n - down);

    var ans = distUp < distDown ? up
            : distUp > distDown ? down
            : Math.Max(up, down);

    Console.WriteLine(ans);
  }
}
```

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int n; cin >> n;

  int block = n / 100;
  int up = block * 100 + 99;
  int down = (block - 1) * 100 + 99;

  if (down <= 0) {
    cout << up << "\n";
    return 0;
  }

  int distUp = abs(up - n);
  int distDown = abs(n - down);

  int ans;
  if (distUp < distDown) ans = up;
  else if (distUp > distDown) ans = down;
  else ans = max(up, down);

  cout << ans << "\n";

  return 0;
}
```
