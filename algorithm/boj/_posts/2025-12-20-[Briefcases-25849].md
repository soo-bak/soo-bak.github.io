---
layout: single
title: "[백준 25849] Briefcases Full of Money (C#, C++) - soo:bak"
date: "2025-12-20 12:12:00 +0900"
description: "백준 25849번 C#, C++ 풀이 - 금액이 최대인 서류가방을 고르되 동률 시 지폐 수가 적은 것을 선택하는 문제"
tags:
  - 백준
  - BOJ
  - 25849
  - C#
  - C++
  - 알고리즘
keywords: "백준 25849, 백준 25849번, BOJ 25849, Briefcases, C# 풀이, C++ 풀이, 알고리즘"
---

## 문제 링크
[25849번 - Briefcases Full of Money](https://www.acmicpc.net/problem/25849)

## 설명
여섯 서류가방에 각각 다른 액면가의 지폐가 들어 있을 때, 총액이 가장 큰 서류가방의 액면가를 출력하는 문제입니다. 총액이 같으면 지폐 장수가 적은 서류가방을 선택합니다.

<br>

## 접근법
먼저 각 서류가방의 지폐 장수에 액면가를 곱해 총액을 구합니다.

다음으로 총액이 최대인 서류가방을 찾되, 동률일 때는 지폐 장수가 더 적은 것을 우선합니다.

- - -

## Code

### C#
```csharp
using System;

class Program {
  static void Main() {
    var denom = new[] {1, 5, 10, 20, 50, 100};
    var parts = Console.ReadLine()!.Split();
    var bestDenom = denom[0];
    var bestBills = int.Parse(parts[0]);
    var bestValue = bestBills * denom[0];

    for (var i = 1; i < 6; i++) {
      var bills = int.Parse(parts[i]);
      var value = bills * denom[i];
      if (value > bestValue || (value == bestValue && bills < bestBills)) {
        bestValue = value;
        bestBills = bills;
        bestDenom = denom[i];
      }
    }

    Console.WriteLine(bestDenom);
  }
}
```

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int denom[6] = {1, 5, 10, 20, 50, 100};
  int bills[6];
  for (int i = 0; i < 6; i++)
    cin >> bills[i];

  int bestDenom = denom[0];
  int bestBills = bills[0];
  int bestValue = bills[0] * denom[0];

  for (int i = 1; i < 6; i++) {
    int value = bills[i] * denom[i];
    if (value > bestValue || (value == bestValue && bills[i] < bestBills)) {
      bestValue = value;
      bestBills = bills[i];
      bestDenom = denom[i];
    }
  }

  cout << bestDenom << "\n";

  return 0;
}
```
