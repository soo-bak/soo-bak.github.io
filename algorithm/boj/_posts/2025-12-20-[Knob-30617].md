---
layout: single
title: "[백준 30617] Knob (C#, C++) - soo:bak"
date: "2025-12-20 16:02:00 +0900"
description: "백준 30617번 C#, C++ 풀이 - 두 노브의 이전 방향과 현재 방향을 비교해 재미도를 누적하는 문제"
tags:
  - 백준
  - BOJ
  - 30617
  - C#
  - C++
  - 알고리즘
  - 구현
keywords: "백준 30617, 백준 30617번, BOJ 30617, Knob, C# 풀이, C++ 풀이, 알고리즘"
---

## 문제 링크
[30617번 - Knob](https://www.acmicpc.net/problem/30617)

## 설명
T박자 동안 두 노브의 조작 방향이 주어질 때, 특정 조건을 만족하면 재미도가 올라가는 규칙에 따라 총 재미도를 구하는 문제입니다. 값이 0이면 노브를 돌리지 않고, -1은 반시계, 1은 시계 방향입니다.

<br>

## 접근법
재미도가 오르는 조건은 두 가지입니다. 현재 노브를 돌리는데 직전 박자에도 같은 노브를 같은 방향으로 돌렸다면 1점을 얻습니다. 현재 양쪽 노브를 모두 돌리는데 방향이 같다면 추가로 1점을 얻습니다.

각 박자마다 이전 박자의 방향을 기억해두고, 위 조건들을 확인하며 점수를 누적합니다.

- - -

## Code

### C#
```csharp
using System;

class Program {
  static void Main() {
    var t = int.Parse(Console.ReadLine()!);
    var prevL = 0;
    var prevR = 0;
    var score = 0;

    for (var i = 0; i < t; i++) {
      var parts = Console.ReadLine()!.Split();
      var l = int.Parse(parts[0]);
      var r = int.Parse(parts[1]);

      if (l != 0 && l == prevL) score++;
      if (r != 0 && r == prevR) score++;
      if (l != 0 && r != 0 && l == r) score++;

      prevL = l;
      prevR = r;
    }

    Console.WriteLine(score);
  }
}
```

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int t; cin >> t;
  int prevL = 0, prevR = 0, score = 0;

  for (int i = 0; i < t; i++) {
    int l, r; cin >> l >> r;

    if (l != 0 && l == prevL) score++;
    if (r != 0 && r == prevR) score++;
    if (l != 0 && r != 0 && l == r) score++;

    prevL = l;
    prevR = r;
  }

  cout << score << "\n";

  return 0;
}
```
