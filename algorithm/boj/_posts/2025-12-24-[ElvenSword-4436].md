---
layout: single
title: "[백준 4436] 엘프의 검 (C#, C++) - soo:bak"
date: "2025-12-24 12:30:00 +0900"
description: "백준 4436번 C#, C++ 풀이 - n의 배수를 이어 보며 0~9가 모두 등장하는 최소 k를 찾는 문제"
tags:
  - 백준
  - BOJ
  - 4436
  - C#
  - C++
  - 알고리즘
  - 수학
  - 브루트포스
keywords: "백준 4436, 백준 4436번, BOJ 4436, ElvenSword, C# 풀이, C++ 풀이, 알고리즘"
---

## 문제 링크
[4436번 - 엘프의 검](https://www.acmicpc.net/problem/4436)

## 설명
n의 배수들을 순서대로 보며 0~9가 모두 등장하는 가장 작은 k를 구하는 문제입니다.

<br>

## 접근법
k를 1부터 증가시키며 n의 k배에 해당하는 수의 자릿수를 확인합니다.

이후 등장한 숫자를 표시하고 0부터 9까지 모두 등장하면 그 k를 출력합니다.

- - -

## Code

### C#
```csharp
using System;

class Program {
  static void Main() {
    string? line;
    while ((line = Console.ReadLine()) != null) {
      line = line.Trim();
      if (line.Length == 0) continue;
      var n = int.Parse(line);

      var seen = new bool[10];
      var cnt = 0;
      var k = 0;
      while (cnt < 10) {
        k++;
        var x = (long)n * k;
        if (x == 0) {
          if (!seen[0]) { seen[0] = true; cnt++; }
        } else {
          while (x > 0) {
            var d = (int)(x % 10);
            if (!seen[d]) { seen[d] = true; cnt++; }
            x /= 10;
          }
        }
      }

      Console.WriteLine(k);
    }
  }
}
```

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  string line;
  while (cin >> line) {
    int n = stoi(line);
    bool seen[10] = {};
    int cnt = 0;
    int k = 0;

    while (cnt < 10) {
      k++;
      ll x = 1LL * n * k;
      if (x == 0) {
        if (!seen[0]) { seen[0] = true; cnt++; }
      } else {
        while (x > 0) {
          int d = x % 10;
          if (!seen[d]) { seen[d] = true; cnt++; }
          x /= 10;
        }
      }
    }

    cout << k << "\n";
  }

  return 0;
}
```
