---
layout: single
title: "[백준 27982] 큐브 더미 (C#, C++) - soo:bak"
date: "2025-12-25 16:05:00 +0900"
description: 여섯 방향 이웃이 모두 존재하는 큐브의 개수를 세는 백준 27982번 큐브 더미 문제의 C# 및 C++ 풀이와 해설
tags:
  - 백준
  - BOJ
  - 27982
  - C#
  - C++
  - 알고리즘
keywords: "백준 27982, 백준 27982번, BOJ 27982, CubePile, C# 풀이, C++ 풀이, 알고리즘"
---

## 문제 링크
[27982번 - 큐브 더미](https://www.acmicpc.net/problem/27982)

## 설명
큐브 좌표들이 주어질 때, 여섯 방향 이웃이 모두 존재하는 큐브의 개수를 구하는 문제입니다.

<br>

## 접근법
좌표를 3차원 배열에 표시해 둔 뒤, 존재하는 큐브마다 여섯 방향이 모두 채워졌는지 확인합니다.

조건을 만족하는 큐브만 세어서 출력합니다.

- - -

## Code

### C#
```csharp
using System;

class Program {
  static void Main() {
    var parts = Console.In.ReadToEnd().Split();
    var idx = 0;
    var n = int.Parse(parts[idx++]);
    var k = int.Parse(parts[idx++]);

    var arr = new bool[11, 11, 11];
    for (var t = 0; t < k; t++) {
      var x = int.Parse(parts[idx++]);
      var y = int.Parse(parts[idx++]);
      var z = int.Parse(parts[idx++]);
      arr[x, y, z] = true;
    }

    var cnt = 0;
    for (var i = 1; i <= n; i++) {
      for (var j = 1; j <= n; j++) {
        for (var l = 1; l <= n; l++) {
          if (arr[i, j, l] && arr[i - 1, j, l] && arr[i + 1, j, l] &&
              arr[i, j - 1, l] && arr[i, j + 1, l] && arr[i, j, l - 1] && arr[i, j, l + 1])
            cnt++;
        }
      }
    }

    Console.WriteLine(cnt);
  }
}
```

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int n, k; cin >> n >> k;

  int cnt = 0;
  bool arr[11][11][11] = {};
  while (k--) {
    int x, y, z; cin >> x >> y >> z;
    arr[x][y][z] = true;
  }

  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
      for (int l = 1; l <= n; l++) {
        if (arr[i][j][l] && arr[i - 1][j][l] && arr[i + 1][j][l] &&
            arr[i][j - 1][l] && arr[i][j + 1][l] && arr[i][j][l - 1] && arr[i][j][l + 1])
          cnt++;
      }
    }
  }

  cout << cnt << "\n";

  return 0;
}
```
