---
layout: single
title: "[백준 33674] 하늘에서 떨어지는 N개의 별 (C#, C++) - soo:bak"
date: "2025-12-25 16:05:00 +0900"
description: 최대 연속 일수를 계산해 최소 청소 횟수를 구하는 문제
---

## 문제 링크
[33674번 - 하늘에서 떨어지는 N개의 별](https://www.acmicpc.net/problem/33674)

## 설명
매일 각 지점에 별이 쌓일 때, D일 동안 폭발이 없도록 하는 최소 청소 횟수를 구하는 문제입니다.

<br>

## 접근법
가장 먼저 폭발하는 지점은 하루에 가장 많이 쌓이는 지점이므로, 그 지점만 관리하면 됩니다.

청소 직후부터 폭발 없이 버틸 수 있는 최대 일수는 K를 하루 최대 낙하량으로 나눈 값입니다.

D일을 이 최대 일수로 나누면 필요한 구간 수가 나오고, 청소는 구간 사이에서만 하므로 구간 수에서 1을 뺀 값이 최소 청소 횟수입니다.

- - -

## Code

### C#
```csharp
using System;

class Program {
  static void Main() {
    var parts = Console.In.ReadToEnd().Split();
    var idx = 0;
    var n = int.Parse(parts[idx++]);
    var d = int.Parse(parts[idx++]);
    var k = int.Parse(parts[idx++]);

    var maxS = 0;
    for (var i = 0; i < n; i++) {
      var s = int.Parse(parts[idx++]);
      if (s > maxS) maxS = s;
    }

    var lmax = k / maxS;
    var segments = (d + lmax - 1) / lmax;
    var cleans = segments - 1;
    Console.WriteLine(cleans);
  }
}
```

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int n, d, k; cin >> n >> d >> k;
  int maxS = 0;
  for (int i = 0; i < n; i++) {
    int s; cin >> s;
    if (s > maxS) maxS = s;
  }

  int lmax = k / maxS;
  int segments = (d + lmax - 1) / lmax;
  int cleans = segments - 1;
  cout << cleans << "\n";

  return 0;
}
```
