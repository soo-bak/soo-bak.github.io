---
layout: single
title: "[백준 14649] 문홍안 (C#, C++) - soo:bak"
date: "2025-12-25 16:05:00 +0900"
description: "백준 14649번 C#, C++ 풀이 - 돌을 밟은 횟수에 따라 색을 바꿔 최종 색깔 비율을 계산하는 문제"
tags:
  - 백준
  - BOJ
  - 14649
  - C#
  - C++
  - 알고리즘
  - 구현
keywords: "백준 14649, 백준 14649번, BOJ 14649, MoonHongAn, C# 풀이, C++ 풀이, 알고리즘"
---

## 문제 링크
[14649번 - 문홍안](https://www.acmicpc.net/problem/14649)

## 설명
비서들의 이동이 끝난 뒤 돌의 색깔 개수에 비례해 재산을 분배할 때, 각 색의 분배 금액을 출력하는 문제입니다.

<br>

## 접근법
각 돌 i를 밟는 횟수는 오른쪽으로 이동하는 비서 중 시작 위치가 i보다 작은 사람 수와, 왼쪽으로 이동하는 비서 중 시작 위치가 i보다 큰 사람 수의 합입니다.  
밟은 횟수의 3으로 나눈 나머지에 따라 최종 색깔을 결정해 파란색/빨간색/초록색 개수를 센 뒤 `P * 개수 / 100`을 출력합니다.

- - -

## Code

### C#
```csharp
using System;
using System.Text;

class Program {
  static void Main() {
    var parts = Console.In.ReadToEnd().Split();
    var idx = 0;
    var p = int.Parse(parts[idx++]);
    var n = int.Parse(parts[idx++]);

    var pos = new int[n];
    var dir = new char[n];
    for (var i = 0; i < n; i++) {
      pos[i] = int.Parse(parts[idx++]);
      dir[i] = parts[idx++][0];
    }

    var blue = 0;
    var red = 0;
    var green = 0;

    for (var i = 1; i <= 100; i++) {
      var steps = 0;
      for (var j = 0; j < n; j++) {
        if (dir[j] == 'R') {
          if (pos[j] < i) steps++;
        } else {
          if (pos[j] > i) steps++;
        }
      }

      var mod = steps % 3;
      if (mod == 0) blue++;
      else if (mod == 1) red++;
      else green++;
    }

    var sb = new StringBuilder();
    sb.AppendLine($"{p * blue / 100.0:F2}");
    sb.AppendLine($"{p * red / 100.0:F2}");
    sb.AppendLine($"{p * green / 100.0:F2}");
    Console.Write(sb);
  }
}
```

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int p, n; cin >> p >> n;
  vector<int> pos(n);
  vector<char> dir(n);
  for (int i = 0; i < n; i++)
    cin >> pos[i] >> dir[i];

  int blue = 0, red = 0, green = 0;
  for (int i = 1; i <= 100; i++) {
    int steps = 0;
    for (int j = 0; j < n; j++) {
      if (dir[j] == 'R') {
        if (pos[j] < i) steps++;
      } else {
        if (pos[j] > i) steps++;
      }
    }

    int mod = steps % 3;
    if (mod == 0) blue++;
    else if (mod == 1) red++;
    else green++;
  }

  cout << fixed << setprecision(2);
  cout << p * blue / 100.0 << "\n";
  cout << p * red / 100.0 << "\n";
  cout << p * green / 100.0 << "\n";

  return 0;
}
```
