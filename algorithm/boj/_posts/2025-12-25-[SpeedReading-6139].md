---
layout: single
title: "[백준 6139] Speed Reading (C#, C++) - soo:bak"
date: "2025-12-25 22:53:06 +0900"
description: "백준 6139번 C#, C++ 풀이 - 읽기와 휴식 주기가 주어질 때 책을 끝내는 데 필요한 분을 구하는 문제"
tags:
  - 백준
  - BOJ
  - 6139
  - C#
  - C++
  - 알고리즘
  - 수학
  - 구현
  - 시뮬레이션
keywords: "백준 6139, 백준 6139번, BOJ 6139, SpeedReading, C# 풀이, C++ 풀이, 알고리즘"
---

## 문제 링크
[6139번 - Speed Reading](https://www.acmicpc.net/problem/6139)

## 설명
각 소의 읽기 속도, 연속 읽기 시간, 휴식 시간이 주어질 때 책을 읽는 데 걸리는 최소 분을 구하는 문제입니다.

<br>

## 접근법
먼저 한 번에 연속으로 읽을 수 있는 페이지 수를 계산합니다.

다음으로 책을 이 연속 읽기 구간으로 몇 번 완전히 읽는지와 남는 페이지 수를 구합니다.

이후 남은 페이지가 0이면 마지막 휴식은 필요 없으므로 마지막 휴식 시간을 제외합니다.

그렇지 않으면 남은 페이지를 읽는 데 필요한 분을 올림 처리해 더합니다.

마지막으로 각 소의 값을 순서대로 출력합니다.

<br>

- - -

## Code

### C#
```csharp
using System;
using System.Text;

class Program {
  static void Main() {
    var parts = Console.In.ReadToEnd().Split();
    var idx = 0;
    var n = int.Parse(parts[idx++]);
    var k = int.Parse(parts[idx++]);

    var sb = new StringBuilder();
    for (var i = 0; i < k; i++) {
      var s = int.Parse(parts[idx++]);
      var t = int.Parse(parts[idx++]);
      var r = int.Parse(parts[idx++]);

      var per = s * t;
      var full = n / per;
      var rem = n % per;

      int minutes;
      if (rem == 0) minutes = full * (t + r) - r;
      else minutes = full * (t + r) + (rem + s - 1) / s;

      sb.AppendLine(minutes.ToString());
    }
    Console.Write(sb);
  }
}
```

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int n, k;
  if (!(cin >> n >> k)) return 0;
  for (int i = 0; i < k; i++) {
    int s, t, r;
    cin >> s >> t >> r;

    int per = s * t;
    int full = n / per;
    int rem = n % per;

    int minutes;
    if (rem == 0) minutes = full * (t + r) - r;
    else minutes = full * (t + r) + (rem + s - 1) / s;

    cout << minutes << "\n";
  }

  return 0;
}
```
