---
layout: single
title: "[백준 27913] SciComLove (2023) (C#, C++) - soo:bak"
date: "2025-12-26 00:18:41 +0900"
description: "백준 27913번 C#, C++ 풀이 - 반복 문자열에서 대문자 개수를 갱신해 출력하는 문제"
tags:
  - 백준
  - BOJ
  - 27913
  - C#
  - C++
  - 알고리즘
  - 구현
keywords: "백준 27913, 백준 27913번, BOJ 27913, SciComLove2023, C# 풀이, C++ 풀이, 알고리즘"
---

## 문제 링크
[27913번 - SciComLove (2023)](https://www.acmicpc.net/problem/27913)

## 설명
반복되는 문자열에서 특정 위치의 대소문자를 뒤집을 때마다 대문자 개수를 출력하는 문제입니다.

<br>

## 접근법
먼저 길이 10인 기본 문자열이 반복된다는 점을 이용해 초기 대문자 위치를 정합니다.

다음으로 각 위치가 몇 번 뒤집혔는지를 기록해 현재 상태를 알 수 있게 합니다.

이후 매번 뒤집는 위치의 현재 대소문자를 확인해 대문자 개수를 하나 증감합니다.

마지막으로 각 과정 뒤의 대문자 개수를 출력합니다.

<br>

- - -

## Code

### C#
```csharp
using System;
using System.Text;

class Program {
  static void Main() {
    var parts = Console.In.ReadToEnd().Split();
    var idx = 0;
    var n = int.Parse(parts[idx++]);
    var q = int.Parse(parts[idx++]);

    var baseStr = "SciComLove";
    var baseLen = baseStr.Length;

    var init = new bool[n];
    var flip = new bool[n];
    var upper = 0;

    for (var i = 0; i < n; i++) {
      var c = baseStr[i % baseLen];
      var isUpper = c >= 'A' && c <= 'Z';
      init[i] = isUpper;
      if (isUpper) upper++;
    }

    var sb = new StringBuilder();
    for (var i = 0; i < q; i++) {
      var x = int.Parse(parts[idx++]) - 1;
      var cur = init[x] ^ flip[x];
      if (cur) upper--;
      else upper++;
      flip[x] = !flip[x];
      sb.AppendLine(upper.ToString());
    }

    Console.Write(sb);
  }
}
```

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int n, q; cin >> n >> q;
  string baseStr = "SciComLove";
  int baseLen = (int)baseStr.size();

  vector<char> init(n, 0), flip(n, 0);
  int upper = 0;
  for (int i = 0; i < n; i++) {
    char c = baseStr[i % baseLen];
    bool isUpper = (c >= 'A' && c <= 'Z');
    init[i] = isUpper;
    if (isUpper) upper++;
  }

  for (int i = 0; i < q; i++) {
    int x; cin >> x;
    x--;
    bool cur = init[x] ^ flip[x];
    if (cur) upper--;
    else upper++;
    flip[x] = !flip[x];
    cout << upper << "\n";
  }

  return 0;
}
```
