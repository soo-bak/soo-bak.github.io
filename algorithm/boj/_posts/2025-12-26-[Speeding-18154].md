---
layout: single
title: "[백준 18154] Speeding (C#, C++) - soo:bak"
date: "2025-12-26 01:36:00 +0900"
description: "백준 18154번 C#, C++ 풀이 - 연속 구간 평균 속도 중 최대를 찾는 문제"
tags:
  - 백준
  - BOJ
  - 18154
  - C#
  - C++
  - 알고리즘
keywords: "백준 18154, 백준 18154번, BOJ 18154, Speeding, C# 풀이, C++ 풀이, 알고리즘"
---

## 문제 링크
[18154번 - Speeding](https://www.acmicpc.net/problem/18154)

## 설명
시간과 위치 기록이 순서대로 주어질 때, 어떤 순간에 반드시 기록한 속도의 최댓값을 구하는 문제입니다.

<br>

## 접근법
먼저 첫 기록을 기준으로 이전 시각과 거리를 잡습니다.

다음으로 인접한 두 기록 사이의 평균 속도를 계산하며 최댓값을 갱신합니다.

마지막으로 갱신된 최댓값을 출력합니다.

<br>

- - -

## Code

### C#
```csharp
using System;

class Program {
  static void Main() {
    var parts = Console.In.ReadToEnd().Split();
    var idx = 0;
    var n = int.Parse(parts[idx++]);

    var prevT = int.Parse(parts[idx++]);
    var prevD = int.Parse(parts[idx++]);
    var best = 0;

    for (var i = 1; i < n; i++) {
      var t = int.Parse(parts[idx++]);
      var d = int.Parse(parts[idx++]);
      var speed = (d - prevD) / (t - prevT);
      if (speed > best) best = speed;
      prevT = t;
      prevD = d;
    }

    Console.WriteLine(best);
  }
}
```

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int n; cin >> n;

  int prevT, prevD; cin >> prevT >> prevD;

  int best = 0;
  for (int i = 1; i < n; i++) {
    int t, d; cin >> t >> d;
    int speed = (d - prevD) / (t - prevT);
    if (speed > best) best = speed;
    prevT = t;
    prevD = d;
  }

  cout << best << "\n";
  
  return 0;
}
```
