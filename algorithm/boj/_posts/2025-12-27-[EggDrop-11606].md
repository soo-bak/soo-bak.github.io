---
layout: single
title: "[백준 11606] Egg Drop (C#, C++) - soo:bak"
date: "2025-12-27 02:15:00 +0900"
description: "백준 11606번 C#, C++ 풀이 - 실험 기록을 바탕으로 깨질 수 있는 최소 층과 안 깨질 수 있는 최대 층을 구하는 문제"
tags:
  - 백준
  - BOJ
  - 11606
  - C#
  - C++
  - 알고리즘
keywords: "백준 11606, 백준 11606번, BOJ 11606, EggDrop, C# 풀이, C++ 풀이, 알고리즘"
---

## 문제 링크
[11606번 - Egg Drop](https://www.acmicpc.net/problem/11606)

## 설명
여러 번의 낙하 실험 결과가 주어질 때, 달걀이 깨질 수 있는 최소 층과 깨지지 않을 수 있는 최대 층을 찾는 문제입니다.

1층은 항상 안전하고, k층은 항상 깨집니다.

<br>

## 접근법
기록에서 SAFE의 최댓값을 maxSafe, BROKEN의 최솟값을 minBroken으로 갱신합니다.

답은 (maxSafe + 1), (minBroken - 1) 이 됩니다. SAFE가 없으면 maxSafe = 1, BROKEN이 없으면 minBroken = k로 두면 됩니다.

<br>

- - -

## Code

### C#
```csharp
using System;
using System.Text;

class Program {
  static void Main() {
    var parts = Console.In.ReadToEnd().Split((char[])null, StringSplitOptions.RemoveEmptyEntries);
    var idx = 0;
    var n = int.Parse(parts[idx++]);
    var k = int.Parse(parts[idx++]);

    var maxSafe = 1;
    var minBroken = k;

    for (var i = 0; i < n; i++) {
      var floor = int.Parse(parts[idx++]);
      var res = parts[idx++];
      if (res == "SAFE") {
        if (floor > maxSafe) maxSafe = floor;
      } else if (floor < minBroken) minBroken = floor;
    }

    var lowestBreak = maxSafe + 1;
    var highestSafe = minBroken - 1;

    Console.WriteLine($"{lowestBreak} {highestSafe}");
  }
}
```

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int n, k; cin >> n >> k;
  int maxSafe = 1;
  int minBroken = k;

  for (int i = 0; i < n; i++) {
    int floor; string res; cin >> floor >> res;
    if (res == "SAFE") {
      if (floor > maxSafe) maxSafe = floor;
    } else if (floor < minBroken) minBroken = floor;
  }

  int lowestBreak = maxSafe + 1;
  int highestSafe = minBroken - 1;

  cout << lowestBreak << " " << highestSafe << "\n";

  return 0;
}
```
