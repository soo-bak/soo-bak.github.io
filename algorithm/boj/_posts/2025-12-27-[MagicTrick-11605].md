---
layout: single
title: "[백준 11605] Magic Trick (C#, C++) - soo:bak"
date: "2025-12-27 04:25:00 +0900"
description: "백준 11605번 C#, C++ 풀이 - 1~100 시작값에 연산을 적용해 음수나 분수가 되면 실패로 세는 문제"
tags:
  - 백준
  - BOJ
  - 11605
  - C#
  - C++
  - 알고리즘
  - 수학
  - 구현
  - 문자열
  - 브루트포스
  - arithmetic
keywords: "백준 11605, 백준 11605번, BOJ 11605, MagicTrick, C# 풀이, C++ 풀이, 알고리즘"
---

## 문제 링크
[11605번 - Magic Trick](https://www.acmicpc.net/problem/11605)

## 설명
1부터 100까지의 정수 중 하나를 시작값으로 정하고, 주어진 연산들을 순서대로 적용합니다. 연산 도중 음수가 되거나 나눗셈에서 나누어떨어지지 않으면 실패입니다.

1부터 100 중 실패하는 시작값이 몇 개인지 구하는 문제입니다.

<br>

## 접근법
연산 목록을 저장한 뒤, 각 시작값에 대해 시뮬레이션합니다. 뺄셈 후 음수가 되거나 나눗셈에서 나머지가 생기면 실패로 카운트합니다.

<br>

- - -

## Code

### C#
```csharp
using System;
using System.Collections.Generic;

class Program {
  static void Main() {
    var n = int.Parse(Console.ReadLine()!);
    var ops = new List<(string op, int v)>();
    for (var i = 0; i < n; i++) {
      var parts = Console.ReadLine()!.Split();
      ops.Add((parts[0], int.Parse(parts[1])));
    }

    var fail = 0;
    for (var k = 1; k <= 100; k++) {
      var val = k;
      var ok = true;
      foreach (var (op, v) in ops) {
        switch (op) {
          case "ADD": val += v; break;
          case "SUBTRACT":
            val -= v;
            if (val < 0) ok = false;
            break;
          case "MULTIPLY": val *= v; break;
          case "DIVIDE":
            if (val % v != 0) ok = false;
            else val /= v;
            break;
        }
        if (!ok) break;
      }
      if (!ok) fail++;
    }

    Console.WriteLine(fail);
  }
}
```

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef pair<string, int> psi;
typedef vector<psi> vpsi;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int n; cin >> n;
  vpsi ops(n);
  for (int i = 0; i < n; i++)
    cin >> ops[i].first >> ops[i].second;

  int fail = 0;
  for (int k = 1; k <= 100; k++) {
    int val = k;
    bool ok = true;
    for (auto& [op, v] : ops) {
      if (op == "ADD") val += v;
      else if (op == "SUBTRACT") {
        val -= v;
        if (val < 0) ok = false;
      } else if (op == "MULTIPLY") val *= v;
      else {
        if (val % v != 0) ok = false;
        else val /= v;
      }
      if (!ok) break;
    }
    if (!ok) fail++;
  }

  cout << fail << "\n";

  return 0;
}
```
