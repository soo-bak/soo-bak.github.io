---
layout: single
title: "순열 반복 구조(Permutation Cycle)의 개념과 알고리듬적 활용 - soo:bak"
date: "2025-04-22 23:10:00 +0900"
description: 특정 상태가 반복되며 발생하는 순열 사이클 구조의 개념과 그를 기반으로 한 알고리듬 문제 해결 방식을 정리한 글
---

## 순열 반복 구조란?

**순열 반복 구조**는 유한한 상태 공간 위에서 확정적인 규칙에 따라 상태를 전이시키는 과정에서<br>

언젠가 이전에 나타났던 상태로 다시 되돌아오는 구조를 말합니다.<br><br>

이는 알고리듬 문제에서 사이클 탐지나 중복 여부 확인, 경로 최적화 등 다양한 상황에서 기본 개념으로 사용됩니다.

---

## 핵심 아이디어

- 상태 공간이 유한하다면, 일정한 규칙에 따라 상태를 이동시킬 때 언젠가는 반드시 이전 상태로 돌아오게 됩니다.
- 이때 상태들의 흐름은 고리(cycle)를 형성하며 반복됩니다.
<br>

이러한 구조는 수학적으로는 **순열(permutation)** 형태로 해석할 수 있으며,

알고리듬적으로는 **사이클 탐지** 또는 **중복 방문 체크**로 다룰 수 있습니다.
<br>
<br>

### 왜 '순열'인가?

순열은 `N`개의 원소를 서로 섞어 새로운 순서를 만드는 것입니다.

특히, 각 원소가 정확히 하나의 위치로 대응되고, 동시에 다른 위치로부터 정확히 하나의 원소가 대응되기 때문에

일대일 대응(bijection)의 형태를 갖습니다.
<br>

이 구조는 함수처럼 작동합니다. 예를 들어, 아래와 같은 매핑이 주어진 경우:<br>

```text
1 → 3
2 → 1
3 → 2
```

- `1`은 `3`으로,
- `3`은 `2`로,
- `2`는 다시 `1`로 돌아갑니다.

<br>
이 흐름을 따라가면 `1 → 3 → 2 → 1`이라는 **폐쇄적인 순환 구조**가 만들어집니다.

이처럼, **각 원소가 하나의 위치로만 이동하고, 다시 정확히 그 위치로 되돌아오는 구조**는 순열의 기본적인 특성이며,

알고리듬 문제에서도 반복되는 상태 전이의 본질을 설명할 때 이 개념이 그대로 적용됩니다.
<br>

또한, 이렇게 구성된 순열은 항상 하나 이상의 순환 사이클을 포함하게 됩니다.

이 사이클은 문제의 정답을 판별하는 기준이 되거나, 최적화 대상이 되는 경우가 많습니다.
<br>

---

## 순열과 사이클 표현

임의의 순열을 다음과 같이 표현할 수 있습니다:<br>

```text
1 → 3 → 2 → 1
4 → 5 → 4
```
<br>

- `1`, `3`, `2`는 서로를 순서대로 가리키며 하나의 사이클을 형성합니다.
- `4`와 `5`도 서로 반복되는 구조를 가집니다.

이처럼 순열은 **여러 개의 불연속적인 사이클의 집합**으로 분해될 수 있습니다.<br>

이를 **순열의 사이클 분해(cycle decomposition)**라고 하며,

어떤 문제에서는 이 사이클의 개수나 길이가 핵심이 되기도 합니다.
<br>

---

## 순열 사이클을 이용한 문제 풀이 예시
<br>

### 예시: N개의 자리가 주어지고, 각 자리에 어떤 값이 매핑되어 있을 때

- 주어진 배열을 하나의 함수처럼 생각할 수 있습니다.
- 예: `arr[i] = j` 는 `i`에서 `j`로의 상태 전이를 의미합니다.
- 이 배열을 탐색하며 각 위치에서 방문 순서를 기록하면, 사이클이 발생하는 지점을 쉽게 찾을 수 있습니다.

```cpp
vector<int> a(n + 1);
vector<bool> visited(n + 1, false);

for (int i = 1; i <= n; ++i) {
  if (visited[i]) continue;
  int cur = i;
  while (!visited[cur]) {
    visited[cur] = true;
    cur = a[cur];
  }
  // 사이클 하나 완료
}
```

- 순열의 각 원소를 하나의 노드처럼 보고 연결 관계를 따라가며 방문하면,<br>
  중복 없이 모든 사이클을 탐색할 수 있습니다.

---

## 그래프 구조로서의 해석

순열 반복 구조는 각 노드에서 **출차수(outdegree)**가 정확히 `1`인 방향 그래프입니다.<br>

<br>
이러한 구조는 항상 다음과 같은 특징을 가집니다:

- 어떤 노드에서 출발하든 반드시 사이클에 도달합니다.
- 비순환 경로는 존재할 수 없으며, 모든 경로는 유한한 길이의 사이클로 수렴합니다.
- 전체 그래프는 **사이클 + 사이클로 향하는 경로(tail)** 구조처럼 해석될 수 있습니다.
<br>

<br>
이 구조를 기반으로 다음과 같은 문제를 해결할 수 있습니다:

- 전체 노드를 사이클 단위로 묶어 개수 세기
- 가장 긴/짧은 사이클의 길이 측정
- 주기성을 이용한 상태 예측 및 반복 패턴 찾기

---

## 활용 예시

- **배열을 순열로 보는 문제**: 원소들의 순서를 통해 사이클을 분석
- **방문 경로 추적**: `DFS`, `BFS` 중 **반복 상태** 탐지
- **해시 충돌 검사**: 특정 해시값에 도달했는지 여부 확인
- **암호학적 순환 분석**: 작은 키 공간에서 순열 구조가 성립되는지 확인
- **게임 상태 분석**: 특정 입력에 대해 동일한 상태가 다시 등장하는지 분석

---

## 주의할 점

- 사이클의 **시작 위치**와 **사이클 길이**를 구분해야 할 때는 토끼와 거북이 기법(Floyd’s Cycle Detection)을 사용할 수도 있습니다.
- 가능한 상태 수가 클 경우, 방문 여부 체크를 위한 자료구조의 크기와 메모리를 고려해야 합니다.
- 반복 구조가 고정되어 있는 경우에는 미리 계산된 수열을 사용하는 방식으로 최적화할 수도 있습니다.

---

## 마무리

순열 반복 구조는 제한된 상태 공간과 결정적인 전이 함수가 주어질 때 자연스럽게 등장하는 흐름입니다.<br>
<br>
사이클 여부를 탐지하거나, 중복 여부를 판별하는 대부분의 알고리듬 문제는 이 구조를 내포하고 있습니다.<br>
<br>
상태 전이가 유한하고 규칙적이라면, 언제든지 **반복**이 발생할 수 있다는 전제를 통해 문제 해결 방향을 단순화할 수 있습니다.
<br>
