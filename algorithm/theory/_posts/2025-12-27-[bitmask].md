---
layout: single
title: "비트마스킹 - 비트 연산을 활용한 집합 표현 - soo:bak"
date: "2025-12-27 01:40:00 +0900"
description: 비트마스킹의 원리와 비트 연산자, 집합을 정수로 표현하는 방법, 부분집합 탐색과 DP에서의 활용을 설명합니다.
---

## 비트마스킹이란?

**비트마스킹(Bitmask)** 은 정수의 이진수 표현을 이용하여 집합을 표현하는 기법입니다.

<br>
집합의 각 원소를 비트 하나에 대응시켜,

원소의 포함 여부를 0과 1로 나타냅니다.

<br>
예를 들어, 집합 `{0, 2, 3}`은 이진수 `1101`(십진수 13)으로 표현됩니다.

```
비트 위치:  3  2  1  0
비트 값:    1  1  0  1
원소:       3  2  -  0  → {0, 2, 3}
```

<br>

---

<br>

## 비트 연산자

### AND (&)

두 비트가 모두 1일 때만 1을 반환합니다.

```
  1101 (13)
& 1010 (10)
------
  1000 (8)
```

**활용**: 특정 비트가 켜져있는지 확인

<br>

### OR (|)

두 비트 중 하나라도 1이면 1을 반환합니다.

```
  1101 (13)
| 1010 (10)
------
  1111 (15)
```

**활용**: 특정 비트 켜기 (원소 추가)

<br>

### XOR (^)

두 비트가 다르면 1을 반환합니다.

```
  1101 (13)
^ 1010 (10)
------
  0111 (7)
```

**활용**: 특정 비트 토글 (있으면 제거, 없으면 추가)

<br>

### NOT (~)

모든 비트를 반전합니다.

```
~ 1101 = ...110010 (2의 보수)
```

<br>

### 왼쪽 시프트 (<<)

비트를 왼쪽으로 이동합니다. 오른쪽은 0으로 채워집니다.

```
1 << 3 = 1000 (8)
```

**활용**: 2의 거듭제곱 계산, 특정 위치 비트 생성

<br>

### 오른쪽 시프트 (>>)

비트를 오른쪽으로 이동합니다.

```
1101 >> 2 = 11 (3)
```

**활용**: 2로 나누기, 특정 비트 확인

<br>

---

<br>

## 비트마스크 기본 연산

### 1. 원소 추가 (i번째 비트 켜기)

```cpp
mask = mask | (1 << i);
// 또는
mask |= (1 << i);
```

<br>

### 2. 원소 제거 (i번째 비트 끄기)

```cpp
mask = mask & ~(1 << i);
// 또는
mask &= ~(1 << i);
```

<br>

### 3. 원소 확인 (i번째 비트가 켜져있는지)

```cpp
if (mask & (1 << i)) {
    // i번 원소가 포함됨
}
```

<br>

### 4. 원소 토글 (있으면 제거, 없으면 추가)

```cpp
mask = mask ^ (1 << i);
// 또는
mask ^= (1 << i);
```

<br>

### 5. 최하위 켜진 비트 구하기

```cpp
int lowest = mask & (-mask);
```

<br>

### 6. 최하위 켜진 비트 끄기

```cpp
mask = mask & (mask - 1);
```

<br>

---

<br>

## 비트마스크 활용 예시

### 1. 부분집합 순회

n개 원소의 모든 부분집합(2ⁿ개)을 순회합니다.

```cpp
int n = 4;
for (int mask = 0; mask < (1 << n); mask++) {
    cout << "부분집합: { ";
    for (int i = 0; i < n; i++) {
        if (mask & (1 << i))
            cout << i << " ";
    }
    cout << "}\n";
}
```

출력:
```
부분집합: { }
부분집합: { 0 }
부분집합: { 1 }
부분집합: { 0 1 }
...
부분집합: { 0 1 2 3 }
```

<br>

### 2. 특정 집합의 부분집합만 순회

집합 `mask`의 모든 부분집합을 순회합니다.

```cpp
int mask = 13; // 1101 = {0, 2, 3}
for (int sub = mask; sub > 0; sub = (sub - 1) & mask) {
    // sub는 mask의 부분집합
    cout << sub << "\n";
}
// 0도 포함하려면 별도 처리
```

<br>

### 3. 켜진 비트 개수 세기 (popcount)

```cpp
int count = __builtin_popcount(mask);    // int용
int count = __builtin_popcountll(mask);  // long long용
```

<br>

---

<br>

## 비트마스크 DP

비트마스크는 **방문한 상태**나 **선택한 원소**를 표현할 때 유용합니다.

<br>

### 예시: 외판원 문제 (TSP)

n개의 도시를 모두 방문하는 최소 비용을 구합니다.

<br>

`dp[mask][i]` = 방문한 도시 집합이 mask이고, 현재 도시가 i일 때의 최소 비용

```cpp
int n;
int dist[20][20];
int dp[1 << 20][20];

int tsp(int mask, int cur) {
    if (mask == (1 << n) - 1)  // 모든 도시 방문
        return dist[cur][0];

    if (dp[mask][cur] != -1)
        return dp[mask][cur];

    int result = INF;
    for (int next = 0; next < n; next++) {
        if (mask & (1 << next)) continue;  // 이미 방문

        int newMask = mask | (1 << next);
        result = min(result, dist[cur][next] + tsp(newMask, next));
    }

    return dp[mask][cur] = result;
}
```

<br>
시간 복잡도: **O(2ⁿ × n²)**

공간 복잡도: **O(2ⁿ × n)**

<br>

---

<br>

## 비트마스킹의 장점

**1. 공간 효율성**

집합을 하나의 정수로 표현하므로 메모리를 절약합니다.

<br>

**2. 빠른 연산**

비트 연산은 CPU에서 매우 빠르게 처리됩니다.

<br>

**3. 간결한 코드**

집합 연산을 한 줄로 표현할 수 있습니다.

<br>

---

<br>

## 주의사항

**1. 원소 개수 제한**

int는 32비트이므로 최대 32개, long long은 64개 원소까지 표현 가능합니다.

<br>

**2. 시프트 연산 시 타입 주의**

```cpp
// 잘못된 예
int mask = 1 << 35;  // 오버플로우

// 올바른 예
long long mask = 1LL << 35;
```

<br>

---

<br>

## 관련 문제 유형

비트마스킹은 다음과 같은 문제에서 활용됩니다:

- 외판원 문제 (TSP)
- 부분집합의 합
- 집합 커버 문제
- 게임 상태 표현
- 연결 요소 표현
- 순열/조합 생성

<br>

