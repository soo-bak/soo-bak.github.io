---
layout: single
title: "분할정복(Divide and Conquer)의 원리와 설계 - soo:bak"
date: "2025-12-27 01:20:00 +0900"
description: 분할정복의 핵심 개념인 분할, 정복, 결합 단계와 대표적인 알고리즘인 병합정렬, 퀵정렬, 이분탐색을 통해 분할정복을 설명합니다.
---

## 분할정복이란?

**분할정복(Divide and Conquer)** 은 큰 문제를 작은 부분 문제로 나누어 해결한 뒤, 그 결과를 합쳐 전체 문제의 답을 구하는 알고리즘 설계 기법입니다.

<br>
분할정복은 세 단계로 구성됩니다:

<br>

**1. 분할(Divide)**

문제를 동일한 유형의 더 작은 부분 문제로 나눕니다.

<br>

**2. 정복(Conquer)**

부분 문제가 충분히 작으면 직접 해결합니다.

그렇지 않으면 재귀적으로 분할정복을 적용합니다.

<br>

**3. 결합(Combine)**

부분 문제의 해를 합쳐 원래 문제의 해를 구합니다.

<br>

---

<br>

## 분할정복 vs 동적 계획법

두 기법 모두 문제를 부분 문제로 나누지만, 중요한 차이가 있습니다.

<br>

| 특성 | 분할정복 | 동적 계획법 |
|------|---------|------------|
| 부분 문제 중복 | 없음 | 있음 |
| 결과 저장 | 불필요 | 필요 (메모이제이션) |
| 접근 방식 | Top-down | Top-down 또는 Bottom-up |

<br>
분할정복에서 부분 문제들은 **서로 독립적**입니다.

같은 부분 문제를 여러 번 풀지 않기 때문에 결과를 저장할 필요가 없습니다.

<br>

---

<br>

## 분할정복의 대표 예시

### 1. 병합 정렬 (Merge Sort)

배열을 반으로 나누어 각각 정렬한 뒤, 합치는 방식입니다.

<br>

**분할**: 배열을 절반으로 나눕니다.

**정복**: 각 부분을 재귀적으로 정렬합니다.

**결합**: 정렬된 두 부분을 하나로 합칩니다.

<br>

```
[38, 27, 43, 3, 9, 82, 10]
         분할
[38, 27, 43, 3]  [9, 82, 10]
     분할             분할
[38, 27] [43, 3]  [9, 82] [10]
   정복     정복     정복
[27, 38] [3, 43]  [9, 82] [10]
     결합             결합
[3, 27, 38, 43]  [9, 10, 82]
         결합
[3, 9, 10, 27, 38, 43, 82]
```

<br>

**시간 복잡도**: O(n log n)

**공간 복잡도**: O(n)

<br>

### 2. 퀵 정렬 (Quick Sort)

피벗을 기준으로 작은 원소와 큰 원소를 분리하여 정렬합니다.

<br>

**분할**: 피벗보다 작은 원소는 왼쪽, 큰 원소는 오른쪽으로 분리합니다.

**정복**: 각 부분을 재귀적으로 정렬합니다.

**결합**: 이미 정렬된 상태이므로 추가 작업이 필요 없습니다.

<br>

```
[3, 7, 8, 5, 2, 1, 9, 5, 4]  피벗: 5
[3, 2, 1, 4] [5] [7, 8, 9, 5]
     재귀          재귀
[1, 2, 3, 4] [5] [5, 7, 8, 9]
```

<br>

**평균 시간 복잡도**: O(n log n)

**최악 시간 복잡도**: O(n²) (이미 정렬된 경우)

<br>

### 3. 이분 탐색 (Binary Search)

정렬된 배열에서 값을 찾을 때, 탐색 범위를 절반씩 줄입니다.

<br>

**분할**: 중간 값과 목표 값을 비교합니다.

**정복**: 목표가 있는 절반만 탐색합니다.

**결합**: 찾으면 반환, 못 찾으면 다음 단계로.

<br>

```
[1, 3, 5, 7, 9, 11, 13]  목표: 9

중간값 7 < 9 → 오른쪽 탐색
[9, 11, 13]

중간값 11 > 9 → 왼쪽 탐색
[9]

중간값 9 == 9 → 찾음!
```

<br>

**시간 복잡도**: O(log n)

<br>

---

<br>

## 분할정복 시간 복잡도 분석

분할정복 알고리즘의 시간 복잡도는 **마스터 정리(Master Theorem)** 로 분석합니다.

<br>

재귀 관계식 `T(n) = aT(n/b) + f(n)`에서:

- `a`: 부분 문제의 개수
- `b`: 문제 크기가 줄어드는 비율
- `f(n)`: 분할과 결합에 드는 비용

<br>

**예시: 병합 정렬**

`T(n) = 2T(n/2) + O(n)`

→ **O(n log n)**

<br>

**예시: 이분 탐색**

`T(n) = T(n/2) + O(1)`

→ **O(log n)**

<br>

---

<br>

## 분할정복 구현

### 병합 정렬 (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

void merge(vector<int>& arr, int left, int mid, int right) {
    vector<int> temp;
    int i = left, j = mid + 1;

    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j])
            temp.push_back(arr[i++]);
        else
            temp.push_back(arr[j++]);
    }

    while (i <= mid) temp.push_back(arr[i++]);
    while (j <= right) temp.push_back(arr[j++]);

    for (int k = left; k <= right; k++)
        arr[k] = temp[k - left];
}

void mergeSort(vector<int>& arr, int left, int right) {
    if (left >= right) return;

    int mid = (left + right) / 2;
    mergeSort(arr, left, mid);      // 왼쪽 정렬
    mergeSort(arr, mid + 1, right); // 오른쪽 정렬
    merge(arr, left, mid, right);   // 병합
}
```

<br>

### 거듭제곱 빠르게 계산하기

분할정복을 이용하면 `a^n`을 **O(log n)** 에 계산할 수 있습니다.

<br>

```cpp
long long power(long long a, long long n, long long mod) {
    if (n == 0) return 1;

    long long half = power(a, n / 2, mod);
    long long result = (half * half) % mod;

    if (n % 2 == 1)
        result = (result * a) % mod;

    return result;
}
```

<br>

---

<br>

## 분할정복 적용 조건

분할정복이 효과적인 문제는 다음 특성을 가집니다:

<br>

**1. 문제를 같은 유형의 작은 문제로 나눌 수 있음**

<br>

**2. 부분 문제의 해를 합쳐 전체 해를 구할 수 있음**

<br>

**3. 부분 문제들이 서로 독립적임**

중복 계산이 많으면 DP가 더 적합합니다.

<br>

---

<br>

## 관련 문제 유형

분할정복은 다음과 같은 문제에서 활용됩니다:

- 정렬 알고리즘 (병합 정렬, 퀵 정렬)
- 이분 탐색 및 응용
- 거듭제곱, 행렬 거듭제곱
- 가장 가까운 두 점 (Closest Pair)
- 큰 정수 곱셈 (카라츠바 알고리즘)
- 고속 푸리에 변환 (FFT)

<br>

