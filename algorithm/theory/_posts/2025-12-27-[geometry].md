---
layout: single
title: "기하학 알고리즘 - CCW와 기본 연산 - soo:bak"
date: "2025-12-27 02:10:00 +0900"
description: CCW(외적)를 이용한 방향 판별, 선분 교차 판정, 다각형 넓이 계산 등 기하학 알고리즘의 핵심을 설명합니다.
---

## 기하학 알고리즘이란?

**기하학 알고리즘(Computational Geometry)** 은 점, 선, 다각형 등 기하학적 객체를 다루는 알고리즘입니다.

<br>
게임 개발, 지도 서비스, CAD 프로그램, 로봇 공학 등 다양한 분야에서 활용됩니다.

<br>

---

<br>

## 벡터의 기초

### 벡터 표현

점 A(x₁, y₁)에서 점 B(x₂, y₂)로의 벡터:

```
AB = (x₂ - x₁, y₂ - y₁)
```

<br>

### 벡터의 내적 (Dot Product)

```
A · B = x₁×x₂ + y₁×y₂ = |A||B|cosθ
```

내적이 0이면 두 벡터는 **수직**입니다.

<br>

### 벡터의 외적 (Cross Product)

2D에서 외적은 스칼라 값을 반환합니다.

```
A × B = x₁×y₂ - y₁×x₂ = |A||B|sinθ
```

외적의 부호로 **방향**을 판별합니다.

<br>

---

<br>

## CCW (Counter-Clockwise)

**CCW**는 세 점의 방향 관계를 판별하는 알고리즘입니다.

<br>
세 점 A, B, C가 주어졌을 때:

- **양수**: 반시계 방향 (왼쪽으로 꺾임)
- **음수**: 시계 방향 (오른쪽으로 꺾임)
- **0**: 일직선

<br>

### CCW 공식

벡터 AB와 벡터 AC의 외적으로 계산합니다.

```
CCW = (B - A) × (C - A)
    = (x₂ - x₁)(y₃ - y₁) - (y₂ - y₁)(x₃ - x₁)
```

<br>

### CCW 구현

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

struct Point {
    ll x, y;
};

ll ccw(Point a, Point b, Point c) {
    ll result = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
    if (result > 0) return 1;   // 반시계
    if (result < 0) return -1;  // 시계
    return 0;                    // 일직선
}
```

<br>

### CCW 예시

```
    C(1, 3)
    ↑
    |
A(0, 0) → B(2, 1)

CCW(A, B, C) = (2-0)(3-0) - (1-0)(1-0)
             = 6 - 1 = 5 > 0 → 반시계 방향
```

<br>

---

<br>

## 선분 교차 판정

두 선분이 교차하는지 CCW를 이용해 판별합니다.

<br>

### 아이디어

선분 AB와 선분 CD가 교차하려면:

1. A와 B가 선분 CD의 **양쪽**에 있어야 합니다.
2. C와 D가 선분 AB의 **양쪽**에 있어야 합니다.

<br>
`CCW(C, D, A) × CCW(C, D, B) < 0` 이고

`CCW(A, B, C) × CCW(A, B, D) < 0` 이면 교차합니다.

<br>

### 일직선 위의 경우

CCW 값이 0인 경우, 점이 선분 위에 있는지 추가 확인이 필요합니다.

<br>

### 구현

```cpp
bool onSegment(Point p, Point a, Point b) {
    return min(a.x, b.x) <= p.x && p.x <= max(a.x, b.x) &&
           min(a.y, b.y) <= p.y && p.y <= max(a.y, b.y);
}

bool intersect(Point a, Point b, Point c, Point d) {
    ll d1 = ccw(c, d, a);
    ll d2 = ccw(c, d, b);
    ll d3 = ccw(a, b, c);
    ll d4 = ccw(a, b, d);

    if (d1 * d2 < 0 && d3 * d4 < 0)
        return true;

    // 한 점이 다른 선분 위에 있는 경우
    if (d1 == 0 && onSegment(a, c, d)) return true;
    if (d2 == 0 && onSegment(b, c, d)) return true;
    if (d3 == 0 && onSegment(c, a, b)) return true;
    if (d4 == 0 && onSegment(d, a, b)) return true;

    return false;
}
```

<br>

---

<br>

## 다각형의 넓이

### 신발끈 공식 (Shoelace Formula)

n개의 꼭짓점으로 이루어진 다각형의 넓이:

```
넓이 = |Σ(xᵢyᵢ₊₁ - xᵢ₊₁yᵢ)| / 2
```

<br>
꼭짓점을 순서대로 나열하고, 인접한 점들의 외적을 모두 더합니다.

<br>

### 구현

```cpp
double polygonArea(vector<Point>& p) {
    int n = p.size();
    ll sum = 0;

    for (int i = 0; i < n; i++) {
        int j = (i + 1) % n;
        sum += p[i].x * p[j].y;
        sum -= p[j].x * p[i].y;
    }

    return abs(sum) / 2.0;
}
```

<br>

### 예시

삼각형 (0, 0), (4, 0), (2, 3):

```
sum = (0×0 - 4×0) + (4×3 - 2×0) + (2×0 - 0×3)
    = 0 + 12 + 0 = 12

넓이 = |12| / 2 = 6
```

<br>

---

<br>

## 점과 다각형의 포함 관계

점이 다각형 내부에 있는지 판별합니다.

<br>

### Ray Casting Algorithm

점에서 수평으로 반직선을 그어, 다각형의 변과 몇 번 교차하는지 셉니다.

<br>
교차 횟수가 **홀수**면 내부, **짝수**면 외부입니다.

<br>

```cpp
bool isInside(Point p, vector<Point>& polygon) {
    int n = polygon.size();
    int count = 0;

    for (int i = 0; i < n; i++) {
        Point a = polygon[i];
        Point b = polygon[(i + 1) % n];

        if ((a.y > p.y) != (b.y > p.y)) {
            double x = (double)(b.x - a.x) * (p.y - a.y) / (b.y - a.y) + a.x;
            if (p.x < x) count++;
        }
    }

    return count % 2 == 1;
}
```

<br>

---

<br>

## 두 점 사이의 거리

### 유클리드 거리

```cpp
double dist(Point a, Point b) {
    double dx = a.x - b.x;
    double dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
}
```

<br>

### 거리의 제곱 (정수 연산용)

```cpp
ll distSquared(Point a, Point b) {
    ll dx = a.x - b.x;
    ll dy = a.y - b.y;
    return dx * dx + dy * dy;
}
```

<br>
실수 오차를 피하려면 제곱 상태로 비교하는 것이 좋습니다.

<br>

---

<br>

## 주의사항: 실수 오차

기하 문제에서는 **실수 오차**에 주의해야 합니다.

<br>

**1. 정수로 계산 가능하면 정수 사용**

CCW, 거리 제곱 비교 등은 정수로 처리합니다.

<br>

**2. 오차 허용 범위 설정**

```cpp
const double EPS = 1e-9;
bool equal(double a, double b) {
    return abs(a - b) < EPS;
}
```

<br>

**3. long long 사용**

좌표 범위가 크면 곱셈 시 오버플로우가 발생할 수 있습니다.

<br>

---

<br>

## 관련 문제 유형

기하학 알고리즘은 다음과 같은 문제에서 활용됩니다:

- 선분 교차 판정
- 볼록 껍질 (Convex Hull)
- 가장 가까운 두 점 (Closest Pair)
- 다각형 넓이 계산
- 점의 내부/외부 판정
- 반직선과 선분의 교차

<br>

