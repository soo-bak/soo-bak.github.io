---
layout: single
title: "LIS - 최장 증가 부분 수열 - soo:bak"
date: "2025-12-27 01:50:00 +0900"
description: 최장 증가 부분 수열(LIS)의 개념과 O(n²) DP 풀이, O(n log n) 이분탐색 최적화까지 단계별로 설명합니다.
---

## LIS란?

**LIS(Longest Increasing Subsequence)** 는 주어진 수열에서 **순서를 유지하면서** 원소를 선택했을 때, **오름차순으로 증가하는 가장 긴 부분 수열**을 의미합니다.

<br>
부분 수열은 연속하지 않아도 됩니다.

원래 수열에서 일부 원소를 선택하되, 상대적인 순서만 유지하면 됩니다.

<br>

### 예시

수열: `[10, 20, 10, 30, 20, 50]`

<br>
가능한 증가 부분 수열:
- `[10]` → 길이 1
- `[10, 20]` → 길이 2
- `[10, 20, 30]` → 길이 3
- `[10, 20, 30, 50]` → 길이 4 ✓ (LIS)
- `[10, 20, 50]` → 길이 3

<br>
**LIS의 길이는 4**이고, 그 수열은 `[10, 20, 30, 50]`입니다.

<br>

---

<br>

## O(n²) DP 풀이

### 아이디어

`dp[i]` = i번째 원소를 마지막으로 하는 LIS의 길이

<br>
각 위치 `i`에서, 자신보다 앞에 있고 값이 작은 원소 `j`를 찾아

`dp[i] = max(dp[j]) + 1`로 갱신합니다.

<br>

### 점화식

```
dp[i] = max(dp[j] + 1)  (단, j < i 이고 arr[j] < arr[i])
```

<br>
모든 `dp[i]`의 초깃값은 1입니다. (자기 자신만으로 길이 1의 LIS)

<br>

### 동작 과정

수열: `[10, 20, 10, 30, 20, 50]`

```
i=0: dp[0] = 1                    → [1]
i=1: arr[0]=10 < arr[1]=20
     dp[1] = dp[0]+1 = 2          → [1, 2]
i=2: arr[2]=10, 앞에 작은 값 없음
     dp[2] = 1                    → [1, 2, 1]
i=3: arr[0]=10 < 30, arr[1]=20 < 30, arr[2]=10 < 30
     dp[3] = max(1,2,1)+1 = 3     → [1, 2, 1, 3]
i=4: arr[0]=10 < 20, arr[2]=10 < 20
     dp[4] = max(1,1)+1 = 2       → [1, 2, 1, 3, 2]
i=5: arr[0~4] 중 50보다 작은 값 모두 확인
     dp[5] = max(1,2,1,3,2)+1 = 4 → [1, 2, 1, 3, 2, 4]
```

<br>
**LIS 길이 = max(dp) = 4**

<br>

### 구현 (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

int lis_dp(vector<int>& arr) {
    int n = arr.size();
    vector<int> dp(n, 1);

    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (arr[j] < arr[i])
                dp[i] = max(dp[i], dp[j] + 1);
        }
    }

    return *max_element(dp.begin(), dp.end());
}
```

<br>
시간 복잡도: **O(n²)**

공간 복잡도: **O(n)**

<br>

---

<br>

## O(n log n) 이분탐색 풀이

### 아이디어

LIS의 **길이만** 필요한 경우, 더 효율적인 방법이 있습니다.

<br>
길이가 `k`인 증가 수열의 **마지막 원소 중 최솟값**을 배열에 저장합니다.

이 배열은 항상 **정렬된 상태**를 유지합니다.

<br>
새 원소가 들어오면:
- 배열의 마지막보다 크면 → 배열 끝에 추가 (LIS 길이 증가)
- 그렇지 않으면 → 이분탐색으로 적절한 위치를 찾아 교체

<br>

### 동작 과정

수열: `[10, 20, 10, 30, 20, 50]`

```
arr[0]=10: lis = [10]
arr[1]=20: 20 > 10, lis = [10, 20]
arr[2]=10: 10 위치 찾기 → lis = [10, 20] (10은 이미 있음)
arr[3]=30: 30 > 20, lis = [10, 20, 30]
arr[4]=20: 20 위치 찾기 → lis = [10, 20, 30] (20은 이미 있음)
arr[5]=50: 50 > 30, lis = [10, 20, 30, 50]
```

<br>
**LIS 길이 = 4**

<br>

### 구현 (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

int lis_binary(vector<int>& arr) {
    vector<int> lis;

    for (int x : arr) {
        auto pos = lower_bound(lis.begin(), lis.end(), x);
        if (pos == lis.end())
            lis.push_back(x);
        else
            *pos = x;
    }

    return lis.size();
}
```

<br>
시간 복잡도: **O(n log n)**

공간 복잡도: **O(n)**

<br>

---

<br>

## LIS 복원하기

길이뿐 아니라 실제 LIS 수열을 구해야 할 때가 있습니다.

<br>
각 원소가 LIS에서 몇 번째 위치인지 저장하고, 역추적합니다.

<br>

### 구현 (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> lis_with_reconstruction(vector<int>& arr) {
    int n = arr.size();
    vector<int> lis, pos(n), parent(n, -1);

    for (int i = 0; i < n; i++) {
        auto it = lower_bound(lis.begin(), lis.end(), arr[i]);
        pos[i] = it - lis.begin();

        if (it == lis.end())
            lis.push_back(arr[i]);
        else
            *it = arr[i];

        if (pos[i] > 0) {
            // 이전 위치 찾기 (역추적용)
            for (int j = i - 1; j >= 0; j--) {
                if (pos[j] == pos[i] - 1 && arr[j] < arr[i]) {
                    parent[i] = j;
                    break;
                }
            }
        }
    }

    // 역추적으로 LIS 복원
    vector<int> result;
    int idx = max_element(pos.begin(), pos.end()) - pos.begin();
    while (idx != -1) {
        result.push_back(arr[idx]);
        idx = parent[idx];
    }
    reverse(result.begin(), result.end());

    return result;
}
```

<br>

---

<br>

## LIS 변형 문제

### 최장 비감소 부분 수열

`<` 대신 `<=`를 사용하면 같은 값도 포함할 수 있습니다.

```cpp
auto pos = upper_bound(lis.begin(), lis.end(), x);  // upper_bound 사용
```

<br>

### 최장 감소 부분 수열 (LDS)

수열을 뒤집거나, 비교 조건을 반대로 합니다.

```cpp
auto pos = lower_bound(lis.begin(), lis.end(), x, greater<int>());
```

<br>

---

<br>

## 시간 복잡도 비교

| 방법 | 시간 복잡도 | 특징 |
|------|------------|------|
| O(n²) DP | O(n²) | 구현 간단, 역추적 용이 |
| 이분탐색 | O(n log n) | 효율적, 길이만 구할 때 적합 |

<br>
n이 작으면 (n ≤ 1000) DP로 충분합니다.

n이 크면 (n ≤ 100,000) 이분탐색이 필요합니다.

<br>

---

<br>

## 관련 문제 유형

LIS는 다음과 같은 문제에서 활용됩니다:

- 가장 긴 증가하는 부분 수열 찾기
- 최소 개수의 부분 수열로 분할 (딜워스 정리)
- 2차원 LIS (정렬 후 1차원 LIS)
- 전깃줄 최소화 문제
- 상자 쌓기 문제

<br>

