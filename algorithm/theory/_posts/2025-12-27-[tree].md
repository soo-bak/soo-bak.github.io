---
layout: single
title: "트리 자료구조 - 계층 구조의 표현 - soo:bak"
date: "2025-12-27 02:00:00 +0900"
description: 트리의 기본 개념과 용어, 이진 트리의 순회 방법, 트리의 구현과 활용을 단계별로 설명합니다.
---

## 트리란?

**트리(Tree)** 는 계층적 구조를 표현하는 비선형 자료구조입니다.

<br>
하나의 루트 노드에서 시작하여 여러 자식 노드로 뻗어나가는 형태입니다.

사이클이 없는 연결 그래프로 정의할 수도 있습니다.

<br>
파일 시스템의 디렉토리 구조, 조직도, HTML DOM 등 실생활에서 자주 볼 수 있습니다.

<br>

---

<br>

## 트리 용어

```
        A          ← 루트(Root)
       / \
      B   C        ← A의 자식(Child)
     /|   |\
    D E   F G      ← 리프(Leaf): 자식이 없는 노드
```

<br>

### 기본 용어

**루트(Root)**: 트리의 최상위 노드. 부모가 없습니다.

**부모(Parent)**: 특정 노드의 바로 위 노드

**자식(Child)**: 특정 노드의 바로 아래 노드

**형제(Sibling)**: 같은 부모를 가진 노드들

**리프(Leaf)**: 자식이 없는 노드 (단말 노드)

**내부 노드**: 자식이 있는 노드 (리프가 아닌 노드)

<br>

### 구조 용어

**간선(Edge)**: 노드와 노드를 연결하는 선

**경로(Path)**: 한 노드에서 다른 노드까지 거치는 노드들의 순서

**깊이(Depth)**: 루트에서 특정 노드까지의 간선 수

**높이(Height)**: 특정 노드에서 가장 먼 리프까지의 간선 수

**레벨(Level)**: 같은 깊이에 있는 노드들의 집합

<br>

### 트리의 속성

- n개의 노드를 가진 트리는 항상 **n-1개의 간선**을 가집니다.
- 임의의 두 노드 사이에는 **유일한 경로**가 존재합니다.

<br>

---

<br>

## 이진 트리 (Binary Tree)

**이진 트리**는 각 노드가 최대 2개의 자식을 가지는 트리입니다.

<br>
왼쪽 자식(Left Child)과 오른쪽 자식(Right Child)으로 구분합니다.

<br>

### 이진 트리의 종류

**정 이진 트리 (Full Binary Tree)**

모든 노드가 0개 또는 2개의 자식을 가집니다.

```
      A
     / \
    B   C
   / \
  D   E
```

<br>

**완전 이진 트리 (Complete Binary Tree)**

마지막 레벨을 제외한 모든 레벨이 채워져 있고,

마지막 레벨은 왼쪽부터 채워집니다.

```
      A
     / \
    B   C
   / \  /
  D  E F
```

<br>

**포화 이진 트리 (Perfect Binary Tree)**

모든 레벨이 완전히 채워진 이진 트리입니다.

```
      A
     / \
    B   C
   /\   /\
  D  E F  G
```

<br>

---

<br>

## 이진 트리 순회 (Traversal)

트리의 모든 노드를 특정 순서로 방문하는 방법입니다.

<br>

### 전위 순회 (Preorder)

**루트 → 왼쪽 → 오른쪽** 순서로 방문합니다.

```cpp
void preorder(Node* node) {
    if (node == nullptr) return;
    cout << node->val << " ";  // 루트 방문
    preorder(node->left);       // 왼쪽 서브트리
    preorder(node->right);      // 오른쪽 서브트리
}
```

<br>

### 중위 순회 (Inorder)

**왼쪽 → 루트 → 오른쪽** 순서로 방문합니다.

이진 탐색 트리에서 오름차순 정렬 결과를 얻습니다.

```cpp
void inorder(Node* node) {
    if (node == nullptr) return;
    inorder(node->left);        // 왼쪽 서브트리
    cout << node->val << " ";  // 루트 방문
    inorder(node->right);       // 오른쪽 서브트리
}
```

<br>

### 후위 순회 (Postorder)

**왼쪽 → 오른쪽 → 루트** 순서로 방문합니다.

자식을 먼저 처리해야 할 때 사용합니다.

```cpp
void postorder(Node* node) {
    if (node == nullptr) return;
    postorder(node->left);      // 왼쪽 서브트리
    postorder(node->right);     // 오른쪽 서브트리
    cout << node->val << " ";  // 루트 방문
}
```

<br>

### 레벨 순회 (Level Order)

레벨별로 왼쪽에서 오른쪽으로 방문합니다. **BFS**를 사용합니다.

```cpp
void levelOrder(Node* root) {
    queue<Node*> q;
    q.push(root);

    while (!q.empty()) {
        Node* node = q.front();
        q.pop();
        cout << node->val << " ";

        if (node->left) q.push(node->left);
        if (node->right) q.push(node->right);
    }
}
```

<br>

### 순회 예시

```
      1
     / \
    2   3
   / \
  4   5
```

| 순회 방식 | 방문 순서 |
|----------|----------|
| 전위 | 1 → 2 → 4 → 5 → 3 |
| 중위 | 4 → 2 → 5 → 1 → 3 |
| 후위 | 4 → 5 → 2 → 3 → 1 |
| 레벨 | 1 → 2 → 3 → 4 → 5 |

<br>

---

<br>

## 트리 구현

### 포인터 기반 구현

```cpp
struct Node {
    int val;
    Node* left;
    Node* right;

    Node(int v) : val(v), left(nullptr), right(nullptr) {}
};

// 트리 생성 예시
Node* root = new Node(1);
root->left = new Node(2);
root->right = new Node(3);
root->left->left = new Node(4);
root->left->right = new Node(5);
```

<br>

### 배열 기반 구현 (완전 이진 트리)

인덱스 규칙:
- 루트: 인덱스 1
- 노드 i의 왼쪽 자식: 2*i
- 노드 i의 오른쪽 자식: 2*i + 1
- 노드 i의 부모: i / 2

```cpp
int tree[100];  // 인덱스 1부터 사용
tree[1] = 1;    // 루트
tree[2] = 2;    // 왼쪽 자식
tree[3] = 3;    // 오른쪽 자식
```

<br>

### 인접 리스트 구현 (일반 트리)

```cpp
vector<int> children[100];  // children[i]: 노드 i의 자식들

void addChild(int parent, int child) {
    children[parent].push_back(child);
}
```

<br>

---

<br>

## 트리의 활용

### 이진 탐색 트리 (BST)

왼쪽 서브트리 < 루트 < 오른쪽 서브트리 조건을 만족하는 트리입니다.

탐색, 삽입, 삭제가 평균 **O(log n)** 에 가능합니다.

<br>

### 힙 (Heap)

부모가 자식보다 크거나(최대 힙) 작은(최소 힙) 완전 이진 트리입니다.

우선순위 큐 구현에 사용됩니다.

<br>

### 트라이 (Trie)

문자열 집합을 저장하는 트리입니다.

문자열 검색이 **O(문자열 길이)** 에 가능합니다.

<br>

---

<br>

## 관련 문제 유형

트리는 다음과 같은 문제에서 활용됩니다:

- 트리 순회
- 트리의 높이/깊이 계산
- 두 노드의 최소 공통 조상 (LCA)
- 트리 DP
- 이진 탐색 트리 구현
- 트리의 지름 찾기

<br>

