---
layout: single
title: "배낭 문제(Knapsack Problem)의 원리와 구현 - soo:bak"
date: "2026-01-03 08:00:00 +0900"
description: 제한된 용량의 배낭에 최대 가치의 물건을 담는 배낭 문제의 유형, 동적 계획법 풀이, 공간 최적화를 다룹니다
---

## 배낭 문제란?

**배낭 문제(Knapsack Problem)**는 제한된 용량의 배낭에 **최대 가치**의 물건을 담는 최적화 문제입니다.

<br>

**문제 설정**:
- 배낭의 최대 용량: $$W$$
- 물건 $$i$$: 무게 $$w_i$$, 가치 $$v_i$$
- 목표: 배낭에 담을 수 있는 물건들의 가치 합 최대화

<br>

배낭 문제는 [동적 계획법(DP)](https://soo-bak.github.io/algorithm/theory/dynamic-programming/)의 대표적인 예시로, 다양한 변형이 존재합니다.

<br>

## 배낭 문제의 유형

<br>

### 1. 0-1 배낭 문제 (0-1 Knapsack)

각 물건을 **한 번만** 선택할 수 있습니다.

물건을 넣거나(1) 넣지 않거나(0) 두 가지 선택만 가능합니다.

<br>

### 2. 완전 배낭 문제 (Unbounded Knapsack)

각 물건을 **무한히** 선택할 수 있습니다.

같은 물건을 여러 번 넣을 수 있습니다.

<br>

### 3. 분할 가능 배낭 문제 (Fractional Knapsack)

물건을 **일부만** 담을 수 있습니다.

[그리디 알고리듬](https://soo-bak.github.io/algorithm/theory/greedyAlgo/)으로 해결할 수 있습니다.

<br>

## 0-1 배낭 문제

<br>

### 문제 정의

```
배낭 용량: W = 7
물건:
  물건 1: 무게 1, 가치 1
  물건 2: 무게 3, 가치 4
  물건 3: 무게 4, 가치 5
  물건 4: 무게 5, 가치 7
```

목표: 무게 합이 7 이하이면서 가치 합이 최대가 되도록 물건 선택

<br>

### 점화식

$$dp[i][w]$$를 "처음 $$i$$개 물건 중에서 무게 합이 $$w$$ 이하일 때의 최대 가치"로 정의합니다.

<br>

**점화식**:

$$
dp[i][w] = \max(dp[i-1][w], \; dp[i-1][w-w_i] + v_i)
$$

- $$dp[i-1][w]$$: $$i$$번째 물건을 **선택하지 않는** 경우
- $$dp[i-1][w-w_i] + v_i$$: $$i$$번째 물건을 **선택하는** 경우 (무게가 충분할 때만)

<br>

### 구현 (2차원 DP)

```cpp
#include <bits/stdc++.h>
using namespace std;

int knapsack01(int W, vector<int>& weights, vector<int>& values) {
  int n = weights.size();
  vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));

  for (int i = 1; i <= n; i++) {
    for (int w = 0; w <= W; w++) {
      // 현재 물건을 선택하지 않는 경우
      dp[i][w] = dp[i - 1][w];

      // 현재 물건을 선택하는 경우
      if (w >= weights[i - 1]) {
        dp[i][w] = max(dp[i][w],
                       dp[i - 1][w - weights[i - 1]] + values[i - 1]);
      }
    }
  }

  return dp[n][W];
}

int main() {
  int W = 7;
  vector<int> weights = {1, 3, 4, 5};
  vector<int> values = {1, 4, 5, 7};

  cout << "최대 가치: " << knapsack01(W, weights, values) << "\n";

  return 0;
}
```

**출력**: `최대 가치: 9` (물건 2와 3 선택: 4 + 5 = 9)

<br>

### 공간 최적화 (1차원 DP)

이전 행의 값만 필요하므로 1차원 배열로 최적화할 수 있습니다.

**핵심**: 역순으로 순회해야 같은 물건을 여러 번 사용하지 않습니다.

```cpp
int knapsack01Optimized(int W, vector<int>& weights, vector<int>& values) {
  int n = weights.size();
  vector<int> dp(W + 1, 0);

  for (int i = 0; i < n; i++) {
    // 역순으로 순회 (중요!)
    for (int w = W; w >= weights[i]; w--) {
      dp[w] = max(dp[w], dp[w - weights[i]] + values[i]);
    }
  }

  return dp[W];
}
```

**시간 복잡도**: $$O(n \cdot W)$$

**공간 복잡도**: $$O(W)$$

<br>

### 선택한 물건 추적

어떤 물건을 선택했는지 추적하려면 역추적이 필요합니다:

```cpp
vector<int> getSelectedItems(int W, vector<int>& weights, vector<int>& values) {
  int n = weights.size();
  vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));

  // DP 테이블 채우기
  for (int i = 1; i <= n; i++) {
    for (int w = 0; w <= W; w++) {
      dp[i][w] = dp[i - 1][w];
      if (w >= weights[i - 1]) {
        dp[i][w] = max(dp[i][w],
                       dp[i - 1][w - weights[i - 1]] + values[i - 1]);
      }
    }
  }

  // 역추적
  vector<int> selected;
  int w = W;
  for (int i = n; i > 0 && w > 0; i--) {
    if (dp[i][w] != dp[i - 1][w]) {
      selected.push_back(i - 1);  // 0-indexed
      w -= weights[i - 1];
    }
  }

  return selected;
}
```

<br>

## 완전 배낭 문제 (Unbounded Knapsack)

각 물건을 무한히 선택할 수 있는 경우입니다.

<br>

### 점화식

$$
dp[w] = \max(dp[w], \; dp[w-w_i] + v_i) \quad \text{for all } i
$$

<br>

### 구현

0-1 배낭과 달리 **정순**으로 순회합니다:

```cpp
int unboundedKnapsack(int W, vector<int>& weights, vector<int>& values) {
  int n = weights.size();
  vector<int> dp(W + 1, 0);

  for (int w = 0; w <= W; w++) {
    for (int i = 0; i < n; i++) {
      if (w >= weights[i]) {
        dp[w] = max(dp[w], dp[w - weights[i]] + values[i]);
      }
    }
  }

  return dp[W];
}
```

또는 물건 중심으로:

```cpp
int unboundedKnapsack2(int W, vector<int>& weights, vector<int>& values) {
  int n = weights.size();
  vector<int> dp(W + 1, 0);

  for (int i = 0; i < n; i++) {
    // 정순으로 순회 (같은 물건 여러 번 사용 가능)
    for (int w = weights[i]; w <= W; w++) {
      dp[w] = max(dp[w], dp[w - weights[i]] + values[i]);
    }
  }

  return dp[W];
}
```

<br>

## 0-1 vs 완전 배낭: 순회 방향

<br>

| 유형 | 순회 방향 | 이유 |
|------|----------|------|
| 0-1 배낭 | 역순 (W→0) | 같은 물건 중복 사용 방지 |
| 완전 배낭 | 정순 (0→W) | 같은 물건 여러 번 사용 허용 |

<br>

**0-1 배낭에서 역순 필요 이유**:

정순으로 순회하면 $$dp[w - w_i]$$가 이미 현재 물건을 포함한 값일 수 있어, 같은 물건을 여러 번 사용하게 됩니다.

<br>

## 분할 가능 배낭 (Fractional Knapsack)

물건을 일부만 담을 수 있는 경우, [그리디 알고리듬](https://soo-bak.github.io/algorithm/theory/greedyAlgo/)으로 해결합니다.

<br>

### 접근법

1. 물건을 **가치/무게 비율** 기준으로 정렬
2. 비율이 높은 물건부터 담기
3. 배낭이 가득 차면 남은 공간만큼만 물건의 일부를 담기

<br>

### 구현

```cpp
double fractionalKnapsack(int W, vector<int>& weights, vector<int>& values) {
  int n = weights.size();
  vector<pair<double, int>> ratio(n);  // {비율, 인덱스}

  for (int i = 0; i < n; i++) {
    ratio[i] = {(double)values[i] / weights[i], i};
  }

  // 비율 내림차순 정렬
  sort(ratio.begin(), ratio.end(), greater<pair<double, int>>());

  double totalValue = 0.0;
  int remainingW = W;

  for (auto [r, i] : ratio) {
    if (remainingW >= weights[i]) {
      // 전체 담기
      totalValue += values[i];
      remainingW -= weights[i];
    } else {
      // 일부만 담기
      totalValue += r * remainingW;
      break;
    }
  }

  return totalValue;
}
```

**시간 복잡도**: $$O(n \log n)$$ (정렬)

<br>

## 시간/공간 복잡도 요약

<br>

| 유형 | 시간 복잡도 | 공간 복잡도 |
|------|------------|------------|
| 0-1 배낭 (2D) | $$O(n \cdot W)$$ | $$O(n \cdot W)$$ |
| 0-1 배낭 (1D) | $$O(n \cdot W)$$ | $$O(W)$$ |
| 완전 배낭 | $$O(n \cdot W)$$ | $$O(W)$$ |
| 분할 가능 | $$O(n \log n)$$ | $$O(n)$$ |

<br>

## 실전 예제: 보석 도둑

<br>

**문제**: 도둑이 배낭에 보석을 담으려 합니다. 배낭 용량이 주어질 때 담을 수 있는 보석의 최대 가치를 구하세요.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  int n, W;  // 보석 수, 배낭 용량
  cin >> n >> W;

  vector<int> weights(n), values(n);
  for (int i = 0; i < n; i++) {
    cin >> weights[i] >> values[i];
  }

  vector<int> dp(W + 1, 0);

  for (int i = 0; i < n; i++) {
    for (int w = W; w >= weights[i]; w--) {
      dp[w] = max(dp[w], dp[w - weights[i]] + values[i]);
    }
  }

  cout << dp[W] << "\n";

  return 0;
}
```

<br>

## 배낭 문제의 변형

<br>

**1. 부분집합 합 (Subset Sum)**

특정 합을 만들 수 있는지 판별

<br>

**2. 동전 교환 (Coin Change)**

목표 금액을 만드는 최소 동전 수

<br>

**3. 목표 합 (Target Sum)**

+/- 연산으로 목표 합을 만드는 경우의 수

<br>

**4. 2차원 배낭**

무게와 부피 두 가지 제약이 있는 경우

<br>

## 마무리

배낭 문제는 동적 계획법의 핵심 예제로, 다양한 최적화 문제에 응용됩니다.

<br>

**핵심 포인트**
- **0-1 배낭**: 역순 순회, 각 물건 한 번만 사용
- **완전 배낭**: 정순 순회, 물건 무한 사용 가능
- **분할 가능**: 그리디로 해결
- **시간 복잡도**: $$O(n \cdot W)$$ (의사 다항 시간)

<br>

배낭 문제는 자원 할당, 예산 배분, 포트폴리오 최적화 등 실생활의 다양한 문제에 적용됩니다.

<br>

### 관련 글
- [동적 계획법(Dynamic Programming)의 원리와 구현 - soo:bak](https://soo-bak.github.io/algorithm/theory/dynamic-programming/)
- [그리디 알고리듬(Greedy Algorithm)의 원리와 적용 - soo:bak](https://soo-bak.github.io/algorithm/theory/greedyAlgo/)

<br>

### 관련 문제
- [[백준 12865] 평범한 배낭](https://www.acmicpc.net/problem/12865)
- [[백준 1535] 안녕](https://www.acmicpc.net/problem/1535)
- [[백준 7579] 앱](https://www.acmicpc.net/problem/7579)

