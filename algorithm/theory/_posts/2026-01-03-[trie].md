---
layout: single
title: "트라이(Trie)의 원리와 구현 - soo:bak"
date: "2026-01-03 12:00:00 +0900"
description: 문자열을 효율적으로 저장하고 검색하는 트라이 자료구조의 원리, 구현 방법, 활용 예시를 다룹니다
---

## 트라이란?

**트라이(Trie)**는 문자열 집합을 저장하고 검색하는 트리 기반 자료구조입니다.

**Prefix Tree** 또는 **Retrieval Tree**라고도 합니다.

<br>

**특징**:
- 문자열 검색: $$O(m)$$ ($$m$$: 문자열 길이)
- 공통 접두사를 공유하여 메모리 효율적
- 자동 완성, 사전 구현에 적합

<br>

## 트라이의 구조

<br>

문자열 `["cat", "car", "card", "dog"]`를 저장한 트라이:

```
        root
       /    \
      c      d
      |      |
      a      o
     / \     |
    t   r    g*
    *   |
        d*
```

`*`는 단어의 끝(종료 표시)을 나타냅니다.

<br>

**핵심 아이디어**:
- 각 노드는 하나의 문자를 나타냄
- 루트에서 노드까지의 경로가 접두사
- 종료 표시가 있는 노드까지의 경로가 완전한 단어

<br>

## 트라이의 구현

<br>

### 기본 구현

```cpp
#include <bits/stdc++.h>
using namespace std;

class Trie {
private:
  struct Node {
    unordered_map<char, Node*> children;
    bool isEnd = false;
  };

  Node* root;

public:
  Trie() {
    root = new Node();
  }

  // 단어 삽입 - O(m)
  void insert(const string& word) {
    Node* cur = root;
    for (char c : word) {
      if (!cur->children.count(c)) {
        cur->children[c] = new Node();
      }
      cur = cur->children[c];
    }
    cur->isEnd = true;
  }

  // 단어 검색 - O(m)
  bool search(const string& word) {
    Node* cur = root;
    for (char c : word) {
      if (!cur->children.count(c)) {
        return false;
      }
      cur = cur->children[c];
    }
    return cur->isEnd;
  }

  // 접두사 검색 - O(m)
  bool startsWith(const string& prefix) {
    Node* cur = root;
    for (char c : prefix) {
      if (!cur->children.count(c)) {
        return false;
      }
      cur = cur->children[c];
    }
    return true;
  }
};

int main() {
  Trie trie;

  trie.insert("apple");
  trie.insert("app");
  trie.insert("application");

  cout << trie.search("app") << "\n";       // 1 (true)
  cout << trie.search("apple") << "\n";     // 1 (true)
  cout << trie.search("appl") << "\n";      // 0 (false)
  cout << trie.startsWith("app") << "\n";   // 1 (true)
  cout << trie.startsWith("apy") << "\n";   // 0 (false)

  return 0;
}
```

<br>

### 배열 기반 구현 (고정 알파벳)

소문자만 사용하는 경우 더 빠른 구현:

```cpp
class TrieArray {
private:
  struct Node {
    Node* children[26] = {nullptr};
    bool isEnd = false;
  };

  Node* root;

  int charToIdx(char c) { return c - 'a'; }

public:
  TrieArray() { root = new Node(); }

  void insert(const string& word) {
    Node* cur = root;
    for (char c : word) {
      int idx = charToIdx(c);
      if (!cur->children[idx]) {
        cur->children[idx] = new Node();
      }
      cur = cur->children[idx];
    }
    cur->isEnd = true;
  }

  bool search(const string& word) {
    Node* cur = root;
    for (char c : word) {
      int idx = charToIdx(c);
      if (!cur->children[idx]) return false;
      cur = cur->children[idx];
    }
    return cur->isEnd;
  }
};
```

<br>

## 시간 복잡도

<br>

| 연산 | 시간 복잡도 | 설명 |
|------|------------|------|
| 삽입 | $$O(m)$$ | 문자열 길이 |
| 검색 | $$O(m)$$ | 문자열 길이 |
| 접두사 검색 | $$O(m)$$ | 접두사 길이 |
| 삭제 | $$O(m)$$ | 문자열 길이 |

<br>

**공간 복잡도**: $$O(n \cdot m \cdot k)$$
- $$n$$: 단어 수
- $$m$$: 평균 단어 길이
- $$k$$: 알파벳 크기 (최악)

실제로는 공통 접두사 공유로 훨씬 적은 메모리 사용

<br>

## 트라이 vs 해시 테이블

<br>

| 특성 | 트라이 | 해시 테이블 |
|------|--------|------------|
| 검색 | $$O(m)$$ | $$O(m)$$ 평균 |
| 접두사 검색 | $$O(m)$$ | $$O(n \cdot m)$$ |
| 정렬된 순회 | 가능 | 불가능 |
| 메모리 | 접두사 공유 | 각 키 독립 |
| 충돌 | 없음 | 가능 |

<br>

**트라이를 선택해야 할 때**:
- 접두사 기반 검색이 필요한 경우
- 자동 완성 기능 구현
- 사전순 정렬이 필요한 경우

<br>

## 활용 예시

<br>

### 1. 자동 완성

```cpp
vector<string> autocomplete(const string& prefix) {
  vector<string> result;
  Node* cur = root;

  // 접두사까지 이동
  for (char c : prefix) {
    if (!cur->children.count(c)) return result;
    cur = cur->children[c];
  }

  // DFS로 모든 단어 수집
  function<void(Node*, string)> dfs = [&](Node* node, string word) {
    if (node->isEnd) result.push_back(word);
    for (auto& [c, child] : node->children) {
      dfs(child, word + c);
    }
  };

  dfs(cur, prefix);
  return result;
}
```

<br>

### 2. 단어 개수 세기

```cpp
class TrieWithCount {
  struct Node {
    unordered_map<char, Node*> children;
    int count = 0;  // 이 접두사를 가진 단어 수
    bool isEnd = false;
  };

  void insert(const string& word) {
    Node* cur = root;
    for (char c : word) {
      if (!cur->children.count(c)) {
        cur->children[c] = new Node();
      }
      cur = cur->children[c];
      cur->count++;
    }
    cur->isEnd = true;
  }

  int countWordsWithPrefix(const string& prefix) {
    Node* cur = root;
    for (char c : prefix) {
      if (!cur->children.count(c)) return 0;
      cur = cur->children[c];
    }
    return cur->count;
  }
};
```

<br>

### 3. 최장 공통 접두사

```cpp
string longestCommonPrefix(vector<string>& words) {
  if (words.empty()) return "";

  Trie trie;
  for (const string& w : words) {
    trie.insert(w);
  }

  string lcp;
  Node* cur = root;

  while (cur->children.size() == 1 && !cur->isEnd) {
    auto it = cur->children.begin();
    lcp += it->first;
    cur = it->second;
  }

  return lcp;
}
```

<br>

## 마무리

트라이는 문자열 집합을 효율적으로 저장하고 검색하는 자료구조입니다.

<br>

**핵심 포인트**
- **구조**: 각 노드가 문자를 나타내는 트리
- **검색**: 문자열 길이에 비례 $$O(m)$$
- **장점**: 접두사 검색, 자동 완성에 최적
- **단점**: 메모리 사용량 (해시 테이블 대비)

<br>

### 관련 글
- [해시 테이블(Hash Table)의 원리와 구현 - soo:bak](https://soo-bak.github.io/algorithm/theory/hash-table/)

<br>

### 관련 문제
- [[백준 5052] 전화번호 목록](https://www.acmicpc.net/problem/5052)
- [[백준 14425] 문자열 집합](https://www.acmicpc.net/problem/14425)

