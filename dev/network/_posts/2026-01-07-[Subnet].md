---
layout: single
title: "서브넷(Subnet)의 개념과 서브네팅 - soo:bak"
date: "2026-01-07 22:00:00 +0900"
description: 서브넷의 개념과 필요성, 서브넷 마스크와 CIDR 표기법, 서브넷 계산 방법을 설명합니다.
tags:
  - 네트워크
  - Subnet
  - IP
  - CIDR
---

## 서브넷이란?

**서브넷(Subnet, Subnetwork의 줄임말)**은 하나의 큰 네트워크를 더 작은 논리적인 네트워크 단위로 분할한 것입니다.

하나의 IP 네트워크를 여러 개의 작은 네트워크로 나누는 것을 **서브네팅(Subnetting)**이라 하고, 이렇게 나누어진 각각의 작은 네트워크를 **서브넷(Subnet)**이라고 합니다.

<br>

같은 서브넷에 속한 장치들은 라우터 없이 직접 통신할 수 있지만, 서로 다른 서브넷에 있는 장치들은 반드시 라우터(게이트웨이)를 통해야만 통신할 수 있습니다.

---

## 서브넷이 등장한 배경

서브넷을 이해하려면 먼저 초기 인터넷의 IP 주소 체계가 어떤 문제를 가지고 있었는지 알아야 합니다.

<br>

### 클래스풀(Classful) 주소 체계

1980년대 초기 인터넷에서는 IP 주소를 **클래스(Class)**라는 고정된 단위로 할당했습니다.

| 클래스 | 첫 옥텟 범위 | 네트워크 비트 | 호스트 비트 | 네트워크당 호스트 수 |
|--------|-------------|--------------|------------|-------------------|
| A | 1 ~ 126 | 8비트 | 24비트 | 16,777,214개 |
| B | 128 ~ 191 | 16비트 | 16비트 | 65,534개 |
| C | 192 ~ 223 | 24비트 | 8비트 | 254개 |

이 체계에서는 네트워크 크기가 오직 3가지뿐이었습니다.

<br>

### 클래스풀 체계의 문제점

**문제 1: IP 주소의 심각한 낭비**

500대의 컴퓨터를 연결해야 하는 회사가 있다고 가정합니다.

- Class C(254개)는 부족합니다.
- Class B(65,534개)를 할당받아야 합니다.
- 결과: 65,034개의 IP 주소가 낭비됩니다.

```
필요한 호스트: 500개
할당받은 Class B: 65,534개
낭비되는 IP: 65,034개 (약 99% 낭비)
```

<br>

**문제 2: IP 주소 고갈**

IPv4 주소는 총 약 43억 개입니다. Class A 네트워크 하나가 1,600만 개의 IP를 차지하므로, 소수의 대형 기관이 Class A를 할당받으면 전체 IP 주소가 빠르게 고갈됩니다.

1990년대에 이르러 이 문제가 심각해졌고, 해결책이 필요했습니다.

<br>

**문제 3: 유연성 부족**

조직 내부에서 부서별로 네트워크를 분리하고 싶어도, 클래스풀 체계에서는 별도의 클래스 주소를 추가로 할당받아야 했습니다.

```
회사가 Class B (172.16.0.0) 를 할당받음
└── 전체 65,534개 호스트가 하나의 네트워크에 존재
└── 개발팀, 영업팀, 재무팀을 분리할 방법이 없음
└── 모든 브로드캐스트가 65,534대에 전달됨
```

<br>

### 해결책: 서브네팅과 CIDR

이 문제들을 해결하기 위해 **서브네팅(Subnetting)**과 **CIDR(Classless Inter-Domain Routing)**이 도입되었습니다.

핵심 아이디어는 다음과 같습니다.

- 클래스의 고정된 경계를 없앤다.
- 네트워크 부분과 호스트 부분의 경계를 자유롭게 설정한다.
- 필요한 만큼만 IP 주소를 할당한다.

```
클래스풀: Class B = 무조건 65,534개 호스트
클래스리스: /22 = 1,022개, /23 = 510개, /24 = 254개 등 자유롭게 선택
```

<br>

예를 들어, 500대의 호스트가 필요한 회사는 이제 `/23` (510개 호스트)을 할당받을 수 있습니다.

```
클래스풀 시대: Class B 할당 → 65,034개 낭비
클래스리스 시대: /23 할당 → 10개 낭비
```

---

## 왜 서브넷이 필요한가?

서브넷은 IP 주소 고갈 문제를 해결하는 것 외에도 실질적인 네트워크 운영에서 다음과 같은 이점을 제공합니다.

<br>

### 1. 효율적인 IP 주소 관리

하나의 큰 네트워크를 필요에 맞게 분할하여 IP 주소 낭비를 최소화합니다.

**예시: 회사에 Class B (172.16.0.0/16, 65,534개) 가 할당된 경우**

| 부서 | 필요 호스트 | 클래스풀 방식 | 서브넷 방식 |
|------|-----------|--------------|------------|
| 개발팀 | 100대 | Class C 1개 필요 | /25 (126개) 할당 |
| 영업팀 | 50대 | Class C 1개 필요 | /26 (62개) 할당 |
| 재무팀 | 20대 | Class C 1개 필요 | /27 (30개) 할당 |
| 서버실 | 10대 | Class C 1개 필요 | /28 (14개) 할당 |

서브넷을 사용하면 하나의 Class B 주소 블록 안에서 부서별로 적절한 크기의 네트워크를 만들 수 있습니다.

<br>

### 2. 브로드캐스트 도메인 축소

**브로드캐스트**는 네트워크의 모든 장치에 데이터를 전송하는 것입니다. ARP 요청, DHCP 요청 등 많은 네트워크 프로토콜이 브로드캐스트를 사용합니다.

브로드캐스트는 같은 서브넷(브로드캐스트 도메인) 내에서만 전파되고, 라우터를 넘어가지 않습니다.

**서브넷이 없는 경우:**

```
하나의 네트워크에 1000대의 장치
└── 장치 A가 브로드캐스트 전송
└── 1000대 모두가 이 패킷을 수신하고 처리해야 함
└── 네트워크 대역폭 소모 + 모든 장치의 CPU 사용
```

**서브넷으로 분할한 경우:**

```
10개의 서브넷, 각 100대의 장치
└── 장치 A가 브로드캐스트 전송
└── 같은 서브넷의 100대만 이 패킷을 수신
└── 나머지 900대는 영향 없음
```

장치 수가 많아질수록 브로드캐스트 트래픽이 네트워크 성능에 미치는 영향이 커지므로, 서브넷 분할은 필수적입니다.

<br>

### 3. 보안 강화

서로 다른 서브넷 간의 통신은 반드시 라우터를 거쳐야 합니다. 라우터에서 **접근 제어 목록(ACL)**이나 **방화벽 규칙**을 적용하여 트래픽을 제어할 수 있습니다.

**예시: 부서별 접근 제어**

```
재무팀 서브넷: 192.168.1.0/24
개발팀 서브넷: 192.168.2.0/24
서버 서브넷:   192.168.10.0/24

라우터 ACL 규칙:
- 재무팀 → 서버: 허용 (재무 시스템 접근)
- 개발팀 → 서버: 허용 (개발 서버 접근)
- 개발팀 → 재무팀: 차단 (민감 정보 보호)
```

같은 서브넷 내에서는 장치들이 직접 통신하므로 이런 제어가 불가능합니다. 서브넷 분할을 통해 보안 경계를 만들 수 있습니다.

<br>

### 4. 장애 격리

네트워크 문제가 발생했을 때 해당 서브넷 내로 영향을 제한할 수 있습니다.

**브로드캐스트 폭풍(Broadcast Storm)**: 네트워크 장비 오류나 루프로 인해 브로드캐스트 패킷이 무한히 증폭되는 현상입니다.

```
서브넷이 없는 경우:
└── 한 곳에서 브로드캐스트 폭풍 발생
└── 전체 네트워크가 마비

서브넷으로 분할된 경우:
└── 한 서브넷에서 브로드캐스트 폭풍 발생
└── 해당 서브넷만 영향, 다른 서브넷은 정상 동작
```

<br>

### 5. 네트워크 관리 효율화

논리적으로 분리된 네트워크는 관리가 쉽습니다.

- **문제 추적**: 어떤 서브넷에서 문제가 발생했는지 빠르게 파악
- **정책 적용**: 서브넷별로 다른 DHCP 설정, DNS 서버, 게이트웨이 지정
- **확장성**: 새로운 부서 추가 시 새 서브넷만 생성하면 됨

```
IP 주소만 보고 장치의 위치/용도 파악 가능:
192.168.1.x  → 1층 사무실
192.168.2.x  → 2층 사무실
192.168.10.x → 서버실
192.168.100.x → 게스트 Wi-Fi
```

---

## IP 주소의 구조

서브넷을 이해하기 위해서는 먼저 IP 주소의 구조를 알아야 합니다.

<br>

### IPv4 주소의 기본 구조

`IPv4` 주소는 `32비트`로 구성되어 있으며, 일반적으로 `4개의 옥텟(Octet)`으로 표현됩니다.

각 옥텟은 8비트이며, 0부터 255까지의 값을 가질 수 있습니다.

```
192     .  168     .  1       .  100
11000000   10101000   00000001   01100100
   8비트  +   8비트  +   8비트  +   8비트  = 32비트
```

<br>

이 32비트는 크게 두 부분으로 나뉩니다.

| 구분 | 설명 | 비유 |
|------|------|------|
| **네트워크 부분** | 해당 장치가 속한 네트워크를 식별 | 도로명 (어느 동네인지) |
| **호스트 부분** | 해당 네트워크 내에서 특정 장치를 식별 | 건물 번호 (동네 내 어느 집인지) |

<br>

### 사설 IP 주소 대역

인터넷에서 직접 사용할 수 없고 내부 네트워크에서만 사용하는 IP 주소 대역이 있습니다.

| 클래스 | 사설 IP 대역 | CIDR | 호스트 수 |
|--------|-------------|------|----------|
| A | 10.0.0.0 ~ 10.255.255.255 | 10.0.0.0/8 | 약 1,677만 개 |
| B | 172.16.0.0 ~ 172.31.255.255 | 172.16.0.0/12 | 약 104만 개 |
| C | 192.168.0.0 ~ 192.168.255.255 | 192.168.0.0/16 | 약 6만 5천 개 |

가정이나 회사 내부 네트워크에서 흔히 볼 수 있는 `192.168.x.x` 주소가 바로 사설 IP입니다.

---

## 서브넷 마스크

**서브넷 마스크(Subnet Mask)**는 IP 주소에서 어디까지가 네트워크 부분이고 어디부터가 호스트 부분인지를 구분하는 역할을 합니다.

<br>

### 서브넷 마스크의 구조

서브넷 마스크는 IP 주소와 마찬가지로 32비트로 구성됩니다.

- **네트워크 부분**: 해당하는 비트를 `1`로 설정
- **호스트 부분**: 해당하는 비트를 `0`으로 설정

<br>

**예시: 서브넷 마스크 `255.255.255.0`**

```
255     .  255     .  255     .  0
11111111   11111111   11111111   00000000
←────── 네트워크 (24비트) ─────→←호스트(8비트)→
```

서브넷 마스크의 `1`이 연속된 부분이 네트워크를 식별하고, `0`이 연속된 부분이 호스트를 식별합니다.

<br>

### 서브넷 마스크를 이용한 네트워크 주소 계산

IP 주소와 서브넷 마스크를 비트 단위로 `AND` 연산하면 네트워크 주소를 얻을 수 있습니다.

AND 연산은 두 비트가 모두 `1`일 때만 `1`을 반환합니다.

<br>

**예시: IP 주소 `192.168.1.100`, 서브넷 마스크 `255.255.255.0`**

```
IP 주소       : 11000000.10101000.00000001.01100100  (192.168.1.100)
서브넷 마스크 : 11111111.11111111.11111111.00000000  (255.255.255.0)
─────────────────────────────────────────────────────────────────
AND 연산 결과 : 11000000.10101000.00000001.00000000  (192.168.1.0)
```

서브넷 마스크의 `1` 부분은 IP 주소의 값이 그대로 유지되고, `0` 부분은 모두 `0`이 됩니다.

따라서 `192.168.1.100/24`의 네트워크 주소는 `192.168.1.0`입니다.

<br>

### 같은 서브넷인지 판별하기

두 장치가 같은 서브넷에 있는지 확인하려면, 각 IP 주소에 서브넷 마스크를 AND 연산하여 네트워크 주소를 비교합니다.

**예시: `192.168.1.100`과 `192.168.1.200`은 같은 서브넷인가? (서브넷 마스크: `255.255.255.0`)**

```
192.168.1.100 AND 255.255.255.0 = 192.168.1.0
192.168.1.200 AND 255.255.255.0 = 192.168.1.0
```

네트워크 주소가 동일하므로 같은 서브넷입니다. 두 장치는 라우터 없이 직접 통신할 수 있습니다.

<br>

**예시: `192.168.1.100`과 `192.168.2.100`은 같은 서브넷인가? (서브넷 마스크: `255.255.255.0`)**

```
192.168.1.100 AND 255.255.255.0 = 192.168.1.0
192.168.2.100 AND 255.255.255.0 = 192.168.2.0
```

네트워크 주소가 다르므로 다른 서브넷입니다. 두 장치가 통신하려면 라우터(게이트웨이)를 거쳐야 합니다.

---

## CIDR 표기법

**CIDR(Classless Inter-Domain Routing)** 표기법은 서브넷 마스크를 더 간결하게 표현하는 방법입니다.

IP 주소 뒤에 슬래시(`/`)와 함께 네트워크 부분의 비트 수(서브넷 마스크에서 `1`의 개수)를 표기합니다.

<br>

**CIDR과 서브넷 마스크 변환**

| CIDR | 서브넷 마스크 | 이진수 표현 |
|------|--------------|------------|
| /8 | 255.0.0.0 | 11111111.00000000.00000000.00000000 |
| /16 | 255.255.0.0 | 11111111.11111111.00000000.00000000 |
| /24 | 255.255.255.0 | 11111111.11111111.11111111.00000000 |
| /25 | 255.255.255.128 | 11111111.11111111.11111111.10000000 |
| /26 | 255.255.255.192 | 11111111.11111111.11111111.11000000 |
| /27 | 255.255.255.224 | 11111111.11111111.11111111.11100000 |
| /28 | 255.255.255.240 | 11111111.11111111.11111111.11110000 |
| /29 | 255.255.255.248 | 11111111.11111111.11111111.11111000 |
| /30 | 255.255.255.252 | 11111111.11111111.11111111.11111100 |

<br>

`/24`는 "앞의 24비트가 네트워크 주소"라는 의미입니다.

`192.168.1.0/24`와 `192.168.1.0 (서브넷 마스크 255.255.255.0)`은 동일한 표현입니다.

---

## 서브넷 계산

서브넷을 계산할 때 알아야 할 핵심 개념들을 정리합니다.

<br>

### 주요 주소의 의미

하나의 서브넷에는 다음과 같은 특수한 주소들이 있습니다.

| 주소 종류 | 설명 | 특징 |
|----------|------|------|
| **네트워크 주소** | 서브넷 자체를 나타내는 주소 | 호스트 비트가 모두 `0` |
| **브로드캐스트 주소** | 서브넷 내 모든 장치에 전송 | 호스트 비트가 모두 `1` |
| **게이트웨이 주소** | 다른 네트워크로 나가는 출구 | 보통 첫 번째 또는 마지막 호스트 IP 사용 |
| **사용 가능한 호스트 주소** | 실제 장치에 할당 가능한 주소 | 네트워크 주소와 브로드캐스트 주소 제외 |

<br>

### 호스트 수 계산

서브넷에서 사용할 수 있는 호스트 수는 호스트 비트 수에 따라 결정됩니다.

$$
\text{사용 가능한 호스트 수} = 2^{\text{호스트 비트 수}} - 2
$$

호스트 비트 수 = 32 - CIDR 값

<br>

`2`를 빼는 이유:
- **네트워크 주소** (호스트 비트 모두 `0`): 장치에 할당 불가
- **브로드캐스트 주소** (호스트 비트 모두 `1`): 장치에 할당 불가

<br>

**CIDR별 호스트 수**

| CIDR | 호스트 비트 | 총 IP 수 | 사용 가능 호스트 |
|------|------------|----------|-----------------|
| /24 | 8 | 256 | 254 |
| /25 | 7 | 128 | 126 |
| /26 | 6 | 64 | 62 |
| /27 | 5 | 32 | 30 |
| /28 | 4 | 16 | 14 |
| /29 | 3 | 8 | 6 |
| /30 | 2 | 4 | 2 |

<br>

### 서브넷 범위 계산 단계

`192.168.1.0/26` 서브넷의 범위를 단계별로 계산해보겠습니다.

<br>

**1단계: 호스트 비트 수 계산**

```
호스트 비트 수 = 32 - 26 = 6비트
```

<br>

**2단계: 서브넷 크기(블록 크기) 계산**

```
서브넷 크기 = 2^6 = 64개 IP 주소
```

이 서브넷은 64개의 연속된 IP 주소를 포함합니다.

<br>

**3단계: 각 주소 계산**

```
네트워크 주소     : 192.168.1.0   (첫 번째 주소, 호스트 비트 모두 0)
첫 번째 호스트    : 192.168.1.1   (장치에 할당 가능한 첫 주소)
마지막 호스트     : 192.168.1.62  (장치에 할당 가능한 마지막 주소)
브로드캐스트 주소 : 192.168.1.63  (마지막 주소, 호스트 비트 모두 1)
게이트웨이        : 보통 192.168.1.1 또는 192.168.1.62 사용
```

<br>

**4단계: 사용 가능한 호스트 수**

```
사용 가능 호스트 = 64 - 2 = 62개
```

<br>

### 네트워크를 여러 서브넷으로 분할하기

`192.168.1.0/24` 네트워크를 4개의 서브넷으로 분할하는 예시입니다.

<br>

**분할 전**

```
네트워크: 192.168.1.0/24
호스트 비트: 8비트
사용 가능 호스트: 254개
```

<br>

**4개로 분할 (/26 사용)**

4개의 서브넷이 필요하므로 추가로 2비트가 필요합니다. (2² = 4)

원래 `/24`에서 2비트를 더 사용하면 `/26`이 됩니다.

| 서브넷 | 네트워크 주소 | 호스트 범위 | 브로드캐스트 | 호스트 수 |
|--------|--------------|-------------|--------------|----------|
| 1번 | 192.168.1.0/26 | .1 ~ .62 | .63 | 62 |
| 2번 | 192.168.1.64/26 | .65 ~ .126 | .127 | 62 |
| 3번 | 192.168.1.128/26 | .129 ~ .190 | .191 | 62 |
| 4번 | 192.168.1.192/26 | .193 ~ .254 | .255 | 62 |

각 서브넷의 시작 주소는 블록 크기(64)만큼 증가합니다: 0, 64, 128, 192

<br>

### 자주 사용되는 서브넷

| CIDR | 서브넷 마스크 | 호스트 수 | 일반적인 용도 |
|------|---------------|-----------|--------------|
| /30 | 255.255.255.252 | 2 | 라우터 간 Point-to-Point 링크 |
| /29 | 255.255.255.248 | 6 | 아주 작은 네트워크 |
| /28 | 255.255.255.240 | 14 | 소규모 부서 |
| /27 | 255.255.255.224 | 30 | 소규모 사무실 |
| /26 | 255.255.255.192 | 62 | 중규모 부서 |
| /25 | 255.255.255.128 | 126 | 중규모 네트워크 |
| /24 | 255.255.255.0 | 254 | 일반적인 LAN |
| /16 | 255.255.0.0 | 65,534 | 대규모 조직 |
| /8 | 255.0.0.0 | 16,777,214 | 매우 큰 네트워크 |

---

## 마무리

서브넷은 네트워크를 효율적으로 관리하고 보안을 강화하기 위한 필수적인 개념입니다.

<br>

**핵심 정리**

| 개념 | 설명 |
|------|------|
| 서브넷 | 큰 네트워크를 작은 단위로 분할한 것 |
| 서브넷 마스크 | IP 주소에서 네트워크/호스트 부분을 구분 |
| CIDR | 서브넷 마스크를 `/비트수`로 간결하게 표현 |
| 네트워크 주소 | 호스트 비트가 모두 0인 주소 |
| 브로드캐스트 주소 | 호스트 비트가 모두 1인 주소 |
| 사용 가능 호스트 | 2^(호스트 비트) - 2 |

<br>

**서브넷 계산 순서**

1. CIDR 값에서 호스트 비트 수 계산 (32 - CIDR)
2. 서브넷 크기 계산 (2^호스트비트)
3. 네트워크 주소 확인 (호스트 비트 모두 0)
4. 브로드캐스트 주소 확인 (호스트 비트 모두 1)
5. 사용 가능한 호스트 범위 확인 (네트워크 주소 + 1 ~ 브로드캐스트 주소 - 1)

---

**관련 글**
- [IP 주소(IP Address)의 개념과 구조](/dev/network/IPAddress/)
- [네트워크 통신의 원리 (1) - 전자기파와 신호 전송](/dev/network/NetworkCommunication-1/)
- [네트워크 통신의 원리 (2) - 디지털 신호와 정보 전달](/dev/network/NetworkCommunication-2/)
- [네트워크 통신의 원리 (3) - 프로토콜 스택과 데이터 흐름](/dev/network/NetworkCommunication-3/)

