---
layout: single
title: "HTTP의 진화 (2) - HTTP/3과 WebSocket - soo:bak"
date: "2026-01-19 23:13:02 +0900"
description: HTTP/3, QUIC 프로토콜, 0-RTT, 연결 마이그레이션, WebSocket의 동작 원리를 설명합니다.
tags:
  - 네트워크
  - HTTP
  - HTTP3
  - QUIC
  - WebSocket
---

## TCP의 한계

[Part 1](/dev/network/HTTPEvolution-1/)에서 HTTP/2의 TCP HOL Blocking 문제를 언급했습니다.

HTTP/2는 HTTP 레벨의 다중화를 구현했지만, TCP 위에서 동작합니다.

<br>

TCP의 특성:
- 순서 보장 (패킷 손실 시 재전송까지 대기)
- 연결 지향 (3-way 핸드셰이크)
- IP 주소 + 포트로 연결 식별

<br>

이 특성들이 현대 웹에서 문제가 됩니다.

<br>

**TCP HOL Blocking**

```
HTTP/2 스트림들:
스트림 1: [A][B][C]
스트림 2: [D][E][F]
스트림 3: [G][H][I]

TCP 전송:
[A][D][G][B 손실][E][H][C][F][I]

TCP 수신 버퍼:
[A][D][G][   ?   ][E][H][C][F][I]
         ↑
         B가 재전송될 때까지 전체 대기

스트림 2, 3의 데이터(E, F, H, I)는 준비됐지만
애플리케이션에 전달 불가
```

<br>

HTTP/2가 여러 스트림을 다중화해도, 하나의 TCP 연결을 공유하므로 패킷 손실이 모든 스트림에 영향을 줍니다.

<br>

**연결 설정 지연**

새 연결을 설정하려면:
- TCP 핸드셰이크: 1 RTT
- TLS 핸드셰이크: 2 RTT (TLS 1.2) 또는 1 RTT (TLS 1.3)

최소 2~3 RTT가 필요합니다.

<br>

모바일 네트워크에서 RTT가 100ms면, 연결 설정에만 200~300ms.

<br>

**연결 마이그레이션 불가**

TCP 연결은 (출발지 IP, 출발지 포트, 목적지 IP, 목적지 포트)로 식별됩니다.

IP 주소가 바뀌면 연결이 끊어집니다.

<br>

- Wi-Fi에서 LTE로 전환
- 다른 Wi-Fi 네트워크로 이동
- NAT 타임아웃으로 포트 변경

→ 모두 새 연결이 필요합니다.

---

## QUIC: UDP 위의 새로운 전송 계층

**QUIC(Quick UDP Internet Connections)**은 Google이 2012년부터 개발했습니다.

2021년 IETF에서 RFC 9000으로 표준화되었습니다.

<br>

핵심 아이디어:

UDP 위에 TCP의 기능(신뢰성, 흐름제어, 혼잡제어)을 구현하되, TCP의 한계를 극복합니다.

<br>

```
HTTP/2 스택:          HTTP/3 스택:
┌─────────────┐       ┌─────────────┐
│   HTTP/2    │       │   HTTP/3    │
├─────────────┤       ├─────────────┤
│    TLS      │       │    QUIC     │ ← TLS 1.3 내장
├─────────────┤       ├─────────────┤
│    TCP      │       │    UDP      │
├─────────────┤       ├─────────────┤
│     IP      │       │     IP      │
└─────────────┘       └─────────────┘
```

---

## QUIC의 스트림 독립성

QUIC의 가장 중요한 특성입니다.

<br>

**각 스트림이 독립적으로 전달됩니다.**

```
스트림 1: [A][B 손실][C]
스트림 2: [D][E][F]
스트림 3: [G][H][I]

QUIC 동작:
- 스트림 1: B 재전송 대기 중
- 스트림 2: D, E, F 즉시 애플리케이션에 전달
- 스트림 3: G, H, I 즉시 애플리케이션에 전달
```

<br>

패킷 손실이 해당 스트림에만 영향을 미칩니다.

다른 스트림은 계속 진행됩니다.

<br>

**TCP와 비교:**

TCP는 바이트 스트림으로 보장합니다.

애플리케이션에 데이터를 순서대로 전달해야 합니다.

TCP 계층에서는 "스트림"이라는 개념이 없습니다.

<br>

QUIC은 스트림을 프로토콜 수준에서 지원합니다.

각 스트림 내에서만 순서를 보장합니다.

스트림 간에는 순서 관계가 없습니다.

---

## 0-RTT 연결 설정

QUIC은 연결 설정을 획기적으로 빠르게 합니다.

<br>

**첫 연결: 1-RTT**

```
Client                                 Server
   │                                      │
   │ ──── Initial (TLS ClientHello) ──►  │
   │                                      │
   │ ◄─── Initial (TLS ServerHello) ───  │
   │ ◄─── Handshake (인증서 등) ────────  │
   │ ◄─── 1-RTT 데이터 ─────────────────  │
   │                                      │
   │ ──── Handshake (완료) ───────────►  │
   │ ──── 1-RTT 데이터 ───────────────►  │
```

<br>

QUIC은 TLS 1.3을 프로토콜에 통합했습니다.

TCP + TLS의 별도 핸드셰이크 대신 하나로 통합.

<br>

**재연결: 0-RTT**

이전에 연결했던 서버라면:

```
Client                                 Server
   │                                      │
   │ ──── Initial + 0-RTT 데이터 ─────►  │
   │      (이전 세션 키 사용)             │
   │                                      │
   │ ◄─── Handshake + 1-RTT 데이터 ────  │
```

<br>

첫 패킷에 애플리케이션 데이터를 포함합니다.

이전에 협상한 파라미터를 캐시하여 재사용합니다.

<br>

**0-RTT의 주의점:**

리플레이 공격에 취약합니다.

공격자가 0-RTT 패킷을 캡처해서 재전송할 수 있습니다.

멱등성(idempotent)이 있는 요청에만 사용해야 합니다 (GET 등).

---

## 연결 마이그레이션

QUIC 연결은 **Connection ID**로 식별됩니다.

IP 주소와 포트가 아닙니다.

<br>

```
초기 연결:
Client (192.168.1.10:5000) ◄──► Server
Connection ID: 0x1234abcd

Wi-Fi → LTE 전환:
Client (10.0.0.5:6789) ◄──► Server
Connection ID: 0x1234abcd   ← 같은 연결

서버는 같은 Connection ID를 보고 같은 연결임을 인식
```

<br>

사용자가 네트워크를 전환해도:
- 연결이 유지됨
- 재핸드셰이크 불필요
- 진행 중인 다운로드가 중단되지 않음

<br>

모바일 환경에서 큰 장점입니다.

---

## HTTP/3

**HTTP/3**은 QUIC 위에서 동작하는 HTTP입니다.

2022년 RFC 9114로 표준화되었습니다.

<br>

HTTP/2와의 관계:

- 의미적으로(semantically) 동일: 같은 메서드, 상태 코드, 헤더
- 전송 방식이 다름: TCP/TLS → QUIC

<br>

**QPACK: HTTP/3의 헤더 압축**

HTTP/2의 HPACK은 TCP의 순서 보장에 의존했습니다.

QUIC의 스트림 독립성 때문에 새로운 방식이 필요합니다.

<br>

QPACK은 별도의 단방향 스트림을 사용합니다:
- Encoder 스트림: 동적 테이블 업데이트 전송
- Decoder 스트림: 테이블 업데이트 확인

<br>

헤더 블록은 동적 테이블의 특정 상태를 참조합니다.

수신자가 해당 상태에 도달할 때까지 대기할 수 있습니다.

---

## HTTP/3 vs HTTP/2

```
특성                HTTP/2              HTTP/3
───────────────────────────────────────────────────
전송 프로토콜        TCP                 QUIC (UDP)
HOL Blocking        있음 (TCP 레벨)     없음 (스트림 독립)
연결 설정           2-3 RTT             1 RTT, 0-RTT
암호화              TLS 별도            TLS 1.3 내장
연결 마이그레이션    불가                가능
헤더 압축           HPACK               QPACK
서버 푸시           있음                있음 (권장 안 함)
```

<br>

**언제 HTTP/3이 유리한가:**

- 높은 지연 네트워크 (모바일, 위성)
- 패킷 손실이 잦은 환경 (무선 네트워크)
- 네트워크 전환이 빈번한 환경 (모바일)

<br>

**HTTP/2가 여전히 적합한 경우:**

- 안정적인 유선 네트워크
- 레거시 인프라 (UDP 차단, 방화벽)
- QUIC 미지원 클라이언트

---

## WebSocket: 양방향 실시간 통신

HTTP는 요청-응답 모델입니다.

클라이언트가 요청해야 서버가 응답합니다.

<br>

**서버에서 클라이언트로 먼저 데이터를 보내려면?**

<br>

전통적인 방법들:

**폴링(Polling)**

클라이언트가 주기적으로 요청합니다.

```
클라이언트: 새 메시지 있어? → 서버: 없어
(5초 후)
클라이언트: 새 메시지 있어? → 서버: 없어
(5초 후)
클라이언트: 새 메시지 있어? → 서버: 있어! [메시지]
```

비효율적입니다. 대부분의 요청이 헛됩니다.

<br>

**롱 폴링(Long Polling)**

서버가 데이터가 있을 때까지 응답을 보류합니다.

```
클라이언트: 새 메시지 있어?
서버: (대기... 30초 동안)
     메시지 도착!
서버: 있어! [메시지]
클라이언트: (즉시 다시) 새 메시지 있어?
```

개선되었지만, 여전히 HTTP 오버헤드가 있습니다.

---

## WebSocket 프로토콜

**WebSocket**은 진정한 양방향 통신을 제공합니다.

2011년 RFC 6455로 표준화되었습니다.

<br>

**핸드셰이크: HTTP 업그레이드**

```
클라이언트 요청:
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13

서버 응답:
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

<br>

이후 같은 TCP 연결이 WebSocket 프로토콜로 전환됩니다.

더 이상 HTTP가 아닙니다.

<br>

**양방향 통신**

```
연결 설정 후:

클라이언트 ←────────────────→ 서버
           (언제든 전송 가능)

클라이언트 → 서버: "안녕"
서버 → 클라이언트: "반가워"
서버 → 클라이언트: "새 메시지 왔어"
클라이언트 → 서버: "확인했어"
...
```

<br>

HTTP처럼 요청-응답 쌍이 없습니다.

어느 쪽이든 언제든 메시지를 보낼 수 있습니다.

---

## WebSocket 프레임 구조

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+
```

<br>

**주요 필드:**

- **FIN**: 마지막 프레임인지 (1비트)
- **Opcode**: 프레임 유형 (4비트)
  - 0x1: 텍스트
  - 0x2: 바이너리
  - 0x8: 연결 종료
  - 0x9: Ping
  - 0xA: Pong
- **MASK**: 페이로드가 마스킹되었는지 (클라이언트→서버는 필수)
- **Payload length**: 데이터 길이

<br>

**마스킹**

클라이언트에서 서버로 보내는 모든 프레임은 마스킹되어야 합니다.

프록시 캐시 포이즈닝 공격을 방지합니다.

<br>

4바이트 마스킹 키로 페이로드를 XOR합니다.

```
masked[i] = original[i] XOR masking_key[i % 4]
```

---

## WebSocket 사용 사례

**실시간 채팅**

메시지가 오면 즉시 모든 참여자에게 전달.

폴링보다 훨씬 효율적이고 반응이 빠릅니다.

<br>

**실시간 게임**

플레이어의 위치, 행동을 실시간으로 동기화.

지연시간이 중요합니다.

<br>

**주식/가상화폐 시세**

빠르게 변하는 가격을 실시간으로 표시.

<br>

**협업 도구**

문서 동시 편집, 화이트보드 공유.

<br>

**알림/푸시**

서버에서 클라이언트에 이벤트 알림.

---

## Server-Sent Events (SSE)

WebSocket의 대안으로 **SSE**가 있습니다.

<br>

차이점:
- WebSocket: 양방향
- SSE: 서버 → 클라이언트 단방향

<br>

SSE는 일반 HTTP를 사용합니다.

```
응답 헤더:
Content-Type: text/event-stream

응답 본문 (스트리밍):
data: 첫 번째 메시지

data: 두 번째 메시지

event: update
data: {"price": 123.45}

```

<br>

SSE가 적합한 경우:
- 서버에서 클라이언트로만 데이터 전송
- HTTP 인프라 활용 (프록시, 캐싱, 인증)
- 자동 재연결 지원

<br>

WebSocket이 필요한 경우:
- 양방향 통신
- 바이너리 데이터
- 더 낮은 오버헤드

---

## HTTP의 미래

HTTP는 계속 진화하고 있습니다.

<br>

**HTTP/3 보급**

HTTP/3 지원은 꾸준히 증가하고 있습니다.

Cloudflare, Google, Meta 등 주요 서비스는 이미 지원 중이며, 대부분의 최신 브라우저에서 기본 활성화되어 있습니다.

<br>

**WebTransport**

HTTP/3 (QUIC) 위에서 양방향 통신을 제공합니다.

WebSocket의 HTTP/3 버전이라고 볼 수 있습니다.

QUIC의 스트림 독립성, 연결 마이그레이션을 활용합니다.

<br>

**진화의 방향**

- 더 낮은 지연시간
- 더 나은 모바일 지원
- 더 간소화된 프로토콜
- 더 강화된 보안

<br>

네트워크 환경이 변하면 프로토콜도 변합니다.

TCP가 40년 넘게 사용되었지만, 웹의 요구사항이 변하면서 QUIC이 등장했습니다.

앞으로도 새로운 요구사항에 맞춰 HTTP는 계속 진화할 것입니다.

---

**관련 글**
- [HTTP의 진화 (1) - HTTP/1.0에서 HTTP/2까지](/dev/network/HTTPEvolution-1/)
- [네트워크 통신의 원리 (3) - 프로토콜 스택과 데이터 흐름](/dev/network/NetworkCommunication-3/)
- [네트워크 보안의 원리 (2) - TLS와 인증서 체계](/dev/network/NetworkSecurity-2/)
