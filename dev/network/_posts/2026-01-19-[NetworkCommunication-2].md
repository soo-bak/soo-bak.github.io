---
layout: single
title: "네트워크 통신의 원리 (2) - 디지털 신호와 정보 전달 - soo:bak"
date: "2026-01-19 23:02:00 +0900"
description: 아날로그-디지털 변환, 정보 이론의 핵심, 오류 검출과 정정, 다중 접근 방식을 설명합니다.
tags:
  - 네트워크
  - 디지털신호
  - 정보이론
  - 오류정정
---

## 왜 디지털인가

[Part 1](/dev/network/NetworkCommunication-1/)에서 물리적 신호 전송의 원리를 살펴보았습니다. 아날로그 신호를 그대로 전송할 수도 있지만, 현대 통신은 디지털을 사용합니다.

<br>

아날로그 신호는 거리에 따라 약해지고(감쇠), 전송 과정에서 잡음이 더해집니다. 아날로그 신호는 연속적인 값을 가지므로, 잡음이 더해지면 원래 신호와 잡음이 하나로 섞입니다. 어디까지가 원래 신호인지 구분할 방법이 없습니다.

약해진 신호를 증폭하면 잡음도 함께 증폭됩니다. 증폭을 반복할수록 신호 대비 잡음 비율이 커지고, 결국 원래 신호를 구분할 수 없게 됩니다.

```
원본 신호:  ∿∿∿∿
     ↓ (전송: 감쇠 + 잡음)
약해진 신호: ∿+잡음
     ↓ (증폭)
증폭 후:   ∿+잡음 (잡음도 함께 증폭)
     ↓ (반복)
결과:     잡음에 묻힌 신호
```

<br>

디지털 신호는 다릅니다. 0과 1, 두 가지 상태만 구분하면 됩니다.

신호가 약해지고 잡음이 더해져도, 0인지 1인지만 판단할 수 있으면 됩니다. 잡음이 임계값을 넘지 않는 한 원래 신호를 완벽하게 복원할 수 있습니다.

```
전송된 신호:  ──┐    ┌──┐
               │    │  │
               └────┘  └──
              0    1    0

수신된 신호 (잡음 포함):
            ~~┐~~┌~~┐~~
              │~  │ ~│
              └~~ └~~└~~

임계값으로 판단:
            ──┐    ┌──┐
               │    │  │
               └────┘  └──
              0    1    0  (원본 복원)
```

디지털 통신은 연속적인 값 대신 0과 1만 전송합니다. 잡음이 더해져도 0인지 1인지만 판단하면 되므로, 임계값 이내의 잡음은 문제가 되지 않습니다.

---

## 아날로그를 디지털로

디지털 전송이 잡음에 강하다면, 아날로그 신호를 디지털로 변환해서 보내면 됩니다.

음성이나 영상 같은 아날로그 신호를 0과 1의 비트열로 바꾸는 과정은 세 단계로 이루어집니다.

<br>

### 표본화 (Sampling)

첫 번째 단계입니다. 연속적으로 변하는 신호의 값을 일정 간격으로 측정합니다. 이 과정을 샘플링이라고 합니다.

```
아날로그 신호:  ∿∿∿∿∿∿∿∿∿∿
                │ │ │ │ │ │ │ │
샘플링:         ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓
측정값:         3.2, 4.1, 4.8, 4.2, 3.1, 2.5, 2.8, 3.5
```

원래 신호를 복원하려면 충분히 자주 샘플링해야 합니다. 파동의 한 주기에 최소 2개의 점이 있어야 오르내림을 구분할 수 있기 때문입니다. 1개 점만 있으면 파동의 꼭대기인지 바닥인지 알 수 없습니다.

1928년 해리 나이퀴스트가 증명한 **나이퀴스트 정리**에 따르면, 신호의 최대 주파수보다 **2배보다 빠르게** 샘플링하면 완벽하게 복원할 수 있습니다.

```
샘플링 주파수 > 2 × 신호의 최대 주파수
```

<br>

사람의 음성은 약 300Hz ~ 3400Hz 범위입니다. 전화 품질로 전송하려면 3400 × 2 = 6800Hz보다 빠르게 샘플링해야 합니다. 실제 전화 시스템은 8000Hz를 사용합니다.

CD 음질은 20Hz ~ 20kHz(사람 청각 범위)를 재현합니다. 20000 × 2 = 40000Hz보다 빠르게 샘플링해야 하고, 실제로는 44100Hz를 사용합니다.

<br>

나이퀴스트 조건을 만족하지 않으면 고주파 신호가 저주파 신호로 잘못 해석됩니다. 이 현상이 **앨리어싱(Aliasing)**입니다.

영화에서 자동차 바퀴가 거꾸로 도는 것처럼 보이는 것도 앨리어싱입니다. 바퀴가 1초에 10바퀴 회전하고(10Hz), 카메라가 1초에 12장을 촬영한다면(12fps), 나이퀴스트 조건(20fps 초과)을 만족하지 못합니다.

```
프레임 1: 표시가 0° 위치
프레임 2: 실제로 300° 회전 → 한 바퀴(360°)에서 60° 부족
프레임 3: 또 300° 회전 → 누적 60° + 60° = 120° 부족
프레임 4: 또 300° 회전 → 누적 180° 부족
```

카메라에는 매 프레임마다 표시가 60°씩 뒤로 가는 것처럼 보입니다. 실제로는 앞으로 300° 회전했지만, 한 바퀴에서 60° 모자라므로 뒤로 60° 간 것과 구분할 수 없습니다.

<br>

### 양자화 (Quantization)

두 번째 단계입니다. 표본화로 시간 축을 이산화했으니, 이제 크기 축도 이산화합니다. 연속적인 측정값을 미리 정해진 값들 중 하나로 변환하는 것이 **양자화**입니다. 이 정해진 값들을 레벨이라고 합니다.

```
연속값:    3.7  →  양자화  →  4
           2.3  →  양자화  →  2
           5.8  →  양자화  →  6
```

비트 수가 많을수록 더 많은 레벨을 표현할 수 있습니다. 8비트를 사용하면 2⁸ = 256개, 16비트를 사용하면 2¹⁶ = 65,536개입니다.

<br>

양자화는 필연적으로 정보 손실을 일으킵니다.

실제 값 3.7을 4로 표현하면 0.3의 오차가 발생합니다.

이것을 **양자화 오류(Quantization Error)** 또는 **양자화 잡음**이라고 합니다.

<br>

비트 수가 많을수록 레벨 간격이 촘촘해지고, 양자화 오류가 줄어듭니다. CD는 16비트(65,536개 레벨)를 사용합니다. 8비트(256개 레벨)로는 음질 저하가 느껴지기 때문입니다.

<br>

### 부호화 (Encoding)

세 번째 단계입니다. 양자화된 값을 이진수로 표현합니다.

```
156 → 10011100 (8비트)
```

<br>

이렇게 표본화 → 양자화 → 부호화를 거쳐 아날로그를 디지털로 변환하는 방식이 **PCM(Pulse Code Modulation)**입니다.

```
아날로그  →  표본화  →  양자화  →  부호화  →  디지털
  ∿∿∿        3.7        4       00000100
```

---

## 비트를 물리 신호로: 라인 코딩

디지털 데이터(0과 1의 나열)를 물리적 매체로 전송하려면 비트를 전압이나 전류 변화로 바꿔야 합니다. 이 과정이 **라인 코딩(Line Coding)**입니다.

<br>

가장 단순한 방식은 **NRZ(Non-Return to Zero)**입니다. 0을 낮은 전압, 1을 높은 전압으로 표현합니다.

```
비트:    1   0   0   1   1   1   0   0   0   0
        ┌─┐           ┌───────┐
전압:   │ │           │       │
       ─┘ └───────────┘       └───────────────
```

<br>

NRZ는 간단하지만 문제가 있습니다.

첫째, **동기화**입니다. 수신측은 한 비트가 끝나고 다음 비트가 시작되는 시점을 알아야 합니다. 위 예시에서 마지막 0이 4개인지 5개인지 구분할 수 없습니다. 송신측과 수신측이 비트를 보내고 읽는 속도가 조금만 달라도 비트 경계가 어긋납니다.

둘째, **DC 성분**입니다. 같은 비트가 계속되면 전압이 일정하게 유지되어, 수신측에서 신호의 기준점을 잡기 어려워집니다.

<br>

**맨체스터 인코딩(Manchester Encoding)**은 이 문제들을 해결합니다. 각 비트 중간에서 반드시 전압이 바뀝니다.

```
비트:       1       0       1       1       0
맨체스터:  ┌─┐     ┌─┐     ┌─┐     ┌─┐     ┌─┐
          │ └─┐ ┌─┘ │ │ └─┐ │ └─┐ ┌─┘ │
          └───┘ └───┘ └───┘ └───┘ └───┘

1: 비트 중간에서 고→저 전이
0: 비트 중간에서 저→고 전이
```

비트 중간에 항상 전이가 있으므로 수신측은 비트 경계를 파악할 수 있습니다. 고전압과 저전압이 번갈아 나타나므로 DC 성분도 없습니다.

<br>

대신 맨체스터 인코딩은 효율이 낮습니다. NRZ는 한 비트당 하나의 신호 구간만 필요하지만, 맨체스터는 두 개가 필요합니다. 같은 대역폭을 사용하면 맨체스터는 NRZ의 절반만 전송할 수 있습니다.

<br>

이 외에도 4B/5B, 8B/10B, MLT-3 등 효율과 동기화를 절충한 다양한 방식이 있지만, 각각의 원리가 복잡하므로 이 글에서는 다루지 않습니다.

---

## 정보의 수학적 정의

1948년, 클로드 섀넌은 "정보"를 수학적으로 정의했습니다. **정보는 불확실성의 해소입니다.**

<br>

동전을 던져 앞면이 나왔다는 메시지는 두 가지 가능성 중 하나를 확정합니다. log₂(2) = 1비트의 정보입니다.

주사위를 던져 3이 나왔다는 메시지는 여섯 가지 가능성 중 하나를 확정하므로 log₂(6) ≈ 2.58비트입니다.

```
정보량 = log₂(가능성의 수) = -log₂(확률)
```

확률이 낮은 사건일수록 더 많은 정보를 담고 있습니다. "내일 해가 뜬다"는 거의 확실하므로 정보량이 낮고, "여름에 눈이 온다"는 확률이 낮아 정보량이 높습니다.

<br>

정보원 전체의 평균 정보량을 **엔트로피(Entropy)**라고 합니다. 열역학의 엔트로피와 이름이 같지만 다른 개념입니다.

```
H = -Σ P(x) × log₂(P(x))
```

영어 텍스트를 예로 들면, 알파벳 26개가 동일한 확률로 나온다면 글자당 log₂(26) ≈ 4.7비트가 필요합니다. 하지만 실제 영어에서는 'e'는 자주 나오고 'z'는 드물게 나옵니다. 이런 불균등한 분포를 고려하면 영어 텍스트의 엔트로피는 글자당 약 1~1.5비트입니다.

실제 사용하는 비트 수와 엔트로피의 차이가 중복(Redundancy)이며, 이 중복을 제거하는 것이 데이터 압축의 기본 원리입니다.

<br>

### 채널 용량

섀넌은 잡음이 있는 채널에서 오류 없이 전송할 수 있는 최대 속도, **채널 용량(Channel Capacity)**을 정의했습니다. [Part 1](/dev/network/NetworkCommunication-1/)에서 소개한 공식입니다.

```
C = B × log₂(1 + S/N)
```

잡음이 있는 채널에서는 전송 중 일부 비트가 뒤집힐 수 있습니다. 오류를 복구하려면 중복 정보를 추가해야 하는데, 중복을 추가할수록 실제 데이터 전송 속도는 줄어듭니다.

C는 오류 복구가 가능한 최대 속도입니다. C 이하로 전송하면 중복을 추가할 여유가 있어 오류를 복구할 수 있고, C를 초과하면 여유가 없어 오류를 피할 수 없습니다.

---

## 오류 검출과 정정

앞서 오류를 복구하려면 중복을 추가해야 한다고 했습니다. 구체적인 방법들을 살펴봅니다.

<br>

### 패리티 비트

가장 간단한 방법입니다. 데이터에 1비트를 추가하여 전체 1의 개수가 짝수(또는 홀수)가 되게 합니다.

```
데이터: 1011001 (1이 4개, 짝수) → 패리티 비트 0 → 전송: 10110010
데이터: 1011101 (1이 5개, 홀수) → 패리티 비트 1 → 전송: 10111011
```

수신측에서 1의 개수를 세어 짝수가 아니면 오류가 발생한 것입니다.

패리티 비트는 1비트 오류만 검출할 수 있습니다. 2비트가 동시에 바뀌면 짝수/홀수가 유지되어 검출하지 못합니다. 또한 오류 위치를 알 수 없어 정정은 불가능합니다.

<br>

### CRC

실용적으로 가장 널리 사용되는 방식입니다. 이더넷, USB, ZIP 파일 등에서 사용됩니다.

CRC는 데이터를 특정 다항식으로 나눈 나머지를 검사값으로 사용합니다. 송신측이 데이터와 검사값을 함께 보내면, 수신측에서 같은 계산을 해서 검사값이 일치하는지 확인합니다. 원리는 복잡하지만 계산이 빠르고 검출 능력이 뛰어납니다.

이더넷 프레임의 마지막 4바이트가 CRC-32 검사값입니다.

<br>

### 해밍 코드

패리티 비트와 CRC는 오류를 검출만 합니다. 오류가 발생하면 재전송을 요청해야 합니다. 위성 통신처럼 왕복 시간이 긴 경우에는 재전송 없이 오류를 정정하는 것이 효율적입니다.

1950년, 리처드 해밍은 여러 개의 패리티 비트를 사용하여 오류 위치를 알아내는 방법을 발명했습니다. 오류 위치를 알면 해당 비트를 뒤집어 정정할 수 있습니다. 구체적인 원리는 복잡하므로 이 글에서는 다루지 않습니다.

해밍 코드의 원리는 현대 오류 정정 코드들의 기초가 됩니다. LDPC, 터보 코드 등이 Wi-Fi, 5G, SSD 등에서 사용됩니다.

<br>

### ARQ

오류 정정 코드는 중복 정보를 항상 추가하므로 대역폭 오버헤드가 있습니다. 채널 상태가 좋을 때는 오류 검출 후 재전송하는 것이 더 효율적일 수 있습니다.

**ARQ(Automatic Repeat Request)**는 오류를 검출하면 재전송을 요청하는 방식입니다. 수신측이 오류가 없으면 ACK(확인)를, 오류가 있으면 NAK(부정 확인)를 보내거나 타임아웃으로 재전송을 유도합니다.

Stop-and-Wait, Go-Back-N, Selective Repeat 등 여러 방식이 있으며, 각각 효율과 복잡도가 다릅니다.

<br>

오류 정정과 재전송 중 선택은 채널 상태에 따라 다릅니다. 오류율이 낮으면 재전송이 효율적이고, 오류율이 높거나 왕복 시간이 길면 오류 정정이 유리합니다. 현대 시스템은 둘을 조합하여 일부 오류는 정정하고, 심각한 오류는 재전송으로 처리합니다.

---

## 채널 공유

통신에서 **채널**은 신호가 전달되는 경로입니다. 무선 통신에서는 특정 주파수 대역이 하나의 채널이 됩니다.

그런데 무선 통신에 사용할 수 있는 주파수 범위는 정해져 있습니다. 정부가 이동통신용으로 허가한 주파수 대역은 한정되어 있고, 그 안에서 동시에 수용할 수 있는 사용자 수도 제한됩니다. 수백만 명이 동시에 통화하려면 주파수를 나누는 것만으로는 부족합니다. 그래서 같은 주파수를 여러 사용자가 나눠 쓰는 방법이 필요합니다.

<br>

### FDMA (Frequency Division Multiple Access)

주파수를 나누는 방법입니다. 전체 주파수 대역을 여러 개의 좁은 채널로 나누고, 각 사용자에게 하나씩 할당합니다.

```
주파수
  ↑
  │  ┌────────┐
  │  │ 사용자C │
  │  ├────────┤
  │  │ 사용자B │
  │  ├────────┤
  │  │ 사용자A │
  └──┴────────┴──→ 시간
```

FM 라디오가 이 방식입니다. 각 방송국이 서로 다른 주파수(88.1MHz, 91.9MHz 등)를 사용하므로 동시에 여러 방송을 송출할 수 있습니다. 1세대(1G) 아날로그 이동통신도 FDMA를 사용했습니다.

FDMA는 통화가 시작되면 끝날 때까지 주파수를 고정 할당합니다. 통화 중 침묵 구간에도 주파수가 점유되어 낭비가 발생합니다. 신호가 인접 주파수로 퍼지는 것을 막기 위해 채널 사이에 빈 간격(가드 밴드)도 필요합니다.

<br>

### TDMA (Time Division Multiple Access)

시간을 나누는 방법입니다. 모든 사용자가 같은 주파수를 사용하지만, 서로 다른 시간에 전송합니다. 자기 차례가 아닐 때는 주파수를 점유하지 않으므로 FDMA보다 효율적입니다.

```
     사용자A   사용자B   사용자C   사용자A   ...
    ┌────────┬────────┬────────┬────────┐
────┤  슬롯1 │  슬롯2 │  슬롯3 │  슬롯1 │───→ 시간
    └────────┴────────┴────────┴────────┘
```

GSM(2G)이 이 방식을 사용했습니다. 단, 모든 사용자가 같은 시간 기준으로 동기화되어야 합니다. 사용자 A가 자기 슬롯이 끝난 줄 모르고 계속 전송하면 사용자 B의 슬롯과 겹칩니다. 같은 주파수에서 두 신호가 동시에 전송되면 서로 간섭하여 둘 다 손상됩니다.

<br>

### CDMA (Code Division Multiple Access)

FDMA는 주파수로, TDMA는 시간으로 사용자를 구분했습니다. CDMA는 둘 다 나누지 않습니다. 모든 사용자가 같은 주파수를, 같은 시간에 사용합니다. 대신 각 사용자에게 고유한 **코드**(신호를 변환하는 고유한 패턴)를 부여하여 구분합니다.

각 사용자는 데이터를 자신의 코드와 결합하여 전송합니다. 공중에서 여러 사용자의 신호가 섞이지만, 수신측은 원하는 사용자의 코드를 적용하면 그 사용자의 데이터만 추출할 수 있습니다. 각 코드가 서로 **직교(Orthogonal)**하도록 설계되어 있기 때문입니다. 직교하는 코드들은 서로 간섭하지 않는 성질이 있습니다. 구체적인 수학적 원리는 이 글에서 다루지 않습니다.

CDMA는 3G 이동통신(CDMA2000, WCDMA)에서 사용되었습니다. GPS 위성도 CDMA 방식으로 여러 위성의 신호를 구분합니다.

<br>

### OFDMA (Orthogonal Frequency Division Multiple Access)

FDMA와 TDMA를 결합한 방식입니다. 4G LTE, 5G, Wi-Fi 6가 이 방식을 사용합니다.

넓은 주파수 대역을 수백~수천 개의 좁은 **부반송파(Subcarrier)**로 나눕니다. FDMA처럼 주파수를 나누되, 각 부반송파가 직교하도록 설계하여 가드 밴드 없이 촘촘하게 배치할 수 있습니다. 그리고 이 부반송파들을 TDMA처럼 시간 슬롯별로 다른 사용자에게 할당합니다.

```
주파수
  ↑
  │ ┌──┐┌──┐┌──┐┌──┐
  │ │A ││B ││A ││C │  ← 시간 슬롯 1
  │ ├──┤├──┤├──┤├──┤
  │ │B ││A ││C ││A │  ← 시간 슬롯 2
  └─┴──┴┴──┴┴──┴┴──┴──→ 부반송파
```

FDMA에서는 통화가 끝날 때까지 주파수가 고정됩니다. 반면 OFDMA는 매 시간 슬롯마다 부반송파 할당을 바꿀 수 있습니다. 예를 들어 영상을 다운로드하는 사용자에게는 많은 부반송파를, 문자만 보내는 사용자에게는 적은 부반송파를 할당하는 방식입니다. 상황이 바뀌면 다음 슬롯에서 할당도 바뀝니다.

---

## 마무리

이 글에서 살펴본 내용을 정리하면:

- 디지털 통신은 이산 상태를 사용하여 잡음 환경에서도 원본을 복원할 수 있습니다.
- 아날로그-디지털 변환은 나이퀴스트 정리(샘플링 조건)와 양자화 비트 수에 의해 결정됩니다.
- 섀넌의 채널 용량은 주어진 조건에서 전송 속도의 한계를 정의합니다.
- 오류 검출과 정정은 중복을 추가하여 신뢰성을 확보합니다.
- 다중 접근 기술(FDMA, TDMA, CDMA, OFDMA)은 유한한 자원을 여러 사용자가 공유하게 합니다.

<br>

이 모든 것이 물리 계층과 데이터링크 계층에서 일어납니다. [Part 3](/dev/network/NetworkCommunication-3/)에서는 이렇게 전달된 비트들이 어떻게 체계적으로 조직되어 의미 있는 통신이 되는지 다룹니다.

<br>

---

**관련 글**
- [네트워크 통신의 원리 (1) - 전자기파와 신호 전송](/dev/network/NetworkCommunication-1/)
- [네트워크 통신의 원리 (3) - 프로토콜 스택과 데이터 흐름](/dev/network/NetworkCommunication-3/)
- [IP 주소(IP Address)의 개념과 구조](/dev/network/IPAddress/)
- [서브넷(Subnet)의 개념과 서브네팅](/dev/network/Subnet/)

**심화 시리즈**
- [소켓과 전송 계층 (1) - 소켓의 탄생과 추상화](/dev/network/SocketTransport-1/)
- [소켓과 전송 계층 (2) - TCP 연결의 상태 머신](/dev/network/SocketTransport-2/)
- [소켓과 전송 계층 (3) - 멀티플렉싱과 패킷 흐름](/dev/network/SocketTransport-3/)
- [무선 통신의 진화 (1) - 무선 채널의 물리적 특성](/dev/network/WirelessCommunication-1/)
- [무선 통신의 진화 (2) - 셀룰러와 Wi-Fi의 발전](/dev/network/WirelessCommunication-2/)
- [라우팅과 인터넷 구조 (1) - 라우팅의 역사와 기본 원리](/dev/network/Routing-1/)
- [라우팅과 인터넷 구조 (2) - 거리 벡터와 링크 상태 알고리즘](/dev/network/Routing-2/)
- [라우팅과 인터넷 구조 (3) - BGP와 인터넷의 구조](/dev/network/Routing-3/)
- [네트워크 보안의 원리 (1) - 암호화의 수학적 기초](/dev/network/NetworkSecurity-1/)
- [네트워크 보안의 원리 (2) - TLS와 인증서 체계](/dev/network/NetworkSecurity-2/)
- [네트워크 보안의 원리 (3) - 네트워크 공격과 방어](/dev/network/NetworkSecurity-3/)
- [HTTP의 진화 (1) - HTTP/1.0에서 HTTP/2까지](/dev/network/HTTPEvolution-1/)
- [HTTP의 진화 (2) - HTTP/3과 QUIC, 그리고 WebSocket](/dev/network/HTTPEvolution-2/)
- [DNS의 원리 (1) - DNS의 탄생과 계층 구조](/dev/network/DNS-1/)
- [DNS의 원리 (2) - DNS 질의와 해석 과정](/dev/network/DNS-2/)
- [DNS의 원리 (3) - DNS 보안과 현대적 발전](/dev/network/DNS-3/)
- [NAT와 방화벽 (1) - NAT의 탄생과 주소 변환](/dev/network/NATFirewall-1/)
- [NAT와 방화벽 (2) - 방화벽과 상태 추적](/dev/network/NATFirewall-2/)
- [NAT와 방화벽 (3) - NAT 트래버설과 P2P](/dev/network/NATFirewall-3/)
- [VPN과 터널링 (1) - 터널링의 원리](/dev/network/VPNTunnel-1/)
- [VPN과 터널링 (2) - IPsec의 구조](/dev/network/VPNTunnel-2/)
- [VPN과 터널링 (3) - 현대 VPN 기술](/dev/network/VPNTunnel-3/)
- [로드 밸런싱 (1) - 로드 밸런싱의 원리](/dev/network/LoadBalancing-1/)
- [로드 밸런싱 (2) - DNS 기반 로드 밸런싱](/dev/network/LoadBalancing-2/)
- [로드 밸런싱 (3) - 고가용성 아키텍처](/dev/network/LoadBalancing-3/)
- [컨테이너 네트워킹 (1) - 컨테이너 네트워크 기초](/dev/network/ContainerNetwork-1/)
- [컨테이너 네트워킹 (2) - 오버레이 네트워크](/dev/network/ContainerNetwork-2/)
- [컨테이너 네트워킹 (3) - Kubernetes 네트워킹](/dev/network/ContainerNetwork-3/)
- [네트워크 성능 (1) - 지연 시간의 구성 요소](/dev/network/NetworkPerformance-1/)
- [네트워크 성능 (2) - TCP 혼잡 제어 심화](/dev/network/NetworkPerformance-2/)
- [네트워크 성능 (3) - 애플리케이션 레벨 최적화](/dev/network/NetworkPerformance-3/)
- [실시간 통신 (1) - RTP와 실시간 전송](/dev/network/RealTimeCommunication-1/)
- [실시간 통신 (2) - WebRTC 스택](/dev/network/RealTimeCommunication-2/)
- [실시간 통신 (3) - 품질 관리와 적응](/dev/network/RealTimeCommunication-3/)
- [네트워크 디버깅 (1) - 계층별 진단 도구](/dev/network/NetworkDebugging-1/)
- [네트워크 디버깅 (2) - 패킷 분석](/dev/network/NetworkDebugging-2/)
- [IoT 네트워킹 (1) - IoT 프로토콜](/dev/network/IoTNetworking-1/)
- [IoT 네트워킹 (2) - LPWAN과 IoT 보안](/dev/network/IoTNetworking-2/)

