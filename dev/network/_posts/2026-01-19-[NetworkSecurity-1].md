---
layout: single
title: "네트워크 보안의 원리 (1) - 암호화의 수학적 기초 - soo:bak"
date: "2026-01-19 23:12:01 +0900"
description: 대칭키와 비대칭키 암호화, AES, RSA, Diffie-Hellman, 해시 함수의 수학적 원리를 설명합니다.
tags:
  - 네트워크
  - 보안
  - 암호화
  - RSA
  - AES
---

## 네트워크에서 보안이 필요한 이유

[네트워크 통신의 원리](/dev/network/NetworkCommunication-1/) 시리즈에서 데이터가 어떻게 전송되는지 살펴보았습니다.

하지만 중요한 문제가 있습니다.

<br>

네트워크를 지나는 데이터는 누구나 볼 수 있습니다.

이더넷은 같은 세그먼트의 모든 트래픽이 보입니다.

Wi-Fi는 공기 중에 방송됩니다.

인터넷은 수많은 라우터를 거칩니다.

<br>

이 중 어디서든 도청이 가능합니다.

<br>

네트워크 보안의 세 가지 목표:

1. **기밀성(Confidentiality)**: 허가되지 않은 자가 내용을 볼 수 없어야 함
2. **무결성(Integrity)**: 데이터가 전송 중 변조되지 않았음을 보장
3. **인증(Authentication)**: 통신 상대방이 실제로 그 사람인지 확인

<br>

이 세 가지를 달성하는 핵심 도구가 **암호화(Cryptography)**입니다.

---

## 암호화의 기본 개념

**암호화**는 평문(plaintext)을 암호문(ciphertext)으로 변환하는 것입니다.

**복호화**는 암호문을 다시 평문으로 변환하는 것입니다.

<br>

```
평문 ──[암호화]──► 암호문 ──[복호화]──► 평문
        키 사용           키 사용
```

<br>

핵심은 **키(Key)**입니다.

같은 알고리즘을 사용해도 키가 다르면 결과가 다릅니다.

키를 모르면 복호화할 수 없습니다.

<br>

암호화 방식은 크게 두 가지:

- **대칭키 암호(Symmetric Key)**: 암호화와 복호화에 같은 키 사용
- **비대칭키 암호(Asymmetric Key)**: 서로 다른 키 사용

---

## 대칭키 암호: 빠르고 효율적

대칭키 암호는 암호화와 복호화에 **동일한 키**를 사용합니다.

<br>

```
Alice                              Bob
  │                                 │
  │  평문 ──[키 K로 암호화]──► 암호문 │
  │        ────────────────────►    │
  │                                 │
  │            [키 K로 복호화]       │
  │                암호문 ──► 평문  │
```

<br>

장점:
- 빠른 연산 (하드웨어 가속 가능)
- 적은 계산 비용

단점:
- **키 교환 문제**: 키를 어떻게 안전하게 전달할 것인가?
- 통신 상대마다 별도의 키 필요 (n명이면 n(n-1)/2개의 키)

<br>

대표적인 대칭키 알고리즘: **AES(Advanced Encryption Standard)**

---

## AES: 현대 대칭키 암호의 표준

AES는 2001년 NIST가 DES를 대체하기 위해 선정한 표준입니다.

벨기에 암호학자 Joan Daemen과 Vincent Rijmen이 설계한 Rijndael 알고리즘입니다.

<br>

**AES의 구조:**

- 블록 크기: 128비트 (16바이트)
- 키 크기: 128, 192, 또는 256비트
- 라운드 수: 10, 12, 또는 14 (키 크기에 따라)

<br>

AES는 **치환-순열 네트워크(Substitution-Permutation Network, SPN)** 구조입니다.

<br>

한 라운드의 연산:

1. **SubBytes (바이트 치환)**
   - 각 바이트를 S-box를 통해 다른 값으로 변환
   - 비선형성 제공 (분석을 어렵게 함)

2. **ShiftRows (행 이동)**
   - 4×4 행렬의 각 행을 왼쪽으로 시프트
   - 0, 1, 2, 3바이트씩

3. **MixColumns (열 혼합)**
   - 각 열에 행렬 곱셈 적용
   - 바이트들을 섞어 확산(diffusion) 제공

4. **AddRoundKey (라운드 키 덧셈)**
   - 현재 상태와 라운드 키를 XOR
   - 키의 영향력 주입

<br>

```
입력 블록 (128비트)
     │
     ▼
┌─────────────┐
│  SubBytes   │  ← 비선형 치환
└─────────────┘
     │
     ▼
┌─────────────┐
│  ShiftRows  │  ← 행 이동
└─────────────┘
     │
     ▼
┌─────────────┐
│ MixColumns  │  ← 열 혼합
└─────────────┘
     │
     ▼
┌─────────────┐
│AddRoundKey  │  ← 라운드 키 XOR
└─────────────┘
     │
     ▼
   (반복)
```

<br>

왜 이렇게 설계했을까요?

<br>

**혼돈(Confusion)**: SubBytes가 담당. 키와 암호문의 관계를 복잡하게.

**확산(Diffusion)**: ShiftRows와 MixColumns가 담당. 평문의 한 비트가 바뀌면 암호문의 많은 비트가 바뀜.

<br>

이 두 성질이 결합되어 통계적 분석을 어렵게 만듭니다.

---

## 블록 암호 운용 모드

AES는 128비트 블록을 암호화합니다.

더 긴 데이터는 어떻게 처리할까요?

<br>

**ECB(Electronic Codebook)**: 가장 단순, 각 블록을 독립적으로 암호화

```
평문1 ──[암호화]──► 암호문1
평문2 ──[암호화]──► 암호문2
평문3 ──[암호화]──► 암호문3
```

문제: 같은 평문 블록은 같은 암호문이 됨. 패턴이 드러남.

유명한 예: ECB 펭귄 (이미지를 ECB로 암호화하면 원본 윤곽이 보임)

<br>

**CBC(Cipher Block Chaining)**: 각 블록을 이전 암호문과 XOR 후 암호화

```
평문1 ⊕ IV ──[암호화]──► 암호문1
평문2 ⊕ 암호문1 ──[암호화]──► 암호문2
평문3 ⊕ 암호문2 ──[암호화]──► 암호문3
```

IV(Initialization Vector)는 무작위 값.

같은 평문도 IV가 다르면 다른 암호문.

<br>

**GCM(Galois/Counter Mode)**: 암호화와 인증을 동시에

- CTR 모드로 암호화 (카운터를 암호화하여 평문과 XOR)
- GHASH로 인증 태그 생성
- **AEAD(Authenticated Encryption with Associated Data)** 제공

<br>

GCM이 현대 네트워크 보안에서 가장 널리 사용됩니다.

TLS 1.3에서 AES-GCM이 필수입니다.

---

## 비대칭키 암호: 키 교환 문제의 해결

대칭키의 문제: 키를 어떻게 안전하게 공유할까?

<br>

1976년, Whitfield Diffie와 Martin Hellman이 새로운 방식을 발표합니다.

**공개키 암호화(Public Key Cryptography)**.

<br>

핵심 아이디어:

- 두 개의 키: 공개키(public key)와 개인키(private key)
- 공개키로 암호화하면 개인키로만 복호화 가능
- 개인키로 서명하면 공개키로 검증 가능

<br>

```
Alice                                  Bob
  │                                     │
  │  Bob의 공개키로 암호화 ──────────► │
  │                         암호문     │
  │                                     │
  │                    Bob의 개인키로   │
  │                         복호화     │
```

<br>

Bob의 공개키는 누구나 알 수 있습니다.

하지만 복호화는 Bob의 개인키로만 가능합니다.

Bob만 개인키를 가지고 있으므로 Bob만 읽을 수 있습니다.

<br>

어떻게 이것이 수학적으로 가능할까요?

---

## RSA: 소인수분해의 어려움

**RSA**는 1977년 Ron Rivest, Adi Shamir, Leonard Adleman이 발명했습니다.

수학적 기반: **큰 수의 소인수분해는 어렵다**.

<br>

**키 생성:**

1. 두 개의 큰 소수 p와 q를 선택 (각각 1024비트 이상)
2. n = p × q 계산
3. φ(n) = (p-1) × (q-1) 계산 (오일러 파이 함수)
4. 1 < e < φ(n)이고 gcd(e, φ(n)) = 1인 e 선택 (보통 65537)
5. e × d ≡ 1 (mod φ(n))인 d 계산

<br>

**공개키**: (n, e)

**개인키**: d

<br>

**암호화**: c = m^e mod n

**복호화**: m = c^d mod n

<br>

왜 안전할까요?

<br>

공격자는 n과 e를 알 수 있습니다.

d를 알아내려면 φ(n)이 필요합니다.

φ(n) = (p-1)(q-1)이므로 p와 q가 필요합니다.

n = p × q에서 p와 q를 찾는 것이 **소인수분해 문제**입니다.

<br>

작은 수는 쉽습니다: 15 = 3 × 5

큰 수는 어렵습니다: 2048비트 수를 소인수분해하는 알려진 효율적인 방법이 없습니다.

<br>

현재 컴퓨터로 2048비트 RSA를 깨는 데는 우주의 나이보다 긴 시간이 걸릴 것으로 추정됩니다.

---

## Diffie-Hellman: 안전한 키 교환

RSA는 암호화에 쓸 수 있지만, 계산 비용이 큽니다.

대칭키 암호가 훨씬 빠릅니다.

<br>

해결책: 비대칭키로 **대칭키를 교환**하고, 대칭키로 실제 데이터를 암호화.

<br>

**Diffie-Hellman 키 교환**은 공개 채널에서 공유 비밀을 만드는 방법입니다.

<br>

수학적 기반: **이산 로그 문제**

g^x mod p에서 g, p, g^x mod p가 주어졌을 때 x를 찾기 어렵다.

<br>

**과정:**

1. Alice와 Bob이 공개 값 p(큰 소수)와 g(원시근)에 합의
2. Alice는 비밀 값 a를 선택하고 A = g^a mod p를 Bob에게 전송
3. Bob은 비밀 값 b를 선택하고 B = g^b mod p를 Alice에게 전송
4. Alice는 s = B^a mod p 계산
5. Bob은 s = A^b mod p 계산

<br>

```
Alice                                 Bob
  │                                    │
  │  a (비밀)                          │  b (비밀)
  │  A = g^a mod p ─────────────────► │
  │                                    │
  │ ◄───────────────── B = g^b mod p  │
  │                                    │
  │  s = B^a mod p                     │  s = A^b mod p
  │    = (g^b)^a mod p                 │    = (g^a)^b mod p
  │    = g^(ab) mod p                  │    = g^(ab) mod p
  │                                    │
  └────────► 같은 비밀 s ◄─────────────┘
```

<br>

도청자는 p, g, A, B를 알 수 있습니다.

하지만 a나 b를 모르면 s를 계산할 수 없습니다.

A에서 a를 알아내는 것이 이산 로그 문제입니다.

<br>

**ECDH(Elliptic Curve Diffie-Hellman)**

타원곡선 위에서 Diffie-Hellman을 수행합니다.

같은 보안 수준에서 키 크기가 훨씬 작습니다.

- RSA 2048비트 ≈ ECDH 224비트

---

## 전방향 비밀성: 과거를 보호하다

일반적인 키 교환:

서버의 개인키가 유출되면?

과거에 기록된 모든 통신을 복호화할 수 있습니다.

<br>

**전방향 비밀성(Forward Secrecy, FS)**은 이 문제를 해결합니다.

<br>

**임시 Diffie-Hellman(Ephemeral DH)**:

매 세션마다 새로운 DH 키 쌍을 생성합니다.

세션이 끝나면 임시 개인키를 폐기합니다.

<br>

```
세션 1: a₁, b₁ → s₁
세션 2: a₂, b₂ → s₂
세션 3: a₃, b₃ → s₃

각 세션의 임시 개인키는 세션 후 폐기됨
```

<br>

서버의 장기 개인키가 유출되어도:

- 과거 세션의 임시 키는 이미 폐기됨
- 과거 세션을 복호화할 수 없음

<br>

TLS 1.3은 전방향 비밀성을 필수로 요구합니다.

---

## 해시 함수: 디지털 지문

**해시 함수**는 임의 길이의 입력을 고정 길이의 출력으로 변환합니다.

<br>

```
"Hello" ──[SHA-256]──► 185f8db32271fe25f561a6fc938b2e26...
"Hello!" ──[SHA-256]──► 33b55d...  (완전히 다른 값)
```

<br>

암호학적 해시 함수의 속성:

1. **일방향성**: 해시값에서 원본을 찾기 불가능
2. **충돌 저항성**: 같은 해시값을 가지는 두 입력을 찾기 어려움
3. **눈사태 효과**: 입력이 조금만 바뀌어도 출력이 크게 변함

<br>

주요 해시 함수:

- **MD5**: 128비트 출력, 충돌 발견됨 (사용 금지)
- **SHA-1**: 160비트 출력, 충돌 발견됨 (사용 금지)
- **SHA-256**: 256비트 출력, 현재 안전
- **SHA-3**: NIST 표준, SHA-2와 다른 구조

<br>

해시의 용도:

- **무결성 검증**: 파일/메시지가 변조되지 않았는지 확인
- **비밀번호 저장**: 원본 대신 해시값 저장
- **디지털 서명**: 메시지 전체 대신 해시에 서명

---

## HMAC: 키가 있는 해시

일반 해시는 누구나 계산할 수 있습니다.

공격자가 메시지와 해시를 모두 변조할 수 있습니다.

<br>

**HMAC(Hash-based Message Authentication Code)**은 키를 사용합니다.

<br>

```
HMAC(K, m) = H((K ⊕ opad) || H((K ⊕ ipad) || m))

K: 비밀 키
m: 메시지
H: 해시 함수
opad, ipad: 패딩 상수
```

<br>

키를 모르면 올바른 HMAC을 생성할 수 없습니다.

수신자는 같은 키로 HMAC을 계산하여 검증합니다.

<br>

HMAC-SHA256은 TLS에서 메시지 인증에 사용됩니다.

---

## 디지털 서명: 부인 방지

HMAC은 대칭키를 사용합니다.

송신자와 수신자 모두 같은 키를 알고 있습니다.

누가 메시지를 보냈는지 제3자에게 증명할 수 없습니다.

<br>

**디지털 서명**은 비대칭키를 사용합니다.

<br>

**서명 과정:**

1. 메시지의 해시를 계산
2. 해시를 개인키로 암호화 (서명)
3. 메시지와 서명을 전송

<br>

**검증 과정:**

1. 수신한 메시지의 해시를 계산
2. 서명을 공개키로 복호화
3. 두 해시가 일치하면 검증 성공

<br>

```
Alice (서명)                          Bob (검증)
  │                                    │
  │ H(m) = 해시                        │
  │ sig = H(m)^d mod n                │
  │                                    │
  │ ───────── m, sig ─────────────► │
  │                                    │
  │                  H(m) 계산         │
  │                  sig^e mod n 계산  │
  │                  두 값 비교        │
```

<br>

서명의 의미:

- **인증**: 개인키 소유자만 서명 가능
- **무결성**: 메시지 변조 시 서명 검증 실패
- **부인 방지**: 서명자가 나중에 부인할 수 없음

---

## 암호화 시스템의 조합

실제 시스템은 여러 암호화 기법을 조합합니다.

<br>

**하이브리드 암호화:**

1. 무작위 대칭키(세션 키) 생성
2. 세션 키를 수신자의 공개키로 암호화
3. 데이터를 세션 키로 암호화 (AES-GCM)
4. 암호화된 세션 키 + 암호화된 데이터 전송

<br>

```
송신자:
  세션키 K ──[수신자 공개키로 암호화]──► 암호화된 K
  데이터 ──[K로 AES-GCM 암호화]──► 암호화된 데이터

전송: {암호화된 K, 암호화된 데이터}

수신자:
  암호화된 K ──[개인키로 복호화]──► K
  암호화된 데이터 ──[K로 복호화]──► 데이터
```

<br>

이 방식의 장점:

- RSA의 키 교환 능력 활용
- AES의 빠른 대칭키 암호화 활용
- 대용량 데이터도 효율적으로 처리

<br>

[Part 2](/dev/network/NetworkSecurity-2/)에서는 이런 암호화 기법들이 TLS에서 어떻게 조합되어 안전한 연결을 만드는지 살펴봅니다.

---

**관련 글**
- [네트워크 통신의 원리 (3) - 프로토콜 스택과 데이터 흐름](/dev/network/NetworkCommunication-3/)
- [네트워크 보안의 원리 (2) - TLS와 인증서 체계](/dev/network/NetworkSecurity-2/)
- [네트워크 보안의 원리 (3) - 네트워크 공격과 방어](/dev/network/NetworkSecurity-3/)
