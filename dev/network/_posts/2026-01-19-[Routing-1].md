---
layout: single
title: "라우팅과 인터넷 구조 (1) - 라우팅의 기본 원리 - soo:bak"
date: "2026-01-19 23:11:01 +0900"
description: 라우팅의 역사, 라우팅 테이블 구조, 최장 접두사 매칭, 정적 라우팅과 동적 라우팅을 설명합니다.
tags:
  - 네트워크
  - 라우팅
  - IP
  - 라우터
---

## 패킷은 어떻게 목적지를 찾아가는가

[네트워크 통신의 원리 (3)](/dev/network/NetworkCommunication-3/)에서 라우터의 기본 개념을 살펴보았습니다. 라우터는 패킷의 목적지 IP 주소를 확인하고 다음 홉(next hop)을 결정하는 역할을 수행합니다.

<br>

그런데 라우터는 다음 홉을 어떻게 알 수 있을까요? 인터넷에는 수십억 개의 IP 주소가 존재하므로, 라우터가 모든 주소를 개별적으로 기억하기란 불가능합니다.

<br>

이 질문의 답을 찾으려면 라우팅의 역사로 돌아가야 합니다.

---

## ARPANET: 분산 라우팅의 탄생

1969년, 인터넷의 전신인 **ARPANET**이 시작되었습니다. 미국 국방부 고등연구계획국(DARPA)이 자금을 지원한 이 프로젝트의 핵심 설계 목표는 **생존성(survivability)**이었습니다.

<br>

핵 공격으로 일부 노드가 파괴되더라도 나머지 네트워크가 계속 동작해야 했기에, ARPANET은 **분산 라우팅(distributed routing)** 방식을 채택했습니다. 중앙 제어 장치 없이 각 노드가 독립적으로 경로를 결정하며, 일부 노드가 사라지면 나머지가 자동으로 우회 경로를 탐색합니다.

<br>

ARPANET의 노드는 **IMP(Interface Message Processor)**라 불렸으며, 오늘날 라우터의 원형이라 할 수 있습니다.

<br>

초기 ARPANET은 단순한 알고리즘을 사용했는데, 각 IMP가 이웃과 정보를 교환하면서 최단 경로를 계산하는 방식이었습니다. 이것이 바로 라우팅 알고리즘의 출발점입니다.

---

## 라우팅 테이블: 경로의 지도

라우터의 핵심은 **라우팅 테이블(Routing Table)**입니다. 목적지로 가기 위해 어디로 보내야 하는지를 기록한 표로, 일종의 "경로 안내 지도" 역할을 합니다.

<br>

라우팅 테이블의 기본 구조는 다음과 같습니다.

```
목적지 네트워크        다음 홉           인터페이스    메트릭
────────────────────────────────────────────────────────────
192.168.1.0/24        직접 연결          eth0         0
10.0.0.0/8           192.168.1.1        eth0         1
172.16.0.0/16        192.168.1.2        eth0         2
0.0.0.0/0            192.168.1.254      eth0         1
```

<br>

각 항목의 의미를 살펴보면 다음과 같습니다.

- **목적지 네트워크**: 어디로 가는 패킷인지를 나타냄
- **다음 홉(Next Hop)**: 해당 패킷을 어디로 전달해야 하는지 지정
- **인터페이스**: 어느 네트워크 인터페이스로 내보낼지 결정
- **메트릭(Metric)**: 이 경로의 비용(거리)을 수치로 표현

<br>

여기서 주목할 점은 **목적지가 개별 IP가 아니라 네트워크 단위**라는 사실입니다. 예를 들어 192.168.1.0/24는 192.168.1.0부터 192.168.1.255까지 256개의 주소를 포함하는데, 이는 [서브넷(Subnet)](/dev/network/Subnet/)에서 설명한 CIDR 표기법을 따릅니다.

<br>

이처럼 네트워크 단위로 묶어서 관리하기 때문에 수십억 개의 IP 주소를 수십만 개의 네트워크 항목으로 압축할 수 있게 됩니다.

---

## 최장 접두사 매칭: 가장 구체적인 경로 선택

패킷이 도착하면 라우터는 목적지 IP와 일치하는 항목을 라우팅 테이블에서 찾습니다. 그런데 문제가 하나 있는데, 여러 항목이 동시에 일치할 수 있다는 점입니다.

<br>

예를 들어 목적지가 10.1.2.3인 경우를 살펴보겠습니다.

```
10.0.0.0/8        → 일치 (10.x.x.x 모두 포함)
10.1.0.0/16       → 일치 (10.1.x.x 모두 포함)
10.1.2.0/24       → 일치 (10.1.2.x 모두 포함)
0.0.0.0/0         → 일치 (모든 주소 포함)
```

<br>

이 중 어떤 것을 선택해야 할까요? 이때 적용되는 원칙이 바로 **최장 접두사 매칭(Longest Prefix Match)**입니다. 가장 구체적인, 즉 접두사가 가장 긴 항목을 선택하는 방식입니다.

<br>

위 예시에서는 /24가 가장 길므로 10.1.2.0/24가 선택됩니다.

<br>

왜 이런 방식을 사용할까요? 더 긴 접두사는 더 구체적인 목적지를 의미하기 때문입니다. 네트워크 관리자가 특정 서브넷에 대해 별도의 경로를 지정했다면 그 의도를 존중해야 합니다.

<br>

한편 0.0.0.0/0은 **기본 경로(Default Route)**라 부릅니다. 모든 IP와 일치하지만 접두사 길이가 0이므로, 다른 어떤 항목도 일치하지 않을 때에만 사용됩니다.

<br>

기본 경로가 설정되어 있으면 라우터는 "모르는 목적지"에 대해서도 패킷을 전달할 수 있습니다. 가정용 공유기에서 ISP의 게이트웨이를 기본 경로로 설정하는 것이 대표적인 예입니다.

---

## 정적 라우팅: 수동 설정

라우팅 테이블을 채우는 방법은 크게 두 가지가 있습니다.

<br>

첫 번째는 **정적 라우팅(Static Routing)**으로, 관리자가 직접 경로를 입력하는 방식입니다.

```bash
# Linux에서 정적 경로 추가
ip route add 10.0.0.0/8 via 192.168.1.1
```

<br>

정적 라우팅은 다음과 같은 특성을 지닙니다.

- **단순함**: 한 번 설정하면 변하지 않음
- **예측 가능**: 항상 동일한 경로를 사용
- **오버헤드 없음**: 라우팅 프로토콜 메시지가 필요 없어 대역폭 절약
- **확장성 부족**: 네트워크 규모가 커지면 관리 부담이 급증
- **장애 대응 불가**: 경로에 문제가 생겨도 자동으로 우회하지 못함

---

## 동적 라우팅: 자동 학습

반면 **동적 라우팅(Dynamic Routing)**은 라우터들이 서로 정보를 교환하여 자동으로 경로를 학습하는 방식입니다.

<br>

동적 라우팅의 동작 흐름은 다음과 같습니다.

1. 라우터가 자신이 연결된 네트워크 정보를 이웃에게 알림
2. 이웃 라우터는 이 정보를 받아 자신의 테이블을 업데이트
3. 업데이트된 정보를 다시 다른 이웃에게 전파
4. 이 과정이 반복되어 네트워크 전체가 동일한 라우팅 정보를 갖게 됨

<br>

여기서 **수렴(Convergence)**이란 모든 라우터가 일관된 라우팅 정보를 갖게 된 상태를 말합니다. 수렴이 완료되기 전에는 라우터마다 다른 정보를 보유할 수 있어 루프가 발생할 위험이 있습니다.

<br>

동적 라우팅의 특성은 다음과 같습니다.

- **자동화**: 네트워크 변화에 자동으로 대응
- **장애 복구**: 경로 장애 발생 시 우회 경로를 자동 선택
- **확장성**: 대규모 네트워크를 효과적으로 지원
- **오버헤드**: 라우팅 프로토콜 메시지가 대역폭을 소비
- **복잡성**: 설정과 디버깅이 상대적으로 어려움

---

## 정적 vs 동적: 언제 무엇을 선택할까

두 방식의 특성을 이해했다면, 이제 실제 상황에서 어떤 것을 선택해야 할지 알아보겠습니다.

<br>

**정적 라우팅이 적합한 상황:**

| 상황 | 이유 |
|------|------|
| 소규모 네트워크 (라우터 2~3대) | 관리할 경로가 적어 수동 설정이 부담되지 않음 |
| 스텁 네트워크 (출구가 하나뿐) | 어차피 모든 트래픽이 한 곳으로 가므로 동적 라우팅이 불필요 |
| 보안이 중요한 환경 | 경로를 고정하여 예측 불가능한 경로 변경 방지 |
| 대역폭이 제한된 링크 | 라우팅 프로토콜 트래픽으로 인한 오버헤드 제거 |
| 백업 경로 설정 | 동적 경로가 실패했을 때 사용할 대체 경로 지정 |

<br>

**동적 라우팅이 적합한 상황:**

| 상황 | 이유 |
|------|------|
| 중대형 네트워크 | 수백 개의 경로를 수동으로 관리하기 어려움 |
| 네트워크 변경이 잦은 환경 | 토폴로지 변화에 자동 대응 가능 |
| 고가용성이 필요한 환경 | 장애 발생 시 자동으로 우회 경로 선택 |
| 다중 경로가 존재하는 환경 | 최적 경로를 자동으로 계산하고 부하 분산 가능 |
| 여러 관리자가 관여하는 환경 | 일관된 라우팅 정책 유지가 용이 |

<br>

**실무에서의 일반적인 조합:**

실제 환경에서는 정적 라우팅과 동적 라우팅을 함께 사용하는 경우가 많습니다. 예를 들어 기업 네트워크의 코어에서는 OSPF 같은 동적 프로토콜을 사용하면서, 인터넷으로 나가는 기본 경로는 정적으로 설정하는 식입니다.

```
내부 네트워크: 동적 라우팅 (OSPF)으로 자동 학습
외부 연결: 정적 기본 경로 (0.0.0.0/0 → ISP 게이트웨이)
백업 링크: 정적 경로로 설정하되 높은 메트릭 부여
```

<br>

이런 하이브리드 접근법을 통해 각 방식의 장점을 취하면서 단점을 보완할 수 있습니다.

---

## 관리 거리: 어떤 정보를 신뢰할 것인가

동적 라우팅을 사용하다 보면 같은 목적지에 대해 여러 소스에서 경로 정보를 받는 상황이 발생합니다. 정적 경로, RIP, OSPF, BGP 등이 각각 다른 다음 홉을 알려줄 수 있기 때문입니다.

<br>

그렇다면 어떤 정보를 믿어야 할까요?

<br>

이 문제를 해결하기 위해 **관리 거리(Administrative Distance, AD)**라는 개념이 도입되었습니다. 라우팅 정보 소스의 신뢰도를 숫자로 나타낸 것으로, 값이 낮을수록 더 신뢰합니다.

<br>

```
소스                관리 거리
─────────────────────────────
직접 연결            0
정적 경로            1
EIGRP (내부)        90
OSPF               110
RIP                120
EIGRP (외부)       170
iBGP               200
알 수 없음          255
```

<br>

구체적인 예를 들어보겠습니다.

- 정적 경로로 10.0.0.0/8 → 192.168.1.1 (AD=1)
- RIP로 10.0.0.0/8 → 192.168.1.2 (AD=120)

이 경우 AD 값이 더 낮은 정적 경로가 선택됩니다.

<br>

참고로 AD=255는 "사용하지 않음"을 의미하며, 이런 경로는 라우팅 테이블에 설치되지 않습니다.

<br>

직접 연결(AD=0)이 가장 높은 신뢰도를 갖는 이유는 간단합니다. 라우터 자신의 인터페이스에 연결된 네트워크이므로 정보가 틀릴 가능성이 없기 때문입니다.

---

## 메트릭: 어떤 경로가 더 좋은가

같은 소스(같은 AD)에서 같은 목적지로 가는 여러 경로가 있다면 어떻게 할까요? 이때는 **메트릭(Metric)**으로 비교합니다.

<br>

메트릭은 경로의 "비용"을 수치화한 것입니다. 다만 라우팅 프로토콜마다 메트릭을 계산하는 기준이 다릅니다.

<br>

```
프로토콜    메트릭 기준
───────────────────────────────────────
RIP        홉 수 (거치는 라우터 수)
OSPF       비용 (대역폭 기반)
EIGRP      복합 메트릭 (대역폭, 지연, 신뢰성, 부하)
BGP        경로 속성 조합
```

<br>

**RIP**는 단순히 홉 수만 셉니다. 예를 들어 A → B → C → D는 3홉이고, A → E → D는 2홉이라면 RIP는 2홉 경로를 선택합니다.

<br>

그러나 여기에는 문제가 있습니다. 홉 수가 실제 경로 품질을 반영하지 못한다는 점입니다. 만약 A → E 구간이 56kbps 링크이고, A → B → C → D 구간이 모두 1Gbps 링크라면 어떨까요? RIP는 여전히 느린 2홉 경로를 선택하게 됩니다.

<br>

반면 **OSPF**는 대역폭 기반 비용을 사용합니다. 기본 공식은 "비용 = 참조 대역폭 / 인터페이스 대역폭"입니다.

<br>

참조 대역폭이 100Mbps인 경우를 살펴보면:
- 100Mbps 링크: 비용 = 1
- 10Mbps 링크: 비용 = 10
- 1Gbps 링크: 비용 = 0.1 → 1 (최소값 적용)

<br>

OSPF는 비용의 합이 가장 작은 경로를 선택하므로, 결과적으로 대역폭이 높은 경로가 선호됩니다.

---

## 라우팅 루프: 패킷이 빙빙 돈다

동적 라우팅에서 가장 주의해야 할 위험 요소는 **라우팅 루프(Routing Loop)**입니다.

<br>

```
라우터 A: 10.0.0.0으로 가려면 B로 보내라
라우터 B: 10.0.0.0으로 가려면 A로 보내라
```

이 상태에서 10.0.0.0으로 향하는 패킷은 A → B → A → B → ... 식으로 무한 반복하게 됩니다.

<br>

왜 이런 상황이 발생할까요? 네트워크 토폴로지가 변경되었을 때 모든 라우터가 동시에 정보를 업데이트하지 못하기 때문입니다.

<br>

구체적인 상황을 살펴보겠습니다. 10.0.0.0 네트워크에 직접 연결된 라우터 C가 있다고 가정합니다.

```
     ┌───────┐
     │   C   │── 10.0.0.0/8
     └───────┘
         │
     ┌───────┐
     │   A   │
     └───────┘
         │
     ┌───────┐
     │   B   │
     └───────┘
```

<br>

이 상태에서 C와 A 사이의 링크가 끊어졌다고 해봅시다. A는 C를 통한 경로가 사라진 것을 알지만, B는 아직 이 사실을 모릅니다.

<br>

B는 여전히 "10.0.0.0으로 가려면 A로 보내라"라고 알고 있고, A는 대안 경로를 찾다가 B의 정보를 보고 "B를 통해 갈 수 있구나"라고 잘못 판단합니다. 이렇게 루프가 형성됩니다.

<br>

이 문제를 해결하기 위한 여러 메커니즘이 존재하며, [Part 2](/dev/network/Routing-2/)에서 자세히 다루겠습니다.

---

## TTL: 루프의 피해를 제한하다

다행히 루프가 발생하더라도 패킷이 영원히 도는 것은 아닙니다. IP 헤더에 포함된 **TTL(Time To Live)** 필드가 이를 방지해 줍니다.

<br>

TTL은 패킷이 거칠 수 있는 최대 홉 수를 나타내며, 일반적으로 64, 128, 또는 255로 시작합니다. 패킷이 라우터를 지날 때마다 TTL이 1씩 감소하고, 0이 되면 해당 패킷은 폐기됩니다.

<br>

따라서 루프가 발생하더라도 패킷은 최대 TTL 횟수만큼만 돌게 되어 무한 루프로 인한 네트워크 마비를 방지할 수 있습니다.

<br>

TTL이 0이 되어 패킷을 폐기할 때, 라우터는 송신자에게 ICMP Time Exceeded 메시지를 전송합니다. 네트워크 경로를 추적하는 `traceroute` 명령어가 바로 이 메커니즘을 활용합니다.

---

## 라우팅 프로토콜의 분류

동적 라우팅 프로토콜은 여러 기준에 따라 분류할 수 있습니다.

<br>

**알고리즘에 따른 분류:**

- **거리 벡터(Distance Vector)**: 이웃에게 자신의 전체 라우팅 테이블을 전송하는 방식
- **링크 상태(Link State)**: 네트워크 토폴로지 전체를 공유하고 각 라우터가 개별적으로 경로를 계산
- **경로 벡터(Path Vector)**: BGP에서 사용하며, 전체 경로 정보를 포함

<br>

**적용 범위에 따른 분류:**

- **IGP(Interior Gateway Protocol)**: 하나의 자율 시스템(AS) 내부에서 사용
  - RIP, OSPF, EIGRP, IS-IS
- **EGP(Exterior Gateway Protocol)**: 자율 시스템 간 통신에 사용
  - BGP

<br>

IGP와 EGP의 차이는 매우 중요합니다. 하나의 조직 내부에서는 기술적으로 최적인 경로를 찾는 것이 목표인 반면, 조직 간에는 정책적 고려사항(누구를 경유할 것인가, 어떤 경로를 광고할 것인가)이 더 중요해집니다.

<br>

이어지는 [Part 2](/dev/network/Routing-2/)에서 거리 벡터와 링크 상태 알고리즘의 동작 원리를 자세히 살펴보고, [Part 3](/dev/network/Routing-3/)에서 BGP와 인터넷의 구조를 알아보겠습니다.

---

## 라우팅의 핵심 원리

지금까지 살펴본 라우팅의 핵심 원리를 정리하면 다음과 같습니다.

1. **분산 시스템**: 중앙 제어 없이 각 라우터가 독립적으로 결정
2. **집계(Aggregation)**: CIDR로 네트워크를 그룹화하여 테이블 크기 감소
3. **최장 접두사 매칭**: 가장 구체적인 경로 선택
4. **신뢰도와 비용**: AD로 소스 신뢰도를, 메트릭으로 경로 비용을 평가
5. **수렴**: 네트워크 변화 후 일관된 상태에 도달

<br>

이러한 원리들이 수십억 기기가 연결된 인터넷을 가능하게 합니다. 중앙에서 모든 경로를 관리하는 것은 사실상 불가능하므로, 분산된 라우터들이 서로 협력하여 패킷을 목적지까지 전달하는 것입니다.

---

**관련 글**
- [네트워크 통신의 원리 (3) - 프로토콜 스택과 데이터 흐름](/dev/network/NetworkCommunication-3/)
- [IP 주소(IP Address)의 개념과 구조](/dev/network/IPAddress/)
- [서브넷(Subnet)의 개념과 서브네팅](/dev/network/Subnet/)
- [라우팅과 인터넷 구조 (2) - 라우팅 알고리즘](/dev/network/Routing-2/)
- [라우팅과 인터넷 구조 (3) - BGP와 인터넷의 구조](/dev/network/Routing-3/)
