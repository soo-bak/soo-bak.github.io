---
layout: single
title: "라우팅과 인터넷 구조 (1) - 라우팅의 기본 원리 - soo:bak"
date: "2026-01-19 23:11:01 +0900"
description: 라우팅의 역사, 라우팅 테이블 구조, 최장 접두사 매칭, 정적 라우팅과 동적 라우팅을 설명합니다.
tags:
  - 네트워크
  - 라우팅
  - IP
  - 라우터
---

## 패킷은 어떻게 목적지를 찾아가는가

[네트워크 통신의 원리 (3)](/dev/network/NetworkCommunication-3/)에서 라우터의 기본 개념을 살펴보았습니다.

라우터는 패킷의 목적지 IP 주소를 보고 다음 홉(next hop)을 결정합니다.

<br>

하지만 라우터는 어떻게 다음 홉을 알까요?

인터넷에는 수십억 개의 IP 주소가 있습니다.

라우터가 모든 주소를 개별적으로 기억할 수는 없습니다.

<br>

이 질문에 답하려면 라우팅의 역사로 돌아가야 합니다.

---

## ARPANET: 분산 라우팅의 탄생

1969년, 인터넷의 전신인 **ARPANET**이 시작됩니다.

미국 국방부 고등연구계획국(DARPA)이 자금을 지원했습니다.

<br>

ARPANET의 설계 목표는 **생존성(survivability)**이었습니다.

핵 공격으로 일부 노드가 파괴되어도 나머지가 계속 동작해야 했습니다.

이를 위해 **분산 라우팅(distributed routing)**을 채택했습니다.

<br>

중앙 제어 장치가 없습니다.

각 노드가 독립적으로 경로를 결정합니다.

일부 노드가 사라져도 나머지가 자동으로 우회 경로를 찾습니다.

<br>

ARPANET의 노드는 **IMP(Interface Message Processor)**라고 불렸습니다.

IMP는 오늘날의 라우터 역할을 했습니다.

<br>

초기 ARPANET은 단순한 알고리즘을 사용했습니다.

각 IMP는 이웃과 정보를 교환하며 최단 경로를 계산했습니다.

이것이 라우팅 알고리즘의 시작입니다.

---

## 라우팅 테이블: 경로의 지도

라우터의 핵심은 **라우팅 테이블(Routing Table)**입니다.

목적지로 가기 위해 어디로 보내야 하는지를 기록한 표입니다.

<br>

라우팅 테이블의 기본 구조:

```
목적지 네트워크        다음 홉           인터페이스    메트릭
────────────────────────────────────────────────────────────
192.168.1.0/24        직접 연결          eth0         0
10.0.0.0/8           192.168.1.1        eth0         1
172.16.0.0/16        192.168.1.2        eth0         2
0.0.0.0/0            192.168.1.254      eth0         1
```

<br>

각 항목의 의미:

**목적지 네트워크**: 어디로 가는 패킷인가

**다음 홉(Next Hop)**: 그 패킷을 어디로 전달해야 하는가

**인터페이스**: 어느 네트워크 인터페이스로 내보내는가

**메트릭(Metric)**: 이 경로의 비용은 얼마인가

<br>

중요한 점은 **목적지가 개별 IP가 아니라 네트워크**라는 것입니다.

192.168.1.0/24는 192.168.1.0부터 192.168.1.255까지 256개의 주소를 포함합니다.

[서브넷(Subnet)](/dev/network/Subnet/)에서 설명한 CIDR 표기법입니다.

<br>

덕분에 수십억 개의 IP 주소를 수십만 개의 네트워크 항목으로 압축할 수 있습니다.

---

## 최장 접두사 매칭: 가장 구체적인 경로 선택

패킷이 도착하면 라우터는 목적지 IP와 일치하는 항목을 찾습니다.

문제는 여러 항목이 일치할 수 있다는 것입니다.

<br>

예를 들어 목적지가 10.1.2.3이라면:

```
10.0.0.0/8        → 일치 (10.x.x.x 모두 포함)
10.1.0.0/16       → 일치 (10.1.x.x 모두 포함)
10.1.2.0/24       → 일치 (10.1.2.x 모두 포함)
0.0.0.0/0         → 일치 (모든 주소 포함)
```

<br>

어떤 것을 선택해야 할까요?

<br>

**최장 접두사 매칭(Longest Prefix Match)**을 사용합니다.

가장 구체적인(접두사가 가장 긴) 항목을 선택합니다.

<br>

위 예시에서는 /24가 가장 길므로 10.1.2.0/24를 선택합니다.

<br>

왜 이렇게 할까요?

더 긴 접두사는 더 구체적인 목적지를 의미합니다.

네트워크 관리자가 특정 서브넷에 대해 다른 경로를 지정했다면, 그것을 존중해야 합니다.

<br>

0.0.0.0/0은 **기본 경로(Default Route)**입니다.

모든 IP와 일치하지만, 접두사 길이가 0입니다.

다른 어떤 항목도 일치하지 않을 때만 사용됩니다.

<br>

기본 경로가 있으면 라우터는 "모르는 목적지"에 대해서도 패킷을 전달할 수 있습니다.

가정용 공유기에서 ISP의 게이트웨이를 기본 경로로 설정하는 것이 그 예입니다.

---

## 정적 라우팅: 수동 설정

라우팅 테이블을 채우는 방법은 두 가지입니다.

<br>

**정적 라우팅(Static Routing)**은 관리자가 직접 경로를 입력합니다.

```bash
# Linux에서 정적 경로 추가
ip route add 10.0.0.0/8 via 192.168.1.1
```

<br>

정적 라우팅의 특성:

- 단순함: 설정하면 변하지 않음
- 예측 가능: 항상 같은 경로 사용
- 오버헤드 없음: 라우팅 프로토콜 메시지가 필요 없음
- 확장성 부족: 네트워크가 커지면 관리가 어려움
- 장애 대응 불가: 경로에 문제가 생겨도 자동으로 우회하지 않음

<br>

정적 라우팅이 적합한 경우:

- 작은 네트워크
- 경로가 하나뿐인 스텁 네트워크(Stub Network)
- 보안상 경로를 고정해야 하는 경우
- 백업 경로로 사용 (동적 경로가 실패할 때)

---

## 동적 라우팅: 자동 학습

**동적 라우팅(Dynamic Routing)**은 라우터들이 서로 정보를 교환하여 자동으로 경로를 학습합니다.

<br>

동적 라우팅의 흐름:

1. 라우터가 자신이 연결된 네트워크 정보를 이웃에게 알림
2. 이웃 라우터는 이 정보를 받아서 테이블을 업데이트
3. 업데이트된 정보를 다시 다른 이웃에게 전파
4. 네트워크 전체가 동일한 라우팅 정보를 갖게 됨 (수렴)

<br>

**수렴(Convergence)**은 모든 라우터가 일관된 라우팅 정보를 갖게 되는 상태입니다.

수렴 전에는 라우터마다 다른 정보를 가질 수 있어 루프가 발생할 수 있습니다.

<br>

동적 라우팅의 특성:

- 자동화: 네트워크 변화에 자동 대응
- 장애 복구: 경로 장애 시 우회 경로 자동 선택
- 확장성: 대규모 네트워크 지원
- 오버헤드: 라우팅 프로토콜 메시지가 대역폭 소비
- 복잡성: 설정과 디버깅이 더 어려움

---

## 관리 거리: 어떤 정보를 신뢰할 것인가

같은 목적지에 대해 여러 소스에서 경로 정보를 받을 수 있습니다.

정적 경로, RIP, OSPF, BGP 등이 모두 다른 다음 홉을 알려줄 수 있습니다.

<br>

어떤 것을 믿어야 할까요?

<br>

**관리 거리(Administrative Distance, AD)**는 라우팅 정보 소스의 신뢰도를 나타냅니다.

값이 낮을수록 더 신뢰합니다.

<br>

```
소스                관리 거리
─────────────────────────────
직접 연결            0
정적 경로            1
EIGRP (내부)        90
OSPF               110
RIP                120
EIGRP (외부)       170
iBGP               200
알 수 없음          255
```

<br>

예를 들어:

- 정적 경로로 10.0.0.0/8 → 192.168.1.1 (AD=1)
- RIP로 10.0.0.0/8 → 192.168.1.2 (AD=120)

이 경우 정적 경로가 선택됩니다. AD가 더 낮기 때문입니다.

<br>

AD=255는 "사용하지 않음"을 의미합니다.

이 경로는 테이블에 설치되지 않습니다.

<br>

직접 연결(AD=0)은 가장 신뢰됩니다.

라우터 자신의 인터페이스에 연결된 네트워크이므로 틀릴 수가 없습니다.

---

## 메트릭: 어떤 경로가 더 좋은가

같은 소스(같은 AD)에서 같은 목적지로 가는 여러 경로가 있다면?

**메트릭(Metric)**으로 비교합니다.

<br>

메트릭은 경로의 "비용"입니다.

라우팅 프로토콜마다 메트릭의 의미가 다릅니다.

<br>

```
프로토콜    메트릭 기준
───────────────────────────────────────
RIP        홉 수 (거치는 라우터 수)
OSPF       비용 (대역폭 기반)
EIGRP      복합 메트릭 (대역폭, 지연, 신뢰성, 부하)
BGP        경로 속성 조합
```

<br>

**RIP**는 단순히 홉 수를 셉니다.

A → B → C → D는 3홉입니다.

A → E → D는 2홉입니다.

RIP는 2홉 경로를 선택합니다.

<br>

문제는 홉 수가 실제 품질을 반영하지 않는다는 것입니다.

A → E가 56kbps 링크이고, A → B → C → D가 모두 1Gbps 링크라면?

RIP는 여전히 느린 2홉 경로를 선택합니다.

<br>

**OSPF**는 대역폭 기반 비용을 사용합니다.

기본 공식: 비용 = 참조 대역폭 / 인터페이스 대역폭

<br>

참조 대역폭이 100Mbps라면:
- 100Mbps 링크: 비용 = 1
- 10Mbps 링크: 비용 = 10
- 1Gbps 링크: 비용 = 0.1 → 1 (최소값)

<br>

OSPF는 비용의 합이 가장 작은 경로를 선택합니다.

대역폭이 높은 경로가 선호됩니다.

---

## 라우팅 루프: 패킷이 빙빙 돈다

동적 라우팅의 가장 큰 위험은 **라우팅 루프(Routing Loop)**입니다.

<br>

```
라우터 A: 10.0.0.0으로 가려면 B로 보내라
라우터 B: 10.0.0.0으로 가려면 A로 보내라
```

이 상태에서 10.0.0.0으로 가는 패킷은 A → B → A → B → ... 무한 반복합니다.

<br>

왜 이런 일이 생길까요?

네트워크 토폴로지가 변경되었을 때, 모든 라우터가 동시에 업데이트되지 않기 때문입니다.

<br>

10.0.0.0에 직접 연결된 라우터 C가 있었다고 합시다.

```
     ┌───────┐
     │   C   │── 10.0.0.0/8
     └───────┘
         │
     ┌───────┐
     │   A   │
     └───────┘
         │
     ┌───────┐
     │   B   │
     └───────┘
```

<br>

C와 A 사이 링크가 끊어졌습니다.

A는 C를 통한 경로가 사라진 것을 압니다.

하지만 B는 아직 모릅니다.

<br>

B는 여전히 "10.0.0.0으로 가려면 A로"라고 알고 있습니다.

A는 대안 경로를 찾다가 B의 정보를 보고 "B를 통해 갈 수 있구나"라고 잘못 판단합니다.

루프가 형성됩니다.

<br>

이 문제를 해결하기 위한 여러 메커니즘이 있습니다.

[Part 2](/dev/network/Routing-2/)에서 자세히 살펴봅니다.

---

## TTL: 루프의 피해를 제한하다

루프가 발생해도 패킷이 영원히 돌지는 않습니다.

IP 헤더의 **TTL(Time To Live)** 필드 덕분입니다.

<br>

TTL은 패킷이 거칠 수 있는 최대 홉 수입니다.

보통 64, 128, 또는 255로 시작합니다.

<br>

라우터를 지날 때마다 TTL이 1씩 감소합니다.

TTL이 0이 되면 패킷을 폐기합니다.

<br>

루프가 있더라도 최대 TTL 횟수만큼만 돕니다.

무한 루프로 네트워크가 마비되는 것을 방지합니다.

<br>

TTL이 0이 되어 패킷을 폐기할 때, 라우터는 송신자에게 ICMP Time Exceeded 메시지를 보냅니다.

`traceroute` 명령어가 이 메커니즘을 활용합니다.

---

## 라우팅 프로토콜의 분류

동적 라우팅 프로토콜은 여러 기준으로 분류됩니다.

<br>

**알고리즘에 따른 분류:**

- **거리 벡터(Distance Vector)**: 이웃에게 자신의 전체 라우팅 테이블 전송
- **링크 상태(Link State)**: 네트워크 토폴로지 전체를 공유하고 각자 계산
- **경로 벡터(Path Vector)**: BGP에서 사용, 전체 경로 정보 포함

<br>

**적용 범위에 따른 분류:**

- **IGP(Interior Gateway Protocol)**: 하나의 자율 시스템(AS) 내부
  - RIP, OSPF, EIGRP, IS-IS
- **EGP(Exterior Gateway Protocol)**: 자율 시스템 간
  - BGP

<br>

IGP와 EGP의 차이는 중요합니다.

하나의 조직 내부에서는 최적 경로를 찾는 것이 목표입니다.

조직 간에는 정책(누구를 경유할 것인가, 어떤 경로를 광고할 것인가)이 중요합니다.

<br>

[Part 2](/dev/network/Routing-2/)에서 거리 벡터와 링크 상태 알고리즘을 자세히 살펴보고,

[Part 3](/dev/network/Routing-3/)에서 BGP와 인터넷의 구조를 알아봅니다.

---

## 라우팅의 핵심 원리

라우팅을 요약하면:

1. **분산 시스템**: 중앙 제어 없이 각 라우터가 독립적으로 결정
2. **집계(Aggregation)**: CIDR로 네트워크를 그룹화하여 테이블 크기 감소
3. **최장 접두사 매칭**: 가장 구체적인 경로 선택
4. **신뢰도와 비용**: AD로 소스 신뢰도, 메트릭으로 경로 비용 평가
5. **수렴**: 네트워크 변화 후 일관된 상태에 도달

<br>

이 원리들이 수십억 기기가 연결된 인터넷을 가능하게 합니다.

중앙에서 모든 경로를 관리하는 것은 불가능합니다.

분산된 라우터들이 협력하여 패킷을 목적지로 전달합니다.

---

**관련 글**
- [네트워크 통신의 원리 (3) - 프로토콜 스택과 데이터 흐름](/dev/network/NetworkCommunication-3/)
- [IP 주소(IP Address)의 개념과 구조](/dev/network/IPAddress/)
- [서브넷(Subnet)의 개념과 서브네팅](/dev/network/Subnet/)
- [라우팅과 인터넷 구조 (2) - 라우팅 알고리즘](/dev/network/Routing-2/)
- [라우팅과 인터넷 구조 (3) - BGP와 인터넷의 구조](/dev/network/Routing-3/)
