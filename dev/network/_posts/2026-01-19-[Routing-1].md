---
layout: single
title: "라우팅과 인터넷 구조 (1) - 라우팅의 기본 원리 - soo:bak"
date: "2026-01-19 23:11:01 +0900"
description: 라우팅의 역사, 라우팅 테이블 구조, 최장 접두사 매칭, 정적 라우팅과 동적 라우팅을 설명합니다.
tags:
  - 네트워크
  - 라우팅
  - IP
  - 라우터
---

## 패킷은 어떻게 목적지를 찾아가는가

[네트워크 통신의 원리 (3)](/dev/network/NetworkCommunication-3/)에서 라우터가 패킷의 목적지 IP 주소를 확인하고 다음 홉(next hop)을 결정한다고 했습니다.

<br>

라우터는 다음 홉을 어떻게 알까요? 인터넷에는 수십억 개의 IP 주소가 존재합니다. 모든 주소를 개별적으로 기억할 수는 없습니다. 이 문제는 인터넷이 처음 만들어질 때부터 있었습니다.

---

## ARPANET: 분산 라우팅의 탄생

1969년, 인터넷의 전신인 **ARPANET**이 시작되었습니다. 미국 국방부 고등연구계획국(DARPA)이 자금을 지원했고, 핵심 목표는 **생존성(survivability)**이었습니다. 핵 공격으로 일부 노드가 파괴되더라도 나머지 네트워크가 계속 동작해야 했습니다.

<br>

만약 중앙 제어 장치가 모든 경로를 관리한다면, 그 장치가 파괴되는 순간 전체 네트워크가 마비됩니다. 그래서 ARPANET은 **분산 라우팅(distributed routing)** 방식을 채택했습니다.

<br>

각 노드는 자신과 직접 연결된 이웃 노드들을 알고 있습니다. 이웃끼리 "나는 어디와 연결되어 있다"는 정보를 주고받으면, 네트워크 전체의 연결 상태를 파악할 수 있습니다. 이 정보를 바탕으로 각 노드가 스스로 경로를 결정합니다. 일부 노드가 사라지면 이웃들이 "저 노드가 응답이 없다"는 것을 감지하고, 다른 경로를 찾습니다.

<br>

ARPANET에서 이 노드를 **IMP(Interface Message Processor)**라고 불렀습니다. 각 대학이나 연구기관에 IMP가 설치되었고, IMP끼리 연결되어 네트워크를 형성했습니다. IMP는 패킷을 받으면 목적지를 확인하고 다음 IMP로 전달했습니다. 오늘날 라우터가 하는 일과 같습니다.

---

## 라우팅 테이블: 경로의 지도

라우터는 두 가지 일을 합니다. 하나는 이웃과 경로 정보를 주고받아 **라우팅 테이블(Routing Table)**을 유지하는 것입니다. 다른 하나는 패킷이 도착하면 이 테이블을 조회해서 다음 라우터로 전달하는 것입니다. 두 과정은 독립적으로 동작합니다.

<br>

다음과 같은 네트워크 구조가 있다고 가정합니다.

```
                         인터넷
                           │
                    ┌──────┴──────┐
                    │192.168.1.254│
                    └──────┬──────┘
                           │
    ┌──────────────────────┼──────────────────────┐
    │                      │                      │
    │              192.168.1.0/24                 │
    │                      │                      │
┌───┴────┐          ┌──────┴──────┐         ┌─────┴────┐
│192.168.│          │  이 라우터   │         │192.168.  │
│1.1     │          │   (eth0)    │         │1.2       │
└───┬────┘          └─────────────┘         └─────┬────┘
    │                                             │
    ↓                                             ↓
10.0.0.0/8                                  172.16.0.0/16
```

<br>

"이 라우터"의 라우팅 테이블입니다.

```
목적지 네트워크        다음 홉           인터페이스    메트릭
────────────────────────────────────────────────────────────
192.168.1.0/24        직접 연결          eth0         0
10.0.0.0/8           192.168.1.1        eth0         1
172.16.0.0/16        192.168.1.2        eth0         2
0.0.0.0/0            192.168.1.254      eth0         1
```

<br>

테이블을 읽는 방법입니다. 10.0.0.0/8 행을 예로 들면:
- **목적지 네트워크** 10.0.0.0/8: 10.x.x.x로 가는 패킷에 이 경로를 적용
- **다음 홉** 192.168.1.1: 이 패킷을 192.168.1.1 라우터로 전달
- **인터페이스** eth0: 라우터에는 케이블이 연결되는 곳이 여러 개 있고, 각각 eth0, eth1 같은 이름이 붙음. 이 패킷은 eth0으로 내보냄
- **메트릭** 1: 이 경로의 비용. 같은 목적지로 가는 경로가 여러 개면 낮은 값을 선택

192.168.1.0/24 행은 "직접 연결"입니다. 이 라우터가 해당 네트워크에 직접 연결되어 있으므로 다른 라우터를 거칠 필요가 없습니다.

<br>

테이블의 목적지가 10.1.2.3 같은 개별 IP가 아니라 10.0.0.0/8 같은 **네트워크 단위**입니다. 10.0.0.0/8은 10.0.0.0부터 10.255.255.255까지 약 1,600만 개 주소를 포함합니다. 개별 IP마다 경로를 저장하면 테이블이 수십억 행이 되지만, 네트워크 단위로 묶으면 수십만 행으로 줄어듭니다. 이 표기법은 [서브넷(Subnet)](/dev/network/Subnet/)에서 설명한 CIDR입니다.

---

## 최장 접두사 매칭: 가장 구체적인 경로 선택

패킷이 도착하면 라우터는 목적지 IP와 일치하는 항목을 라우팅 테이블에서 찾습니다.

<br>

라우팅 테이블에 다음 네 개의 항목이 있고, 목적지가 10.1.2.3인 패킷이 도착했다고 가정합니다.

```
10.0.0.0/8        → 10.x.x.x 모두 포함
10.1.0.0/16       → 10.1.x.x 모두 포함
10.1.2.0/24       → 10.1.2.x 모두 포함
0.0.0.0/0         → 모든 주소 포함
```

네 항목 모두 10.1.2.3을 포함합니다. 네트워크 단위로 저장하기 때문에 이런 상황이 생깁니다.

<br>

라우터는 이 중에서 접두사가 가장 긴 항목을 선택합니다. /8, /16, /24에서 숫자가 접두사 길이입니다. 숫자가 클수록 더 많은 비트를 고정하므로 범위가 좁아집니다. /8은 약 1,600만 개 주소를 포함하고, /24는 256개만 포함합니다. 위 예시에서는 /24가 가장 크니까 10.1.2.0/24가 선택됩니다. 이를 **최장 접두사 매칭(Longest Prefix Match)**이라 합니다.

<br>

0.0.0.0/0은 **기본 경로(Default Route)**입니다. 접두사 길이가 0이라 모든 IP와 일치하지만, 최장 접두사 매칭에서 항상 마지막 순위가 됩니다. 더 구체적인 경로가 없을 때만 사용됩니다.

<br>

집에서 google.com에 접속하는 상황입니다.

```
                    인터넷
                      │
              ┌───────┴───────┐
              │ KT/SK 라우터   │
              └───────┬───────┘
                      │
              ┌───────┴───────┐
              │   공유기       │
              └───────┬───────┘
                      │
        ┌─────────────┼─────────────┐
        │             │             │
    컴퓨터         스마트폰        태블릿
```

가정용 공유기도 라우터입니다. 공유기의 라우팅 테이블을 보면:

```
목적지 네트워크        다음 홉
─────────────────────────────────
192.168.0.0/24        직접 연결     ← 집 안 장치들
0.0.0.0/0             KT/SK 라우터  ← 기본 경로
```

컴퓨터가 google.com(142.250.196.110)에 접속하려고 합니다. 공유기는 이 IP를 라우팅 테이블에서 찾습니다. 192.168.0.0/24에는 포함되지 않습니다. 하지만 0.0.0.0/0에는 포함됩니다. 기본 경로가 KT/SK 라우터를 가리키고 있으니, 패킷을 그쪽으로 보냅니다. 이후는 인터넷 회사의 라우터들이 처리합니다.

---

## 정적 라우팅과 동적 라우팅

앞서 라우터가 이웃과 경로 정보를 교환한다고 했습니다. 이것이 **동적 라우팅(Dynamic Routing)**입니다. 하지만 모든 경로를 이렇게 학습하지는 않습니다. 관리자가 직접 입력하는 방법도 있습니다. 이것이 **정적 라우팅(Static Routing)**입니다.

<br>

### 정적 라우팅

관리자가 직접 라우팅 테이블에 경로를 추가합니다. Linux에서는 다음과 같이 합니다.

```bash
ip route add 10.0.0.0/8 via 192.168.1.1
```

이 명령은 "10.x.x.x로 가는 패킷은 192.168.1.1로 보내라"는 의미입니다.

<br>

정적 라우팅은 단순합니다. 한 번 설정하면 변하지 않고, 항상 같은 경로를 사용합니다. 하지만 네트워크가 커지면 관리자가 모든 경로를 직접 입력해야 합니다. 경로에 문제가 생겨도 자동으로 우회하지 못합니다. 관리자가 직접 수정해야 합니다.

<br>

### 동적 라우팅

동적 라우팅은 라우터들이 서로 경로 정보를 주고받아 자동으로 학습합니다. ARPANET에서 설명한 방식입니다.

<br>

```
라우터 A ─── 라우터 B ─── 라우터 C
   │
10.0.0.0/8
```

1. 라우터 A는 10.0.0.0/8에 직접 연결되어 있음
2. A가 B에게 이 정보를 전송
3. B는 자신의 테이블에 "10.0.0.0/8 → A" 추가
4. B가 C에게 이 정보를 전파
5. C는 자신의 테이블에 "10.0.0.0/8 → B" 추가

이 과정이 반복되면 모든 라우터가 동일한 경로 정보를 갖게 됩니다. 이 상태를 **수렴(Convergence)**이라 합니다.

<br>

네트워크가 커져도 관리자가 경로를 입력할 필요가 없습니다. 라우터가 알아서 학습합니다. 라우터 A와 B 사이의 링크가 끊어지면 어떻게 될까요? B는 A에게서 더 이상 정보를 받지 못합니다. B는 테이블에서 A를 통한 경로를 삭제하고, 다른 이웃을 통한 우회 경로를 찾습니다.

<br>

대신 라우터들이 주기적으로 정보를 주고받아야 합니다. 네트워크 상태가 바뀌었는지 확인하기 위해서입니다. 이 메시지들이 네트워크 대역폭을 사용합니다. 정적 라우팅은 라우터끼리 메시지를 주고받지 않으므로 이런 오버헤드가 없습니다.

---

### 언제 무엇을 선택할까

**정적 라우팅**은 네트워크가 작고 단순할 때 적합합니다. 라우터가 2~3대이고, 경로가 거의 바뀌지 않는 환경입니다. 앞서 본 가정용 공유기의 기본 경로(0.0.0.0/0)도 정적 라우팅입니다. 출구가 하나뿐이라 동적으로 학습할 필요가 없습니다.

<br>

**동적 라우팅**은 네트워크가 크거나 자주 변경될 때 적합합니다. 라우터가 수십 대이고, 경로가 여러 개이며, 장애 시 자동 우회가 필요한 환경입니다.

<br>

실제 환경에서는 둘을 함께 사용합니다.

```
                         인터넷
                           │
                    ┌──────┴──────┐
                    │ 경계 라우터  │
                    └──────┬──────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────┴────┐       ┌─────┴─────┐      ┌─────┴────┐
   │ 라우터 A │───────│ 라우터 B  │──────│ 라우터 C │
   └────┬────┘       └─────┬─────┘      └─────┬────┘
        │                  │                  │
    영업부서            개발부서           관리부서
```

하나의 라우터가 정적 라우팅과 동적 라우팅을 동시에 사용할 수 있습니다. 라우터 A의 라우팅 테이블을 보면:

```
목적지              다음 홉          학습 방법
───────────────────────────────────────────────
영업부서 네트워크    직접 연결        -
개발부서 네트워크    라우터 B         동적 (이웃에게서 학습)
관리부서 네트워크    라우터 B         동적 (이웃에게서 학습)
0.0.0.0/0           경계 라우터      정적 (관리자가 설정)
```

내부 네트워크 경로는 자주 변경될 수 있어서 동적으로 학습합니다. 인터넷 출구는 경계 라우터 하나뿐이라 정적으로 설정합니다.

<br>

이렇게 각 방식의 장점을 취하면서 단점을 보완합니다.

---

### 관리 거리: 정적과 동적이 충돌하면?

앞서 하나의 라우터가 정적 라우팅과 동적 라우팅을 함께 사용한다고 했습니다. 그런데 같은 목적지에 대해 정적 경로와 동적 경로가 서로 다른 다음 홉을 알려주면 어떻게 될까요?

<br>

```
10.0.0.0/8 → 192.168.1.1 (정적으로 설정)
10.0.0.0/8 → 192.168.1.2 (동적으로 학습)
```

<br>

**관리 거리(Administrative Distance, AD)**가 우선순위를 결정합니다. 경로 소스의 신뢰도를 숫자로 나타낸 것으로, 값이 낮을수록 우선합니다.

```
소스                관리 거리
─────────────────────────────
직접 연결            0
정적 경로            1
동적 라우팅         90~200 (프로토콜마다 다름)
```

직접 연결(AD=0)이 가장 높은 우선순위입니다. 라우터 자신에게 연결된 네트워크이므로 틀릴 가능성이 없습니다. 정적 경로(AD=1)가 그 다음입니다. 관리자가 직접 설정했으므로 동적으로 학습한 경로보다 우선합니다.

<br>

위 예시에서는 정적 경로(AD=1)가 동적 경로보다 AD가 낮으므로, 192.168.1.1이 선택됩니다.

<br>

AD 값은 관리자가 변경할 수 있습니다. 정적 경로의 AD를 200으로 설정하면 어떻게 될까요? 동적 경로(AD=90~200)가 있을 때는 동적 경로가 우선됩니다. 동적 경로가 없을 때만 정적 경로가 사용됩니다. 이렇게 백업 경로를 만들 수 있습니다.

---

### 메트릭: 같은 방식으로 학습한 경로가 여러 개면?

관리 거리는 정적 경로와 동적 경로 중 어떤 것을 선택할지 결정합니다. 그런데 같은 방식으로 학습한 경로가 여러 개라면 어떻게 될까요?

<br>

```
A ──── B ──── D
 \           /
  \── E ────/
```

A에서 D로 가는 경로가 두 개입니다. A → B → D와 A → E → D. 둘 다 동적으로 학습했다면 AD는 같습니다. 이때 **메트릭(Metric)**으로 비교합니다.

<br>

메트릭은 경로의 비용입니다. 값이 낮을수록 좋은 경로입니다. 계산 방식은 라우팅 프로토콜마다 다릅니다.

<br>

가장 단순한 방식은 홉 수입니다. 거치는 라우터 수만 셉니다. A → E → D는 2홉, A → B → C → D는 3홉이면 2홉 경로를 선택합니다.

<br>

하지만 홉 수가 적다고 항상 좋은 경로는 아닙니다. A와 E 사이 회선이 56kbps이고, A → B → C → D 구간의 회선이 모두 1Gbps라면? 홉 수는 2홉이 적지만, 실제로는 3홉 경로가 훨씬 빠릅니다.

<br>

그래서 대역폭을 기준으로 메트릭을 계산하는 프로토콜도 있습니다. 대역폭이 높은 링크일수록 비용이 낮습니다. 이런 프로토콜은 A → B → D를 선택합니다. 구체적인 프로토콜과 계산 방식은 [Part 2](/dev/network/Routing-2/)에서 다룹니다.

---

---

## 라우팅 루프: 패킷이 빙빙 돈다

동적 라우팅에는 위험 요소가 있습니다. **라우팅 루프(Routing Loop)**입니다.

**정상 상태:**

```
     ┌───────┐
     │   C   │── 10.0.0.0/8
     └───────┘
         │  (연결됨)
     ┌───────┐
     │   A   │
     └───────┘
         │
     ┌───────┐
     │   B   │
     └───────┘

라우터 A: 10.0.0.0/8 → C
라우터 B: 10.0.0.0/8 → A
```

<br>

**C와 A 사이 회선이 끊어진 상태:**

```
     ┌───────┐
     │   C   │── 10.0.0.0/8
     └───────┘
         ✕  (끊어짐)
     ┌───────┐
     │   A   │  ← C로 가는 경로가 사라진 것을 앎
     └───────┘
         │
     ┌───────┐
     │   B   │  ← 아직 모름 (정보 교환에 시간이 걸림)
     └───────┘
```

<br>

B는 주기적으로 자신의 라우팅 정보를 이웃에게 보냅니다. B의 테이블에는 아직 "10.0.0.0/8 → A"가 있습니다. A는 B에게서 이 정보를 받습니다. A는 C로 가는 경로가 없으니, B를 통해 10.0.0.0/8에 갈 수 있다고 판단합니다. 하지만 B가 알고 있는 경로는 원래 A → C였습니다. C로 가는 경로가 사라졌다는 사실이 B에게 전달되기 전에 A가 잘못된 판단을 한 것입니다.

```
라우터 A: 10.0.0.0/8 → B
라우터 B: 10.0.0.0/8 → A
```

10.0.0.0/8로 향하는 패킷은 A → B → A → B → ... 무한 반복합니다.

<br>

이 문제를 해결하는 메커니즘은 [Part 2](/dev/network/Routing-2/)에서 다룹니다.

---

### TTL: 루프의 피해를 제한하다

루프가 발생하면 패킷이 영원히 돌까요? 그렇지 않습니다. 패킷에는 **TTL(Time To Live)**이라는 값이 있습니다.

<br>

TTL은 패킷이 거칠 수 있는 최대 라우터 수입니다. 패킷을 보내는 장치가 TTL을 설정합니다. 운영체제마다 다른데, Linux는 64, Windows는 128을 기본값으로 사용합니다.

<br>

패킷이 라우터를 지날 때마다 TTL이 1씩 감소합니다. 0이 되면 라우터는 패킷을 폐기합니다. 루프가 발생해도 패킷은 최대 TTL 횟수만큼만 돌고 사라집니다.

---

---

## 다음 글에서 다룰 내용

동적 라우팅 프로토콜은 경로를 계산하는 방식에 따라 분류됩니다.

<br>

**거리 벡터(Distance Vector)** 방식은 이웃에게 자신의 라우팅 테이블 전체를 전송합니다. 앞서 설명한 "A가 B에게 정보를 전달하고, B가 C에게 전파하는" 방식입니다.

<br>

**링크 상태(Link State)** 방식은 네트워크의 전체 연결 정보를 모든 라우터가 공유합니다. 각 라우터가 전체 그림을 보고 스스로 최단 경로를 계산합니다.

<br>

[Part 2](/dev/network/Routing-2/)에서 이 두 알고리즘의 동작 원리를 다룹니다. [Part 3](/dev/network/Routing-3/)에서는 인터넷이 어떻게 여러 네트워크로 구성되어 있는지, 그리고 네트워크 간 라우팅이 어떻게 다른지 다룹니다.

---

## 마무리

중앙에서 모든 경로를 관리하는 것은 불가능합니다. 수십억 개의 IP 주소가 있고, 네트워크 상태는 계속 변합니다. ARPANET이 선택한 분산 라우팅은 이 문제의 해결책이었습니다. 각 라우터가 이웃과 정보를 교환하고, 스스로 경로를 결정합니다.

이 원리 위에 라우팅 테이블, 최장 접두사 매칭, 관리 거리, 메트릭 같은 개념들이 쌓여 있습니다. 오늘날 인터넷에서 패킷이 목적지를 찾아가는 것은 이 분산된 협력 덕분입니다.

<br>

---

**관련 글**
- [네트워크 통신의 원리 (3) - 프로토콜 스택과 데이터 흐름](/dev/network/NetworkCommunication-3/)
- [IP 주소(IP Address)의 개념과 구조](/dev/network/IPAddress/)
- [서브넷(Subnet)의 개념과 서브네팅](/dev/network/Subnet/)
- [라우팅과 인터넷 구조 (2) - 라우팅 알고리즘](/dev/network/Routing-2/)
- [라우팅과 인터넷 구조 (3) - BGP와 인터넷의 구조](/dev/network/Routing-3/)
