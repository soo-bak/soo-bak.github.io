---
layout: single
title: "라우팅과 인터넷 구조 (2) - 라우팅 알고리즘 - soo:bak"
date: "2026-01-19 23:11:02 +0900"
description: 거리 벡터 알고리즘, 링크 상태 알고리즘, RIP, OSPF, EIGRP의 동작 원리를 설명합니다.
tags:
  - 네트워크
  - 라우팅
  - OSPF
  - RIP
  - 알고리즘
---

## 라우터는 어떻게 최적 경로를 찾는가

[Part 1](/dev/network/Routing-1/)에서 라우팅 테이블의 구조와 기본 개념을 살펴보았습니다.

동적 라우팅에서 라우터들은 서로 정보를 교환하여 경로를 학습합니다.

<br>

하지만 구체적으로 어떤 정보를 어떻게 교환할까요?

그리고 그 정보로 어떻게 최적 경로를 계산할까요?

<br>

두 가지 근본적인 접근법이 있습니다.

**거리 벡터(Distance Vector)**와 **링크 상태(Link State)**.

---

## 거리 벡터: 이웃에게 배운다

**거리 벡터 알고리즘**의 핵심 아이디어:

> "나는 목적지까지의 거리와 방향(다음 홉)만 알고, 전체 경로는 모른다."

<br>

각 라우터는 자신의 라우팅 테이블을 이웃에게 주기적으로 전송합니다.

이웃은 받은 정보를 기반으로 자신의 테이블을 업데이트합니다.

<br>

수학적 기반은 **벨만-포드(Bellman-Ford)** 알고리즘입니다.

```
D(x, y) = min { c(x, v) + D(v, y) }
          v∈이웃

D(x, y): x에서 y까지의 최소 비용
c(x, v): x에서 이웃 v까지의 비용
D(v, y): 이웃 v에서 y까지의 최소 비용 (v가 알려줌)
```

<br>

쉽게 말하면:

"목적지까지의 최소 비용 = 이웃까지 가는 비용 + 이웃이 알려준 거리 중 최솟값"

<br>

예시로 보겠습니다.

```
     2         1
A ────── B ────── C
│                 │
│ 7               │ 3
│                 │
└─────── D ───────┘
     1         2
```

<br>

초기 상태 (각 라우터는 직접 연결된 것만 앎):

```
라우터 A의 테이블:
목적지  거리  다음홉
B       2     B
D       7     D

라우터 B의 테이블:
목적지  거리  다음홉
A       2     A
C       1     C

라우터 C의 테이블:
목적지  거리  다음홉
B       1     B
D       3     D

라우터 D의 테이블:
목적지  거리  다음홉
A       7     A
C       2     C
```

<br>

첫 번째 라운드: 각 라우터가 이웃에게 테이블 전송

A가 B에게: "나는 D까지 7이다"
B가 A에게: "나는 C까지 1이다"
...

<br>

A는 B의 정보를 받고 계산합니다:
- C까지: A→B(2) + B→C(1) = 3
- 직접 경로보다 좋으면 업데이트

<br>

여러 라운드 후 수렴:

```
라우터 A의 최종 테이블:
목적지  거리  다음홉
B       2     B
C       3     B      (A→B→C)
D       6     B      (A→B→C→D, 7보다 작음)
```

<br>

모든 라우터가 최적 경로를 학습했습니다.

---

## Count-to-Infinity 문제

거리 벡터의 치명적인 약점입니다.

<br>

다시 예시:

```
A ─── B ─── C
 1     1
```

C가 네트워크에서 분리되었습니다 (B-C 링크 단절).

<br>

B는 C로의 경로가 사라진 것을 압니다.

하지만 A는 아직 모릅니다.

<br>

A의 테이블: C까지 거리 2 (A→B→C)

B가 A에게 물어봅니다: "C까지 얼마야?"
A: "2야"
B 생각: "A를 통하면 C까지 갈 수 있네! 1 + 2 = 3"

<br>

B의 새 테이블: C까지 거리 3 (B→A→...→C)

<br>

다음 라운드:
A가 B에게 물어봅니다: "C까지 얼마야?"
B: "3이야"
A 생각: "음, B를 통하면 1 + 3 = 4네. 업데이트!"

<br>

이 과정이 반복됩니다.

```
라운드   A의 C거리   B의 C거리
1        2          ∞ → 3
2        4          3
3        4          5
4        6          5
5        6          7
...
∞        ∞          ∞
```

<br>

결국 둘 다 무한대에 도달하지만, 엄청난 시간이 걸립니다.

RIP의 경우 "무한대"를 16으로 정의하므로 16번 반복해야 합니다.

30초마다 업데이트한다면 8분이 걸립니다.

<br>

그동안 C로 가는 패킷은 A↔B 사이를 왔다갔다합니다.

---

## 거리 벡터의 해결책들

**Split Horizon (분할 지평선)**

A가 B에게서 배운 경로를 다시 B에게 알려주지 않습니다.

"너한테 배운 건 너한테 안 알려줄게"

<br>

위 예시에서 A는 C로 가는 경로를 B에게서 배웠습니다.

따라서 A는 B에게 "나도 C까지 2야"라고 말하지 않습니다.

B는 A를 통한 우회 경로를 고려하지 않게 됩니다.

<br>

**Poison Reverse (독 역류)**

Split Horizon의 강화 버전입니다.

B에게 배운 경로는 B에게 "무한대"로 알려줍니다.

"B야, 나는 C까지 무한대야 (너를 통하지 않고는 못 가)"

<br>

**Hold-down Timer**

경로가 사라지면 일정 시간 동안 그 목적지에 대한 업데이트를 무시합니다.

"갑자기 나타난 우회 경로는 의심스러우니 잠시 기다려 보자"

<br>

**Triggered Updates**

주기적 업데이트를 기다리지 않고 변경이 생기면 즉시 알립니다.

수렴 시간을 단축합니다.

<br>

이 해결책들은 문제를 완화하지만 완전히 해결하지는 못합니다.

복잡한 토폴로지에서는 여전히 느린 수렴이 발생할 수 있습니다.

---

## RIP: 거리 벡터의 대표

**RIP(Routing Information Protocol)**는 가장 오래된 동적 라우팅 프로토콜 중 하나입니다.

1988년 RFC 1058로 표준화되었습니다.

<br>

RIP의 특성:

- 메트릭: 홉 수 (hop count)
- 최대 홉: 15 (16은 "도달 불가")
- 업데이트 주기: 30초
- UDP 포트 520 사용

<br>

RIP의 한계:

- 15홉 제한으로 대규모 네트워크에 부적합
- 홉 수만 고려하므로 대역폭, 지연 무시
- 느린 수렴 (분 단위)

<br>

RIPv2는 몇 가지를 개선했습니다:
- CIDR 지원 (서브넷 마스크 포함)
- 인증 지원
- 멀티캐스트 사용 (224.0.0.9)

<br>

하지만 근본적인 거리 벡터의 한계는 그대로입니다.

현대 네트워크에서 RIP는 거의 사용되지 않습니다.

---

## 링크 상태: 전체 지도를 공유하다

**링크 상태 알고리즘**의 핵심 아이디어:

> "모든 라우터가 전체 네트워크의 토폴로지를 알고, 각자 최적 경로를 계산한다."

<br>

거리 벡터와의 차이:

- 거리 벡터: 이웃이 알려준 거리 정보만 앎
- 링크 상태: 전체 네트워크 구조를 앎

<br>

링크 상태 라우팅의 과정:

1. **이웃 발견**: 인접한 라우터들과 Hello 메시지 교환
2. **링크 비용 측정**: 각 링크의 비용(대역폭, 지연 등) 측정
3. **LSA 생성**: 자신의 링크 정보를 담은 Link State Advertisement 생성
4. **LSA 플러딩**: LSA를 모든 라우터에게 전파
5. **데이터베이스 구축**: 받은 LSA들로 전체 토폴로지 데이터베이스 구축
6. **SPF 계산**: Dijkstra 알고리즘으로 최단 경로 트리 계산
7. **라우팅 테이블 생성**: SPF 결과로 테이블 구축

<br>

핵심은 모든 라우터가 **같은 토폴로지 데이터베이스**를 갖는다는 것입니다.

같은 데이터로 같은 알고리즘을 실행하면 같은 결과가 나옵니다.

루프가 발생하지 않습니다.

---

## Dijkstra 알고리즘

링크 상태 프로토콜은 **다익스트라(Dijkstra) 알고리즘**으로 최단 경로를 계산합니다.

1959년 에츠허르 다익스트라(Edsger Dijkstra)가 고안했습니다.

<br>

알고리즘의 핵심:

1. 시작점에서 가장 가까운 노드를 확정한다
2. 그 노드를 통한 새로운 경로가 더 짧으면 업데이트한다
3. 모든 노드가 확정될 때까지 반복한다

<br>

예시:

```
         10
    A ────── B
    │╲       │
   5│  ╲3    │2
    │    ╲   │
    D ──── C─┘
       2
```

<br>

A에서 시작:

```
초기:
확정: {A}
거리: A=0, B=10, C=3, D=5

1단계: C가 가장 가까움 (3), C 확정
확정: {A, C}
C를 통한 경로 확인:
- B: min(10, 3+2) = 5 (업데이트!)
- D: min(5, 3+2) = 5 (같음)
거리: A=0, B=5, C=3, D=5

2단계: B와 D 둘 다 5, B 선택
확정: {A, C, B}
거리 변화 없음

3단계: D 확정
확정: {A, C, B, D}
완료!
```

<br>

결과: A→B는 A→C→B (거리 5), A→D는 A→D (거리 5)

<br>

Dijkstra의 시간 복잡도: O(n²) 또는 힙 사용 시 O((n+e)log n)

n: 노드 수, e: 엣지 수

---

## OSPF: 링크 상태의 대표

**OSPF(Open Shortest Path First)**는 가장 널리 사용되는 IGP입니다.

1989년에 개발되어 RFC 2328로 표준화되었습니다.

<br>

OSPF의 특성:

- 메트릭: 비용 (cost), 대역폭 기반
- 영역(Area) 계층 구조 지원
- 빠른 수렴 (초 단위)
- IP 프로토콜 번호 89 사용 (TCP/UDP 아님)

<br>

**OSPF 영역 구조**

대규모 네트워크를 위해 OSPF는 영역으로 분할합니다.

```
           Area 1
         ┌───────┐
         │ R1 R2 │
         └───┬───┘
             │
    ┌────────┴────────┐
    │    Area 0       │  (백본)
    │  ABR1    ABR2   │
    └────┬───────┬────┘
         │       │
    ┌────┴───┐ ┌─┴────┐
    │ Area 2 │ │Area 3│
    │ R3 R4  │ │R5 R6 │
    └────────┘ └──────┘
```

<br>

- **Area 0**: 백본 영역, 모든 다른 영역은 Area 0과 연결되어야 함
- **ABR(Area Border Router)**: 여러 영역에 걸친 라우터

<br>

영역의 이점:

- LSA 플러딩 범위 제한 (영역 내부로)
- SPF 계산 범위 축소
- 라우팅 테이블 크기 감소

<br>

**OSPF 라우터 유형**

- **내부 라우터**: 한 영역에만 속함
- **ABR**: 여러 영역에 속함
- **ASBR(AS Boundary Router)**: 다른 AS와 연결됨
- **DR(Designated Router)**: 멀티액세스 네트워크에서 대표 역할

<br>

**DR/BDR 선출**

이더넷처럼 여러 라우터가 같은 네트워크에 있으면:

모든 라우터 쌍이 인접 관계를 맺으면 n(n-1)/2 개의 관계가 필요합니다.

10대면 45개의 관계입니다.

<br>

OSPF는 **DR(Designated Router)**을 선출합니다.

모든 라우터는 DR과만 LSA를 교환합니다.

BDR(Backup DR)은 DR이 실패할 경우를 대비합니다.

<br>

```
DR 없이:              DR 있을 때:

R1 ── R2              R1
 │╲  ╱│                │
 │ ╲╱ │            DR ─┼── R2
 │ ╱╲ │                │
R3 ── R4              R3 ── R4
                      (모두 DR과만 통신)
```

---

## EIGRP: 하이브리드 접근

**EIGRP(Enhanced Interior Gateway Routing Protocol)**는 Cisco 독점 프로토콜이었다가 2013년에 개방되었습니다.

거리 벡터와 링크 상태의 장점을 결합했습니다.

<br>

EIGRP의 특성:

- 복합 메트릭: 대역폭, 지연, 신뢰성, 부하
- DUAL 알고리즘으로 빠른 수렴
- 부분 업데이트 (변경된 것만 전송)
- 비동기 업데이트 (주기적이지 않음)

<br>

**DUAL 알고리즘**

Diffusing Update Algorithm의 핵심은 **Feasibility Condition**입니다.

<br>

루프를 방지하기 위한 조건:

```
이웃의 Reported Distance < 나의 현재 Feasible Distance
```

<br>

이 조건을 만족하는 이웃만 대체 경로(Feasible Successor)로 인정합니다.

현재 경로(Successor)가 실패하면 즉시 Feasible Successor로 전환합니다.

재계산이 필요 없어 매우 빠릅니다.

<br>

Feasible Successor가 없으면 "Active" 상태로 전환하여 이웃들에게 질의합니다.

모든 응답을 받으면 새 경로를 결정하고 "Passive" 상태로 돌아갑니다.

---

## 알고리즘 비교

```
특성            거리 벡터 (RIP)    링크 상태 (OSPF)    하이브리드 (EIGRP)
─────────────────────────────────────────────────────────────────────────
정보 공유       전체 테이블        LSA (링크 정보)     변경분만
공유 대상       이웃만            모든 라우터         이웃만
계산 위치       수신 시           각 라우터에서       수신 시
메모리 사용     낮음              높음 (토폴로지 DB)  중간
CPU 사용        낮음              높음 (SPF 계산)     중간
수렴 속도       느림 (분)         빠름 (초)           매우 빠름
루프 방지       불완전            완전                완전 (DUAL)
확장성          제한적 (15홉)     높음 (영역 구조)    높음
```

<br>

어떤 것을 선택할까요?

<br>

**RIP**는 거의 사용하지 않습니다.

레거시 시스템이나 매우 작은 네트워크에서만.

<br>

**OSPF**는 대부분의 기업 네트워크에서 표준입니다.

개방형 표준이고, 벤더 독립적이며, 검증된 안정성.

<br>

**EIGRP**는 Cisco 환경에서 고려할 수 있습니다.

빠른 수렴과 낮은 오버헤드가 장점.

<br>

**IS-IS**는 대규모 ISP에서 사용됩니다.

OSPF와 유사한 링크 상태 프로토콜이지만 IP에 종속되지 않음.

---

## 수렴 속도가 중요한 이유

네트워크 장애가 발생하면 라우팅이 수렴할 때까지 패킷이 손실됩니다.

<br>

```
수렴 전:
A ─X─ B ─── C ─── D
 ╲         │
  ╲───────┘

X: 링크 단절

A의 테이블: D로 가려면 B로 (아직 업데이트 안 됨)
→ 패킷 손실
```

<br>

RIP: 수렴에 수 분

OSPF: 수렴에 수 초 ~ 수십 초

EIGRP (Feasible Successor 있을 때): 밀리초

<br>

음성, 비디오 같은 실시간 트래픽에서 수 분의 수렴 시간은 치명적입니다.

현대 네트워크가 OSPF나 EIGRP를 사용하는 이유입니다.

<br>

[Part 3](/dev/network/Routing-3/)에서는 자율 시스템 간 라우팅을 담당하는 BGP와 인터넷의 구조를 살펴봅니다.

---

**관련 글**
- [라우팅과 인터넷 구조 (1) - 라우팅의 기본 원리](/dev/network/Routing-1/)
- [라우팅과 인터넷 구조 (3) - BGP와 인터넷의 구조](/dev/network/Routing-3/)
- [네트워크 통신의 원리 (3) - 프로토콜 스택과 데이터 흐름](/dev/network/NetworkCommunication-3/)
