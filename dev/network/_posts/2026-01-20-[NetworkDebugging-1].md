---
layout: single
title: "네트워크 디버깅 (1) - 계층별 진단 도구 - soo:bak"
date: "2026-01-20 22:31:19 +0900"
description: 계층별 문제 해결, ARP, ping, traceroute, 포트 상태 확인, DNS 진단 도구를 설명합니다.
tags:
  - 네트워크
  - 디버깅
  - ping
  - traceroute
  - DNS
  - netstat
---

## 네트워크 문제를 어떻게 진단하는가

"인터넷이 안 돼요."

가장 흔하지만 가장 모호한 문의입니다. 이 한 문장 뒤에는 수십 가지 원인이 숨어 있을 수 있습니다. 케이블이 빠져 있을 수도 있고, DNS 서버가 응답하지 않을 수도 있고, 방화벽이 특정 포트를 차단하고 있을 수도 있습니다.

이 시리즈에서 다루어 온 [네트워크 통신의 원리](/dev/network/NetworkCommunication-1/), [TCP/IP 스택](/dev/network/SocketTransport-1/), [라우팅](/dev/network/Routing-1/), [DNS](/dev/network/DNS-1/) 등의 지식은 단순히 이론으로 끝나지 않습니다. 문제가 발생했을 때 원인을 빠르게 찾아내는 것이 이 지식의 실전적 가치입니다.

네트워크는 물리 계층부터 애플리케이션 계층까지 여러 계층이 쌓여 동작합니다. 각 계층은 아래 계층이 정상적으로 동작한다는 전제 위에서 작동하므로, 아래 계층에 문제가 있으면 위 계층도 함께 실패합니다.

예를 들어, DNS가 동작하려면 먼저 UDP/IP 통신이 되어야 하고, IP 통신이 되려면 L2(데이터 링크 계층, 즉 MAC 주소 기반의 물리적 연결) 수준의 연결이 되어야 합니다. 문제 해결의 첫 단계는 이 계층 중 **어디서** 문제가 발생하는지 찾는 것입니다.

---

## 문제 해결 방법론

### 계층별 접근

[OSI 모델과 TCP/IP 스택](/dev/network/NetworkCommunication-1/)을 따라 아래에서 위로 확인합니다. TCP/IP 모델에서는 세션(5)과 표현(6) 계층을 애플리케이션 계층에 포함하므로, 실무 진단에서는 아래 5개 계층을 기준으로 삼습니다.

```
확인 순서 (아래 → 위):
┌─────────────────────────────────────┐
│ 7. 애플리케이션  ← HTTP, DNS 확인   │
├─────────────────────────────────────┤
│ 4. 전송 계층     ← 포트, 연결 확인  │
├─────────────────────────────────────┤
│ 3. 네트워크 계층 ← IP, 라우팅 확인  │
├─────────────────────────────────────┤
│ 2. 데이터 링크   ← MAC, ARP 확인    │
├─────────────────────────────────────┤
│ 1. 물리 계층     ← 케이블, 연결 확인│  ← 여기서 시작
└─────────────────────────────────────┘
```

### 분할 정복

계층별 접근이 "어느 계층에서 막히는가"를 찾는 전략이라면, 분할 정복은 "같은 계층 안에서 어느 구간이 문제인가"를 좁히는 전략입니다. 특히 경로가 길어서 하나씩 확인하기 어려울 때 유용합니다.

네트워크 경로의 중간 지점을 먼저 확인하여 문제 범위를 절반으로 좁힙니다.

```
클라이언트 ─── 스위치 ─── 라우터 ─── 인터넷 ─── 서버
                            │
                     여기까지 정상 응답?
                       → 오른쪽(서버 방향) 확인

                     여기서 응답 실패?
                       → 왼쪽(클라이언트 방향) 확인
```

### 가설과 검증

증상을 관찰한 뒤 하나의 가설을 세우고, 해당 가설을 검증할 수 있는 최소한의 테스트를 수행합니다.

예를 들어 "DNS 문제"라는 가설이 있다면, 도메인 대신 IP 주소로 직접 접속해 봅니다. IP로 접속이 되면 DNS 문제가 확정되고, IP로도 안 되면 가설을 수정하여 네트워크 경로 문제로 범위를 옮깁니다.

---

## L2 진단: 데이터 링크 계층

계층별 접근에서 아래부터 위로 확인한다고 했습니다. L1(물리 계층)은 케이블 연결 여부나 링크 LED 점등처럼 육안으로 빠르게 판단할 수 있으므로, 명령줄 기반 진단은 L2부터 시작하게 됩니다. L2가 정상이어야 그 위의 IP 통신(L3)과 포트 연결(L4)도 동작합니다. 따라서 L2 문제를 먼저 배제하는 편이 효율적입니다.

### ARP 테이블 확인

L2 통신 여부를 확인할 때 가장 먼저 살펴볼 곳은 **ARP(Address Resolution Protocol) 테이블** 입니다. ARP는 통신하려는 상대의 IP 주소로부터 실제 프레임을 전달할 MAC 주소를 알아내는 프로토콜이며, ARP 테이블에는 이렇게 알아낸 IP-MAC 매핑이 캐시되어 있습니다. ARP는 같은 서브넷, 즉 동일한 L2 브로드캐스트 도메인(스위치로 연결되어 ARP 요청이 직접 도달할 수 있는 범위) 안에서만 동작합니다. 따라서 다른 서브넷의 호스트와 통신할 때는, 패킷을 대신 전달해 줄 게이트웨이의 MAC 주소가 ARP 테이블에 등록됩니다.

```bash
# Linux
ip neigh show
# 또는
arp -a

# 결과 예시:
# 192.168.1.1 dev eth0 lladdr 00:11:22:33:44:55 REACHABLE
# 192.168.1.100 dev eth0 lladdr aa:bb:cc:dd:ee:ff STALE
```

ARP 테이블의 각 항목은 상태(state)를 가집니다. REACHABLE은 최근 통신이 확인된 정상 상태이며, STALE은 일정 시간이 지나 재확인이 필요한 상태를 뜻합니다. 이 둘은 정상 범위에 해당합니다.

반면 INCOMPLETE은 ARP 요청을 보냈지만 응답을 받지 못한 것이고, FAILED는 ARP 해석이 완전히 실패한 것을 나타냅니다. 이 두 상태가 보인다면 대상 호스트가 네트워크에 연결되어 있지 않거나, ARP 요청에 응답하지 않는 상황입니다. 케이블 연결, VLAN(같은 스위치에서 네트워크를 논리적으로 분리하는 설정) 설정, 대상 호스트의 전원 상태를 먼저 점검합니다.

### MAC 주소 문제

ARP 테이블에 올바른 MAC 주소가 등록되어 있더라도, 같은 네트워크 안에 동일한 MAC 주소가 중복 존재하면 L2 통신은 여전히 실패합니다. 현재 인터페이스의 MAC 주소는 다음과 같이 확인합니다.

```bash
# 인터페이스 MAC 확인
ip link show eth0
# link/ether 00:11:22:33:44:55 brd ff:ff:ff:ff:ff:ff
```

MAC 주소는 48비트(6바이트)로 구성되며, L2에서 네트워크 인터페이스를 식별하는 역할을 합니다. 스위치는 각 포트에 연결된 장비의 MAC 주소를 학습하고, 프레임을 해당 포트로만 전달합니다.

동일한 네트워크 세그먼트(같은 스위치나 허브에 연결된 장비들의 L2 영역)에 같은 MAC 주소를 가진 장비가 두 대 이상 존재하면 문제가 생깁니다. 같은 MAC 주소가 두 포트에 나타나면서 스위치의 학습 테이블이 계속 변경되는데, 이 현상을 MAC flapping이라고 합니다. 그 결과 프레임이 올바른 포트로 전달되지 못합니다.

증상으로는 연결이 랜덤하게 끊기거나, 트래픽이 엉뚱한 장비로 향하는 현상이 나타납니다. 가상 머신의 MAC 주소를 수동 설정하거나, 저가 장비에서 고정 MAC을 사용할 때 이런 충돌이 발생하기 쉽습니다.

### 스위치 포트 상태

ARP 테이블과 MAC 주소에 이상이 없다면, 인터페이스의 물리적 링크 상태를 확인할 차례입니다. `ip link show` 명령으로 관리적 상태와 물리적 상태를 모두 볼 수 있습니다.

```bash
# Linux: 인터페이스 상태
ip link show
# eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> ...
#       UP: 관리자 활성화
#       LOWER_UP: 물리적 연결됨

# ethtool로 자세한 정보
ethtool eth0
# Link detected: yes
# Speed: 1000Mb/s
# Duplex: Full
```

출력에서 확인할 핵심 플래그는 두 가지입니다.

- `UP` -- 관리자가 인터페이스를 활성화한 상태입니다. 이 플래그가 없으면 `ip link set eth0 up`으로 활성화해야 합니다.
- `LOWER_UP` -- 물리적 링크(케이블 연결)가 감지된 상태입니다. 이 플래그가 없으면 케이블이 빠져 있거나 상대 스위치 포트가 비활성 상태입니다.

`ethtool`의 `Speed`와 `Duplex`(Full이면 동시 송수신, Half이면 교대 송수신) 값으로 협상된 링크 속도도 확인할 수 있습니다.

---

## L3 진단: 네트워크 계층

L2에서 인터페이스 상태와 ARP 테이블이 정상임을 확인했다면, 다음으로 살펴볼 것은 IP 수준의 통신입니다. 패킷이 대상 호스트까지 실제로 도달하는지, 경로에 이상이 없는지, 라우팅 설정이 올바른지를 차례로 검증합니다.

### ping의 원리

L3 진단에서 가장 먼저 꺼내는 도구는 ping입니다. 패킷이 상대에게 닿기는 하는지, 그 왕복에 얼마나 걸리는지를 한 번의 명령으로 확인할 수 있기 때문입니다.

내부적으로 ping은 **ICMP(Internet Control Message Protocol)**의 Echo Request를 대상 호스트에 보내고, 돌아오는 Echo Reply 유무로 IP 수준의 도달 가능성을 판단합니다.

```
클라이언트                        대상
    │                              │
    │ ── ICMP Echo Request ──────► │
    │                              │
    │ ◄── ICMP Echo Reply ──────── │
    │                              │
```

Google의 공개 DNS 서버(8.8.8.8)에 ping을 실행하면 다음과 같은 출력을 볼 수 있습니다.

```bash
ping 8.8.8.8

# PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.
# 64 bytes from 8.8.8.8: icmp_seq=1 ttl=116 time=32.5 ms
# 64 bytes from 8.8.8.8: icmp_seq=2 ttl=116 time=31.8 ms
# ...
#
# --- 8.8.8.8 ping statistics ---
# 5 packets transmitted, 5 received, 0% packet loss, time 4005ms
# rtt min/avg/max/mdev = 31.8/32.1/32.5/0.3 ms
```

이 출력에서 눈여겨볼 부분은 응답 여부, RTT, 패킷 손실률, TTL입니다.

응답이 돌아온다면 대상에 IP 수준에서 도달 가능하다는 뜻이고, 응답이 없다면 경로상 어딘가에서 패킷이 차단되거나 유실되고 있는 것입니다. **RTT(Round Trip Time)** 는 패킷이 대상까지 왕복하는 데 걸린 시간입니다. 같은 대상인데 RTT가 크게 흔들린다면 네트워크 혼잡을 의심할 수 있습니다.

패킷 손실률은 전송한 패킷 중 응답이 돌아오지 않은 비율입니다. 0%가 정상이며, 1% 이상이면 경로상 간헐적 장애가 존재할 가능성이 있습니다. 손실률 100%는 대상이 아예 응답하지 않거나 ICMP가 차단된 상황을 가리킵니다.

TTL(Time To Live) 값으로는 패킷이 경유한 라우터 수를 역산할 수 있습니다. 운영체제마다 초기 TTL이 다른데, Linux는 64, Windows는 128입니다. 위 출력에서 응답의 TTL이 116이므로, 초기 TTL이 128인 경우 128 - 116 = 12개의 라우터를 경유한 것으로 추정됩니다.

### ping이 실패하는 이유

ping 출력이 정상이라면 다음 단계로 넘어가면 되지만, 응답이 돌아오지 않을 때가 문제입니다.

**ping 실패가 곧 연결 불가능을 뜻하지는 않습니다.** 에러 메시지 유형에 따라 원인을 좁힐 수 있습니다. "Destination Host Unreachable"은 경로가 존재하지 않아 라우터가 패킷을 전달하지 못하는 상황입니다. 응답 없이 타임아웃되면 방화벽이 ICMP를 차단하거나 대상 서버가 꺼져 있을 가능성이 높습니다. "Time to live exceeded"는 패킷이 TTL이 0이 될 때까지 목적지에 도달하지 못한 것으로, 라우팅 루프를 의심하게 됩니다.

한편, 많은 서버가 보안상 ICMP를 차단합니다. 그래서 ping이 실패해도 HTTP 요청은 정상 처리되는 경우가 있습니다. 이럴 때는 nc로 특정 포트에 TCP 연결을 시도하여 실제 서비스 도달 가능성을 따로 확인해야 합니다.

### traceroute / mtr

ping은 목적지까지의 도달 여부를 알려주지만, 어디에서 막히는지는 알려주지 않습니다. traceroute는 경로상의 각 홉(hop, 패킷이 거치는 각 라우터 지점)을 하나씩 드러내어 병목이나 장애 지점을 특정할 수 있게 합니다.

```bash
traceroute google.com

# traceroute to google.com (142.250.185.46), 30 hops max
#  1  192.168.1.1 (192.168.1.1)  1.234 ms  1.156 ms  1.089 ms
#  2  10.0.0.1 (10.0.0.1)  5.678 ms  5.432 ms  5.321 ms
#  3  * * *  (응답 없음)
#  4  72.14.198.18 (72.14.198.18)  15.432 ms  15.321 ms  15.210 ms
#  5  142.250.185.46 (142.250.185.46)  20.123 ms  20.012 ms  19.987 ms
```

원리는 TTL을 이용한 역추적입니다. traceroute는 TTL 값을 1부터 하나씩 늘려 가며 패킷을 보냅니다. TTL=1이면 첫 번째 라우터에서 TTL이 0이 되어 ICMP Time Exceeded 응답이 돌아오고, TTL=2이면 두 번째 라우터에서 같은 일이 일어납니다. 목적지에 도달할 때까지 이 과정을 반복하면 경로상의 모든 라우터가 순서대로 드러납니다. 각 홉에서 기본적으로 3번 측정하기 때문에 출력에 응답 시간이 3개씩 나타납니다.

결과에서 `* * *`가 나오면 해당 홉에서 ICMP Time Exceeded 응답을 받지 못한 것입니다. 대부분은 해당 라우터가 보안 정책으로 ICMP 응답을 차단하기 때문이고, 응답 시간이 타임아웃(기본 5초)을 초과해도 `*`로 표시됩니다. 드물게는 비대칭 라우팅 -- 요청은 도달하지만 응답이 다른 경로로 돌아오면서 유실되는 경우 -- 이 원인이 되기도 합니다. 다만, 중간에 `* * *`가 있더라도 최종 목적지에 도달한다면 해당 홉만 응답을 차단한 것이므로 정상입니다.

traceroute는 한 번의 스냅샷입니다. 그 순간의 경로는 보여주지만, 간헐적으로 패킷이 유실되는 홉은 잡아내기 어렵습니다.

**mtr**은 이 한계를 보완합니다. traceroute와 ping을 결합하여 동일 경로에 대해 반복 측정을 수행하고, 각 홉의 패킷 손실률과 지연 시간 통계를 실시간으로 누적합니다. 단발성 traceroute로는 놓치기 쉬운 간헐적 장애를 잡아내는 데 적합한 도구입니다.

```bash
mtr google.com

# 실시간으로 업데이트되는 통계
# Host                   Loss%   Snt   Last   Avg  Best  Wrst
# 1. 192.168.1.1          0.0%    50    1.2   1.3   1.0   2.1
# 2. 10.0.0.1             0.0%    50    5.4   5.5   5.2   6.1
# 3. (no response)       100.0%   50    0.0   0.0   0.0   0.0
# 4. 72.14.198.18         0.0%    50   15.3  15.4  15.1  16.2
```

각 컬럼의 의미는 다음과 같습니다. Loss%는 해당 홉의 패킷 손실률, Snt는 보낸 패킷 수, Last는 가장 최근 측정값, Avg/Best/Wrst는 각각 평균/최소/최대 응답 시간(ms)입니다. 특정 홉의 Loss%가 높은데 그 이후 홉들은 정상이라면, 해당 라우터가 ICMP 응답만 제한하는 것이므로 실제 장애는 아닙니다. 반대로 특정 홉부터 이후 모든 홉의 Loss%가 함께 올라간다면, 그 홉이 실제 병목 지점일 가능성이 높습니다.

### 라우팅 테이블 확인

traceroute로 경로를 추적한 뒤에는, 그 경로가 왜 그렇게 결정되었는지도 확인해야 합니다. 운영체제는 **라우팅 테이블** -- 목적지별로 어떤 인터페이스와 게이트웨이를 사용할지 정리한 경로 목록 -- 을 참조하여 패킷의 다음 행선지를 결정하기 때문입니다.

```bash
# Linux
ip route show
# 또는
route -n

# default via 192.168.1.1 dev eth0 proto dhcp metric 100
# 192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.10
# 10.0.0.0/8 via 192.168.1.254 dev eth0
```

출력을 한 줄씩 살펴봅니다.

- `default via 192.168.1.1 dev eth0` -- 명시적으로 일치하는 경로가 없는 모든 패킷을 192.168.1.1(기본 게이트웨이)로 보내라는 규칙입니다.
- `192.168.1.0/24 dev eth0` -- 192.168.1.0~255 범위가 eth0에 직접 연결된 로컬 서브넷이므로 게이트웨이 없이 통신한다는 뜻입니다.
- `10.0.0.0/8 via 192.168.1.254` -- 10.x.x.x 대역 트래픽을 192.168.1.254 라우터로 넘기라는 정적 경로입니다.

진단 시 가장 먼저 볼 것은 기본 게이트웨이(`default via ...`)의 존재 여부입니다. 이 항목이 없고 별도의 정적 경로도 설정되어 있지 않다면, 로컬 서브넷 밖으로 나가는 패킷은 전달되지 않습니다. 그 다음으로는 특정 목적지에 대한 경로가 올바른 인터페이스와 게이트웨이를 가리키는지 확인합니다. 잘못된 정적 경로가 남아 있으면 트래픽이 엉뚱한 방향으로 흘러갈 수 있습니다.

---

## L4 진단: 전송 계층

ping이 잘 나가고 traceroute 경로도 깨끗하다면, IP 수준의 도달 가능성은 확보된 셈입니다. 하지만 호스트에 패킷이 도착한다고 해서 원하는 서비스에 접근할 수 있는 것은 아닙니다.

**IP 도달 가능성과 서비스 도달 가능성은 별개입니다.**

리슨하는 프로세스가 없거나 방화벽이 해당 포트를 차단하고 있으면, IP가 살아 있어도 연결은 실패합니다.

### 포트 상태 확인

서비스가 실제로 포트를 열고 대기하고 있는지 확인하려면, 서버 측 소켓 상태를 직접 조회해야 합니다. **ss(socket statistics)**가 그 역할을 합니다. 특정 포트가 리슨(listen) 상태인지, 현재 어떤 클라이언트가 연결되어 있는지를 한눈에 보여줍니다.

```bash
# ss (socket statistics) - Linux 권장
ss -tuln
# -t: TCP
# -u: UDP
# -l: listening
# -n: 숫자로 표시

# State    Recv-Q Send-Q Local Address:Port   Peer Address:Port
# LISTEN   0      128    0.0.0.0:22          0.0.0.0:*
# LISTEN   0      128    0.0.0.0:80          0.0.0.0:*
# LISTEN   0      128    [::]:443            [::]:*
```

`netstat -tuln`도 같은 정보를 제공하지만, 최신 Linux에서는 ss가 더 빠르고 출력도 상세합니다.

### TCP 연결 상태

리슨 포트뿐 아니라 현재 활성 중인 모든 TCP 연결까지 확인하려면 `ss -tan`을 사용합니다.

```bash
ss -tan
# State      Recv-Q Send-Q Local Address:Port  Peer Address:Port
# LISTEN     0      128    0.0.0.0:80         0.0.0.0:*
# ESTAB      0      0      192.168.1.10:22    192.168.1.100:54321
# TIME-WAIT  0      0      192.168.1.10:80    10.0.0.5:12345
```

LISTEN은 서버가 해당 포트에서 연결 요청을 기다리는 상태이고, ESTAB(ESTABLISHED의 약어로, ss는 출력 폭을 줄이기 위해 이렇게 표기)은 TCP 3-way handshake가 완료되어 양쪽이 데이터를 주고받을 수 있는 정상 연결 상태입니다. ss 출력에서 이 두 상태가 대부분을 차지한다면 서비스는 정상 동작 중입니다.

TIME-WAIT는 연결이 정상 종료(FIN 교환 완료)된 후 보통 60초간 유지되는 상태입니다.

왜 종료 후에도 상태를 유지할까요? TCP는 (출발지 IP, 출발지 포트, 목적지 IP, 목적지 포트)의 네 값 조합, 즉 4-tuple로 연결을 식별합니다. 연결이 종료된 직후 같은 4-tuple로 새 연결을 열면, 이전 연결에서 네트워크를 떠돌던 지연 패킷이 새 연결에 뒤늦게 도착할 수 있습니다. 수신 측은 그 패킷이 이전 연결의 잔재인지 새 연결의 정상 데이터인지 구별할 수 없으므로, 데이터 스트림이 오염됩니다.

**TIME-WAIT는 같은 4-tuple의 재사용을 일정 시간 차단하여, 지연 패킷이 완전히 소멸한 뒤에만 새 연결을 허용합니다.**

트래픽이 많은 서버에서 TIME-WAIT가 수천 개 쌓이더라도 그 자체로 문제가 되지는 않습니다.

SYN-SENT는 클라이언트가 SYN을 보내고 SYN-ACK를 기다리는 상태, CLOSE-WAIT는 상대방이 FIN을 보냈지만 로컬 애플리케이션이 아직 소켓을 닫지 않은 상태입니다. 어느 쪽이든 소수가 잠깐 나타났다 사라지는 것은 정상입니다.

하지만 지속적으로 쌓인다면 원인을 파악해야 합니다. SYN-SENT가 오래 남아 있다면 서버가 응답하지 않거나 방화벽이 SYN 패킷을 DROP하고 있을 가능성이 높고, CLOSE-WAIT가 누적된다면 애플리케이션이 소켓을 제때 닫지 않는 버그를 의심해야 합니다.

### 포트 도달 가능성 테스트

ss로 서버 측 소켓 상태를 확인했다면, 클라이언트 측에서 해당 포트에 실제로 닿을 수 있는지도 검증해야 합니다. **nc(netcat)**는 TCP/UDP 연결을 직접 시도하는 도구입니다. `-z` 옵션은 데이터를 보내지 않고 연결 가능 여부만 확인하며, `-v`는 결과를 상세히 출력합니다.

ping은 ICMP 기반이라 특정 포트의 서비스 상태를 알 수 없지만, nc는 실제 TCP 연결을 시도하므로 포트 수준의 도달 가능성을 직접 확인할 수 있습니다.

```bash
# nc (netcat)
nc -zv example.com 80
# Connection to example.com 80 port [tcp/http] succeeded!

# 실패 시:
nc -zv example.com 12345
# nc: connect to example.com port 12345 (tcp) failed: Connection refused
```

"succeeded"는 TCP 3-way handshake가 완료되어 해당 포트에서 서비스가 실행 중임을 뜻합니다. "Connection refused"는 대상에 도달했지만 리슨하는 프로세스가 없다는 의미이며, 타임아웃이 발생한다면 방화벽이 패킷을 DROP하고 있을 가능성이 높습니다.

### 방화벽 규칙 확인

nc에서 타임아웃이 발생했다면, 다음으로 살펴볼 곳은 방화벽 규칙입니다. Linux에서는 iptables, nftables, UFW 등 여러 방화벽 프레임워크가 사용됩니다. `iptables -L`은 현재 적용된 필터 규칙을 보여주고, `-n`은 DNS 역조회 없이 IP와 포트를 숫자 그대로 표시하며, `-v`를 붙이면 각 규칙에 매칭된 패킷 수까지 확인할 수 있어 어떤 규칙이 트래픽을 차단하는지 파악하는 데 도움이 됩니다.

```bash
# iptables (Linux)
sudo iptables -L -n -v

# nftables (최신 Linux)
sudo nft list ruleset

# UFW (Ubuntu)
sudo ufw status verbose
```

출력에서 특정 포트에 대한 DROP 또는 REJECT 규칙이 있다면, 해당 규칙이 nc 타임아웃의 원인일 수 있습니다.

---

## DNS 진단

L4까지의 진단으로 포트 연결이 정상임을 확인했는데도, 도메인 이름으로 접속하면 실패하는 경우가 있습니다. IP 주소로 직접 접속하면 정상 동작한다면, DNS가 도메인을 올바른 IP로 해석하지 못하고 있을 가능성이 높습니다. dig와 nslookup으로 DNS 해석 과정을 직접 질의하면 어느 단계에서 문제가 발생하는지 특정할 수 있습니다.

### dig

DNS 문제를 확인할 때 가장 먼저 꺼내는 도구가 **dig(Domain Information Groper)**입니다. DNS 질의의 상세한 결과 -- 응답 레코드, 응답 시간, 질의에 사용된 DNS 서버 -- 를 한 번에 보여주기 때문입니다.

```bash
dig example.com

# ;; QUESTION SECTION:
# ;example.com.                   IN      A
#
# ;; ANSWER SECTION:
# example.com.            3600    IN      A       93.184.216.34
#
# ;; Query time: 45 msec
# ;; SERVER: 8.8.8.8#53(8.8.8.8)
# ;; WHEN: Mon Jan 20 22:31:00 KST 2026
```

`QUESTION SECTION`은 질의 내용, `ANSWER SECTION`은 응답 결과입니다. `Query time`으로 응답 시간을, `SERVER`로 질의에 사용된 DNS 서버를 확인합니다.

기본 출력 외에도 dig는 용도에 따라 옵션을 바꿔 사용할 수 있습니다.

```bash
# 특정 DNS 서버 지정
dig @8.8.8.8 example.com

# 특정 레코드 타입
dig example.com MX      # 메일 서버
dig example.com AAAA    # IPv6 주소
dig example.com NS      # 네임 서버

# 짧은 출력
dig +short example.com
# 93.184.216.34

# 추적 (재귀적으로 해석)
dig +trace example.com
```

`@8.8.8.8`은 특정 DNS 서버를 지정하여 질의합니다. `+short`는 응답 IP만 간결하게 출력하고, `+trace`는 루트 서버부터 재귀적으로 해석하는 전체 과정을 보여줍니다.

### nslookup

dig가 상세한 DNS 분석에 적합하다면, `nslookup`은 간결한 출력으로 빠르게 결과를 확인하는 데 적합합니다. 출력 첫 부분의 "Server"는 질의에 사용된 DNS 서버이고, "Non-authoritative answer"는 권한 있는 네임서버가 아닌 재귀 리졸버로부터 온 응답임을 나타냅니다.

```bash
nslookup example.com
# Server:         192.168.1.1
# Address:        192.168.1.1#53
#
# Non-authoritative answer:
# Name:   example.com
# Address: 93.184.216.34
```

레코드 타입별 세부 분석이나 해석 경로 추적이 필요하면 dig를, 단순히 도메인이 어떤 IP로 해석되는지만 확인하면 nslookup을 사용합니다.

### DNS 캐시 문제

dig나 nslookup으로 조회한 결과가 예상과 다르다면 -- 예를 들어 레코드를 변경했는데 이전 IP가 계속 반환된다면 -- 로컬 DNS 캐시를 의심해야 합니다. 운영체제는 DNS 응답을 TTL(Time To Live) 값에 따라 캐시하고, TTL이 만료되기 전까지는 DNS 서버에 다시 질의하지 않습니다. 캐시를 수동으로 비우면 즉시 새 레코드를 조회할 수 있습니다.

```bash
# Linux: systemd-resolved 캐시 상태 확인 (플러시 전후로 비교할 수 있습니다)
systemd-resolve --statistics

# 캐시 플러시
sudo systemd-resolve --flush-caches

# macOS
sudo dscacheutil -flushcache
sudo killall -HUP mDNSResponder

# Windows
ipconfig /flushdns
```

### 전파 지연

로컬 캐시를 비운 뒤에도 일부 지역에서 이전 IP가 반환된다면, 문제는 전파 지연에 있습니다. DNS 레코드를 변경하면 전 세계의 리졸버(재귀 DNS 서버)가 기존 캐시의 TTL이 만료될 때까지 이전 값을 반환합니다. TTL이 3600초(1시간)로 설정되어 있다면, 변경 후 최대 1시간까지 이전 IP가 응답될 수 있습니다. 여러 공개 DNS 서버에 직접 질의하면 전파 상태를 확인할 수 있습니다.

```bash
# 여러 DNS 서버에서 확인
dig @8.8.8.8 example.com +short    # Google DNS
dig @1.1.1.1 example.com +short    # Cloudflare DNS
dig @208.67.222.222 example.com +short  # OpenDNS
```

세 서버의 응답이 동일하면 전파가 완료된 것이고, 서로 다른 IP가 반환된다면 아직 일부 리졸버에 이전 캐시가 남아 있는 상태입니다.

---

## 마무리: 계층을 따라가라

네트워크 문제는 물리 계층부터 애플리케이션 계층까지, 아래에서 위로 순서대로 확인합니다.

L2에서는 케이블 연결, 인터페이스 상태, ARP 테이블로 물리적 연결을 검증합니다. L3에서는 ping으로 IP 도달 가능성을, traceroute로 경로를, 라우팅 테이블로 경로 설정을 확인합니다. L4에서는 nc로 포트 도달 가능성을, ss로 소켓 상태를, iptables로 방화벽 규칙을 점검합니다. DNS에서는 dig로 이름 해석이 정상인지, 캐시가 오래된 것은 아닌지 살펴봅니다.

각 계층의 도구는 아래 계층이 정상이라는 전제 위에서 동작합니다. ping이 실패하는 상황에서 traceroute를 실행해도 의미 있는 결과를 얻기 어렵고, IP 통신 자체가 안 되면 DNS 진단은 성립하지 않습니다.

[Part 2](/dev/network/NetworkDebugging-2/)에서는 패킷 분석 도구를 다룹니다.

---

**관련 글**
- [네트워크 통신의 원리 (1) - 데이터는 어떻게 전달되는가](/dev/network/NetworkCommunication-1/)
- [DNS의 원리와 구조 (1) - DNS의 탄생과 계층 구조](/dev/network/DNS-1/)

**시리즈**
- 네트워크 디버깅 (1) - 계층별 진단 도구 (현재 글)
- [네트워크 디버깅 (2) - 패킷 분석](/dev/network/NetworkDebugging-2/)
