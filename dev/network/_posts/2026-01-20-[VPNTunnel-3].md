---
layout: single
title: "VPN과 터널링 (3) - 현대 VPN 기술 - soo:bak"
date: "2026-01-20 22:31:06 +0900"
description: SSL/TLS VPN, OpenVPN, WireGuard의 설계 철학, 프로토콜 비교, Split Tunneling, Zero Trust를 설명합니다.
tags:
  - 네트워크
  - VPN
  - WireGuard
  - OpenVPN
  - SSL VPN
  - Zero Trust
---

[Part 2](/dev/network/VPNTunnel-2/)에서 IPsec의 구조를 살펴보았습니다.

키 교환(IKE), 패킷 암호화(ESP), 보안 정책 관리(SAD/SPD)까지, IPsec은 VPN에 필요한 모든 기능을 갖추고 있습니다.

하지만 IPsec은 1990년대 후반, 본사와 지사를 연결하는 기업용 인프라를 전제로 설계되었습니다. 고정된 IP 주소, 전용 VPN 장비, 전문 네트워크 관리자가 있는 환경에서 잘 작동했습니다.

2000년대 들어 환경이 바뀌었습니다. 노트북과 스마트폰이 보편화되면서 사용자의 IP 주소는 수시로 바뀌기 시작했고, 커피숍이나 공항처럼 HTTP(80)와 HTTPS(443) 외의 포트를 차단하는 네트워크에서 VPN을 사용해야 하는 상황이 늘어났습니다.

IPsec은 이런 환경에 맞지 않았고, 다른 접근이 필요했습니다.

SSL/TLS VPN은 웹과 같은 포트(443)를 사용하여 방화벽을 우회했고, WireGuard는 코드를 4,000줄로 줄여 보안 감사가 가능한 수준의 단순함을 확보했습니다.

---

## 왜 새로운 VPN 프로토콜이 등장했는가

구체적으로 어떤 문제가 있었을까요?

**설정 복잡성.** IKE 버전, DH 그룹, 암호화 알고리즘, 무결성 알고리즘, 수명 등 수십 개의 파라미터를 양쪽에서 정확히 일치시켜야 합니다. 하나라도 다르면 터널이 수립되지 않습니다.

**방화벽 통과 어려움.** ESP(프로토콜 50), UDP 500, UDP 4500 등 일반적이지 않은 포트와 프로토콜을 사용합니다. 호텔이나 공항 Wi-Fi에서는 이 포트들이 차단되어 VPN 자체가 연결되지 않는 경우가 많습니다.

**모바일 환경의 한계.** SA는 특정 IP 주소 쌍에 바인딩됩니다. 스마트폰이 Wi-Fi에서 LTE로 전환하면 IP 주소가 바뀌고, SAD에서 SA를 찾을 수 없어 IKE 재협상이 필요합니다. 그 사이 연결이 끊기게 됩니다.

**코드베이스 비대.** Linux의 IPsec 스택(커널 XFRM + strongSwan)은 약 40만 줄에 달합니다. 코드가 많을수록 버그가 숨을 수 있는 곳도 많아지고, 공격자가 노릴 수 있는 취약점도 늘어납니다. 40만 줄을 빠짐없이 검토하는 것은 현실적으로 불가능합니다.

---

## SSL/TLS VPN

방화벽이 IPsec을 차단할 수 있는 이유는, IPsec이 ESP라는 별도의 프로토콜을 사용하기 때문입니다. 방화벽 입장에서 ESP는 허용 목록에 없는 생소한 프로토콜입니다.

**SSL/TLS VPN**은 발상을 바꿉니다. VPN 트래픽을 [TLS(Transport Layer Security)](/dev/network/NetworkSecurity-2/) 안에 담아 HTTPS와 같은 포트(443)로 보냅니다. TLS는 웹 브라우저가 서버와 통신할 때 데이터를 암호화하는 프로토콜로, 주소창의 자물쇠 아이콘이 이 프로토콜이 동작하고 있다는 표시입니다.

```
TLS VPN 캡슐화:
┌─────────────────────────────────────────────────────────────┐
│              원본 IP 패킷 (VPN 트래픽)                       │
├─────────────────────────────────────────────────────────────┤
│                    TLS (암호화)                              │
├─────────────────────────────────────────────────────────────┤
│                    TCP (포트 443)                            │
├─────────────────────────────────────────────────────────────┤
│                       IP                                     │
└─────────────────────────────────────────────────────────────┘
```

방화벽이 보는 것은 바깥쪽의 TCP 포트 443뿐입니다. 포트 443을 차단하면 웹 서비스 전체가 멈추므로, 어떤 방화벽도 이 포트를 막을 수 없고 VPN 트래픽이 자연스럽게 통과합니다.

다만 완벽하지는 않습니다. DPI(Deep Packet Inspection)를 사용하는 방화벽은 포트 번호가 아니라 트래픽 패턴을 분석합니다.

같은 443 포트를 쓰더라도 일반 HTTPS와 VPN 트래픽의 패턴 차이를 탐지하여 차단할 수 있습니다.

---

## OpenVPN

SSL/TLS VPN이 방화벽 우회라는 문제를 해결했다면, 이를 실제로 구현한 소프트웨어는 무엇일까요?

**OpenVPN**은 2001년에 시작된 오픈소스 프로젝트입니다. TLS를 VPN에 처음 적용했으며, 현재까지 가장 널리 사용되는 TLS 기반 VPN입니다.

### OpenVPN의 구조

OpenVPN은 두 가지 채널을 분리합니다.

- **제어 채널**: TLS로 보호되며, 인증과 키 교환을 담당
- **데이터 채널**: 제어 채널에서 협상된 키로 암호화하여 실제 VPN 트래픽을 전송

```
제어 채널:                        데이터 채널:
┌─────────────────────┐          ┌─────────────────────┐
│    키 교환 / 인증    │          │    원본 IP 패킷     │
├─────────────────────┤          ├─────────────────────┤
│        TLS          │          │     자체 암호화      │
├─────────────────────┤          ├─────────────────────┤
│  TCP 또는 UDP       │          │  TCP 또는 UDP       │
│  (기본: UDP 1194)   │          │  (기본: UDP 1194)   │
├─────────────────────┤          ├─────────────────────┤
│         IP          │          │         IP          │
└─────────────────────┘          └─────────────────────┘
```

### OpenVPN의 특징

오픈소스로 누구나 소스 코드를 검토할 수 있고, Windows, macOS, Linux, iOS, Android 등 주요 플랫폼을 지원합니다.

전송 프로토콜로 TCP와 UDP를 모두 지원합니다. 기본은 UDP를 사용하지만, 방화벽이 엄격한 환경에서는 TCP 443 포트로 전환하여 HTTPS 트래픽처럼 통과할 수 있습니다. 인증 방식도 인증서, 비밀번호, 2단계 인증 등을 지원합니다.

다만 성능에는 한계가 있습니다. [Part 1](/dev/network/VPNTunnel-1/)에서 설명한 것처럼, IPsec과 WireGuard는 커널에서 패킷을 바로 처리합니다. OpenVPN은 사용자 공간에서 동작하므로, 패킷이 커널에서 프로세스로, 다시 커널로 전달되어야 합니다. 이 컨텍스트 스위칭이 처리량을 낮춥니다.

설정도 복잡합니다. 수백 개의 옵션이 존재하여 최적의 구성을 찾기까지 시행착오가 필요할 수 있습니다.

TCP 모드를 사용하면 TCP-over-TCP 문제도 발생합니다.

### TCP-over-TCP 문제

OpenVPN을 TCP 모드로 사용하면, 애플리케이션의 TCP 위에 OpenVPN의 TCP가 겹칩니다.

```
┌──────────────────────────┐
│    애플리케이션 데이터     │
├──────────────────────────┤
│        TCP (내부)         │ ← 애플리케이션
├──────────────────────────┤
│     OpenVPN 암호화        │
├──────────────────────────┤
│        TCP (외부)         │ ← OpenVPN
├──────────────────────────┤
│           IP              │
└──────────────────────────┘
```

[Part 1](/dev/network/VPNTunnel-1/)에서 설명한 TCP Meltdown이 발생하는 구조입니다. 패킷 손실이 생기면 내부와 외부 TCP가 모두 재전송을 시도하고, 혼잡 제어가 서로 간섭하여 지연이 급격히 증가합니다.

방화벽 우회가 필요한 환경이 아니라면 UDP 모드를 권장합니다.

---

## WireGuard

IPsec은 설정이 복잡하고, OpenVPN은 사용자 공간에서 동작하여 성능이 제한됩니다.

**WireGuard**는 이 두 문제를 동시에 해결하기 위해 설계된 VPN 프로토콜입니다. 보안 연구자 Jason Donenfeld가 만들었으며, 2020년 Linux 커널 5.6에 정식 포함되었습니다.

### 설계 철학: 단순함

다른 VPN과 코드 크기를 비교하면:

- OpenVPN: 약 100,000줄
- IPsec (strongSwan): 약 400,000줄
- WireGuard: **약 4,000줄**

코드가 적으면 보안 검토 또한 보다 수월해집니다.

### Noise Protocol Framework

TLS나 IKE는 버전, 모드, 암호 알고리즘을 협상하는 과정에서 복잡해지고, 구현 오류가 발생하기 쉽습니다. WireGuard는 이 협상 자체를 없애는 **Noise Protocol Framework**를 사용합니다.

**고정된 암호 조합.** IKE나 TLS는 "AES-128로 할까, AES-256으로 할까, 키 교환은 어떤 방식으로 할까"를 협상합니다. 옵션이 많을수록 잘못된 조합을 선택할 가능성도 커집니다. WireGuard는 협상 없이 미리 정해진 조합만 사용합니다.

**단순한 핸드셰이크.** IKEv2는 먼저 알고리즘을 협상하고(1왕복), 그 다음 신원을 인증합니다(1왕복). 협상이 끝나야 인증을 암호화할 수 있으므로, 4개 메시지(2-RTT)가 필요합니다. WireGuard는 알고리즘이 고정되어 있고, 상대방의 공개키를 설정 시 미리 교환해 두므로 협상과 인증을 한 번에 처리합니다. 2개 메시지, 1-RTT로 충분합니다.

**형식적 검증 가능.** 복잡한 프로토콜은 테스트로 취약점을 찾습니다. 모든 경우를 테스트할 수는 없으므로, 수년 후에 새로운 취약점이 발견되기도 합니다. 단순한 프로토콜은 다릅니다. "제3자가 키를 알아낼 수 없다"는 것을 수학적으로 증명할 수 있습니다. WireGuard의 핸드셰이크는 이런 증명이 완료되었습니다.

앞서 말한 "고정된 암호 조합"은 다음 알고리즘으로 구성됩니다.

- **Curve25519**: 키 교환. [Part 2](/dev/network/VPNTunnel-2/)의 Diffie-Hellman과 같은 역할이지만, 타원곡선을 사용하여 2048비트 대신 256비트 키로 동등한 보안 강도를 제공합니다.
- **ChaCha20-Poly1305**: 암호화와 무결성 검증. Part 2에서 ESP는 암호화 키와 인증 키를 따로 사용했지만, 이 방식은 하나의 키로 둘을 동시에 처리합니다. 하드웨어 가속 없이도 빠르므로 모바일 기기에서도 성능이 좋습니다.
- **BLAKE2s**: 해시. SHA-256보다 빠르면서 동등한 보안 강도를 제공합니다.

<br>

알고리즘이 고정되어 있으므로 사용자가 약한 알고리즘을 실수로 선택할 가능성이 없습니다.

대신 특정 알고리즘에 취약점이 발견되면, 그 알고리즘만 교체할 수 없고 프로토콜 버전 자체를 업그레이드해야 합니다.

### WireGuard 핸드셰이크

```
개시자                                 응답자
    │                                      │
    │ ─── Handshake Initiation ─────────► │
    │     (임시 공개키 + 암호화된 신원)     │
    │                                      │
    │ ◄─── Handshake Response ──────────  │
    │     (임시 공개키 + 확인)              │
    │                                      │
    │ ◄────── 데이터 전송 ──────────►     │
    │                                      │
```

개시자는 응답자의 공개키를 이미 알고 있으므로, 첫 메시지부터 자신의 신원을 암호화하여 보낼 수 있습니다. 응답자가 확인을 보내면 바로 데이터 전송이 시작됩니다.

<br>

### Cryptokey Routing

IPsec에서는 인증(IKE)과 라우팅(트래픽 정책)이 별개 설정이었습니다. 관리자가 인증을 설정하고, 어떤 트래픽을 터널로 보낼지 따로 정의해야 합니다. 두 설정이 맞지 않으면 터널은 수립되었는데 트래픽이 흐르지 않는 문제가 발생합니다.

WireGuard는 **Cryptokey Routing**으로 인증과 라우팅을 하나로 통합합니다. 각 연결 상대(피어)에게 공개키와 허용 IP 범위를 지정합니다.

```
[Peer]
PublicKey = xTIBA5rboUvnH4htodjb60Y7YAf21J7YQMlYhM2IPVY=
AllowedIPs = 10.200.200.2/32, 192.168.0.0/24
```

이 설정은 두 방향으로 동작합니다.

- **수신**: 이 피어에서 온 패킷 중 출발지가 AllowedIPs 범위인 것만 허용
- **송신**: 목적지가 이 범위에 해당하는 패킷을 이 피어로 전송

공개키 하나로 "누구인지"와 "어떤 트래픽을 허용할지"가 동시에 결정됩니다. 별도의 인증 절차가 필요 없습니다.

### WireGuard의 특징

**장점.**

WireGuard는 커널 공간에서 직접 패킷을 처리합니다. OpenVPN처럼 커널과 사용자 공간을 오가는 컨텍스트 스위칭이 없으므로, 처리량이 OpenVPN 대비 3~4배에 달합니다.

피어의 IP 주소가 변경되어도 공개키로 식별하므로 SA를 재협상할 필요가 없습니다. IPsec에서 Wi-Fi→LTE 전환 시 연결이 끊기던 문제가 해결됩니다.

설정 파일도 수십 줄 수준으로 간결하여, 대규모 환경에서도 피어를 쉽게 추가하거나 제거할 수 있습니다.

<br>

**단점.**

2020년 Linux 커널에 포함되어 IPsec(1995년~)이나 OpenVPN(2001년~)에 비해 역사가 짧습니다. 대규모 기업 환경에서의 운영 실적이 아직 축적 중입니다.

암호 알고리즘을 선택할 수 없습니다. 단순함이라는 장점의 이면이기도 한데, 특정 알고리즘(예: AES)을 의무화하는 규제 환경에서는 제약이 됩니다.

전송 프로토콜도 UDP만 지원합니다. 일부 기업이나 공공 네트워크에서는 보안 정책상 TCP 80/443 외의 모든 포트를 차단합니다. 이런 환경에서는 WireGuard를 사용할 수 없습니다. OpenVPN은 TCP 443으로 방화벽을 우회할 수 있지만, WireGuard에는 이 옵션이 없습니다.

또한 동적 IP 할당 기능이 내장되어 있지 않아 별도 도구가 필요합니다.

---

## 프로토콜 비교

앞에서 IPsec의 한계, SSL/TLS VPN의 방화벽 우회, WireGuard의 단순한 설계를 살펴봤습니다. 세 프로토콜은 각각 다른 시대와 요구에서 탄생했고, 모든 상황에서 최선인 프로토콜은 없습니다.

```
┌────────────────┬──────────────┬──────────────┬──────────────┐
│     항목       │    IPsec     │   OpenVPN    │  WireGuard   │
├────────────────┼──────────────┼──────────────┼──────────────┤
│ 계층           │     L3       │    L4/L7     │      L3      │
├────────────────┼──────────────┼──────────────┼──────────────┤
│ 암호화         │   다양함     │   TLS 기반   │   고정 조합   │
├────────────────┼──────────────┼──────────────┼──────────────┤
│ 전송 프로토콜  │ ESP/UDP/TCP  │  TCP/UDP     │   UDP만      │
├────────────────┼──────────────┼──────────────┼──────────────┤
│ 코드 복잡성    │    매우 높음  │     높음     │    낮음      │
├────────────────┼──────────────┼──────────────┼──────────────┤
│ 성능           │     높음     │    중간      │    매우 높음  │
├────────────────┼──────────────┼──────────────┼──────────────┤
│ 방화벽 우회    │    어려움    │    쉬움      │    중간      │
├────────────────┼──────────────┼──────────────┼──────────────┤
│ 모바일 로밍    │    제한적     │   제한적     │    우수      │
├────────────────┼──────────────┼──────────────┼──────────────┤
│ 표준화         │    IETF      │   사실상     │   Linux 커널  │
└────────────────┴──────────────┴──────────────┴──────────────┘
```

<br>

### 사용 사례별 선택

**기업 Site-to-Site VPN**에는 IPsec이 적합합니다. IETF 표준이며 시스코, 주니퍼 등 모든 장비 벤더가 지원하여 이기종 환경에서도 호환됩니다.

**개인 또는 소규모 VPN**에는 WireGuard가 적합합니다. 설정이 단순하고 성능이 높으며 유지보수 부담이 적습니다.

**방화벽 우회가 필요한 환경**에는 OpenVPN(TCP 모드, 포트 443)이 적합합니다. 일반 HTTPS 트래픽과 구분이 어려워 차단을 피할 수 있습니다.

**모바일 환경**에는 WireGuard가 적합합니다. IP 주소가 변경되어도 공개키로 피어를 식별하므로 자동으로 재연결됩니다.

---

## Split Tunneling

프로토콜을 선택한 다음에는 또 하나의 결정이 필요합니다. 모든 트래픽을 VPN으로 보낼 것인가, 일부만 보낼 것인가?

**Split Tunneling**은 목적지에 따라 일부 트래픽만 VPN을 통과시키는 기법입니다.

### Full Tunnel

Full Tunnel 모드에서는 사용자의 모든 인터넷 트래픽이 VPN을 통과합니다.

<br>

```
사용자 ──► VPN ──► 인터넷
          (모든 트래픽)
```

모든 트래픽이 암호화되므로 보안 범위가 넓고, 라우팅 정책도 단순합니다.

하지만 유튜브 스트리밍이나 OS 업데이트 같은 대용량 트래픽까지 VPN을 경유하면 어떻게 될까요? 서버 자원을 불필요하게 소모하고, 사용자 체감 지연이 증가합니다.
지리적으로 먼 VPN 서버를 경유하면, 사용자 가까이에 콘텐츠를 배치해두는 CDN(Content Delivery Network)의 이점을 활용하지 못합니다.

### Split Tunnel

Split Tunnel 모드에서는 사내 리소스로 향하는 트래픽만 VPN을 통과하고, 일반 인터넷 트래픽은 직접 연결합니다.

```
사용자 ──► VPN ──► 회사 내부 (10.0.0.0/8)
      │
      └──────────► 인터넷 (직접)
```

예를 들어, 사내 네트워크(10.0.0.0/8 대역)로 향하는 트래픽만 VPN을 통과시키고, 유튜브나 구글 검색은 로컬 인터넷으로 직접 보냅니다.
VPN 서버 부하가 줄어들고, 일반 웹 서핑이나 스트리밍 지연도 낮아집니다.

하지만 VPN 밖의 트래픽은 암호화되지 않으므로, 공용 Wi-Fi 같은 신뢰할 수 없는 네트워크에서는 위험이 남습니다.
어떤 트래픽을 VPN으로 보낼지 정책 설계도 복잡해질 수 있습니다.

### 역 Split Tunnel

보안 정책상 대부분의 트래픽을 VPN으로 보호하되, 특정 서비스만 예외로 두고 싶다면 어떻게 할까요? 역 Split Tunnel은 기본적으로 모든 트래픽을 VPN으로 보내되, 지정한 트래픽만 VPN을 **우회**하도록 설정합니다.

```
예: 화상 회의(Zoom, Teams) 트래픽은 VPN 우회
    지연에 민감한 실시간 트래픽의 품질 확보
```

Full Tunnel의 보안 범위를 유지하면서, 지연에 민감하거나 대역폭이 큰 특정 서비스만 예외 처리할 수 있습니다.

다만 우회 대상으로 지정한 서비스의 트래픽은 VPN 보호 밖에 놓이므로, 예외 목록을 최소한으로 유지하고 주기적으로 검토해야 합니다.

---

## VPN과 Zero Trust

지금까지 VPN 프로토콜의 암호화와 터널링을 살펴봤습니다. 하지만 터널을 암호화하는 것과 터널 안쪽에서 누가 무엇에 접근할 수 있는지는 별개의 문제입니다.

### 전통적 경계 보안

전통적인 VPN은 하나의 가정 위에 세워졌습니다. 내부 네트워크는 안전하고, 외부는 위험하다는 **경계 보안(Perimeter Security)** 모델입니다.

<br>

```
┌──────────────────────────────────────┐
│           신뢰된 내부 네트워크        │
│                                      │
│     서버      데이터베이스    사용자  │
│                                      │
└───────────────────┬──────────────────┘
                    │ 방화벽/VPN
                    │
        ────────────┴────────────────
               신뢰되지 않은 외부
```

VPN으로 연결에 성공하면 사용자는 내부 네트워크의 일원으로 간주됩니다. 인증은 연결 시점에만 이루어지고, 이후에는 내부 리소스에 자유롭게 접근할 수 있습니다.

### 경계 보안의 한계

하지만 이 모델은 현대 환경에서 한계를 드러냈습니다.
실제 대형 보안 사고는 외부 침입보다 내부에서 시작되는 경우가 많았습니다. 2013년 에드워드 스노든 사건은 정당한 접근 권한을 가진 내부자가 그 권한을 남용한 사례이고, 2020년 SolarWinds 해킹은 공급망을 통해 내부에 침투한 공격자가 네트워크 내 다른 시스템으로 횡적 이동(lateral movement)하며 피해를 확대한 사례입니다.
경계 보안은 이 두 가지 유형 모두에 취약했습니다.

<br>

**내부 위협.** 악의적인 내부자나 악성코드에 감염된 장치가 이미 내부에 있으면 방어할 수 없습니다. 경계 보안은 "밖에서 안으로"의 침입만 막습니다.

**과도한 접근 권한.** VPN 연결만 성공하면 내부 네트워크 전체에 접근할 수 있습니다. 재무팀 직원이 개발 서버에 접근하거나, 인턴이 경영 데이터베이스에 접근할 수 있습니다.

**경계의 모호화.** 클라우드 서비스 확산과 재택근무 증가로 "내부"와 "외부"의 구분이 무의미해졌습니다. 회사 데이터가 AWS에, 직원은 카페에 있다면 경계를 어디에 그어야 하는지 불분명합니다.

### Zero Trust 모델

경계 보안의 한계를 근본적으로 해결하려면, 전제 자체를 바꿔야 합니다.

**Zero Trust** 모델은 "내부는 안전하다"는 가정을 폐기합니다. 핵심 원칙은 "절대 신뢰하지 말고, 항상 검증하라(Never Trust, Always Verify)"입니다.

<br>

```
┌─────────────────────────────────────────────────────────────┐
│                    Zero Trust 환경                          │
│                                                             │
│  사용자 ──[검증]──► 정책엔진 ──[검증]──► 리소스            │
│                        │                                    │
│              신원, 장치, 컨텍스트 확인                      │
│              최소 권한 부여                                 │
│              지속적 검증                                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

Zero Trust는 "네트워크 내부에 있다"는 이유만으로 신뢰를 부여하지 않습니다. 사용자의 신원, 장치 상태, 접근 시간과 위치 등을 확인한 뒤에야 접근을 허용합니다.

구글이 2014년에 공개한 BeyondCorp이 대표적인 구현 사례입니다.

**항상 검증.** 네트워크 위치와 관계없이 모든 접근 요청을 검증합니다. 사무실 안에서 접속하든, 카페에서 접속하든 같은 수준의 인증을 거칩니다.

**최소 권한.** 작업 수행에 필요한 최소한의 권한만 부여합니다. 재무팀은 재무 시스템에만, 개발팀은 개발 서버에만 접근할 수 있습니다.

**마이크로 세분화.** 네트워크를 작은 단위로 분리하여 횡적 이동을 차단합니다. 하나의 시스템이 침해되어도 다른 시스템으로 확산되지 않도록 격리하는 것입니다.

**침해 가정.** 이미 침해되었다고 가정하고 피해를 최소화하도록 설계합니다. "방어에 성공한다"가 아니라 "침해 시 피해를 제한한다"가 목표이기 때문입니다.

### VPN의 역할 변화

Zero Trust 환경에서 VPN의 역할은 변화하고 있습니다.
전통적 VPN이 네트워크 전체에 대한 접근을 제공했다면, **ZTNA(Zero Trust Network Access)**는 사용자가 필요로 하는 특정 애플리케이션에만 접근을 허용합니다.
Zscaler Private Access나 Cloudflare Access 같은 서비스가 대표적인 ZTNA 구현체입니다.

예를 들어, ZTNA 환경에서는 연결 후에도 다음과 같은 제어가 적용됩니다.

사용자 역할에 따라 접근 범위가 달라집니다. 마케팅팀 직원은 분석 대시보드에 접근할 수 있지만, 프로덕션 데이터베이스에는 접근할 수 없습니다.

접속 시간대, 장치 보안 상태, 지리적 위치에 따라 동적으로 접근을 제어하기도 합니다. OS 패치가 오래된 노트북에서 접속하면 접근이 제한될 수 있습니다.

모든 접근 시도는 상세히 로깅되고 실시간으로 모니터링됩니다.

---

## 마무리: 단순함이 보안이다

이 글에서 살펴본 내용을 정리합니다.

- **IPsec**: 벤더 호환성이 높고 보안이 검증되었지만, 설정이 복잡하고 모바일 환경에서 제약이 있습니다.
- **SSL/TLS VPN(OpenVPN)**: 방화벽 우회가 쉽지만, 사용자 공간에서 동작하여 성능 오버헤드가 있습니다.
- **WireGuard**: 4,000줄의 코드, 고정된 암호 조합, 1-RTT 핸드셰이크로 단순함과 성능을 확보했습니다.
- **Split Tunneling**: 트래픽을 선별적으로 VPN에 통과시켜 보안 범위와 성능 사이의 균형을 잡습니다.
- **Zero Trust와 ZTNA**: VPN은 네트워크 전체가 아니라 개별 리소스에 대한 접근을 제어하는 방향으로 변화하고 있습니다.

<br>

WireGuard가 보여준 교훈은 VPN 설계를 넘어 보안 소프트웨어 전반에 적용됩니다.

코드가 적을수록 잠재적인 버그와 취약점도 줄어듭니다. 4,000줄은 한 명이 검토할 수 있지만, 40만 줄은 불가능합니다.

협상 가능한 옵션이 많을수록 공격자가 노릴 수 있는 약점도 많아집니다. IPsec의 다양한 알고리즘 조합 중 약한 조합을 강제하는 다운그레이드 공격이 대표적입니다.

현대 암호화 알고리즘은 충분히 빠르므로, 성능을 이유로 보안을 타협할 필요가 없습니다. ChaCha20은 하드웨어 가속 없이도 소프트웨어만으로 고속 처리가 가능하기 때문입니다.

<br>

Zero Trust 환경에서 VPN은 유일한 보안 수단이 아니라 여러 보안 레이어 중 하나입니다. 단순하고 검증 가능한 VPN 위에 지속적 인증과 최소 권한 정책을 더하는 것, 그것이 현대 네트워크 보안이 나아가는 방향입니다.

<br>

---

**관련 글**
- [네트워크 보안의 원리 (2) - TLS와 인증서 체계](/dev/network/NetworkSecurity-2/)
- [NAT와 방화벽 (2) - 방화벽의 원리와 상태 추적](/dev/network/NATFirewall-2/)

**시리즈**
- [VPN과 터널링 (1) - 터널링의 원리](/dev/network/VPNTunnel-1/)
- [VPN과 터널링 (2) - IPsec의 구조](/dev/network/VPNTunnel-2/)
- VPN과 터널링 (3) - 현대 VPN 기술 (현재 글)
